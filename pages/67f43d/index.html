<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Activity基础 | 极速cv</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-8621788234752924" async="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924" crossorigin="anonymous"></script>
    <meta name="description" content="CV操作好，下班就是早。">
    <meta name="keywords" content="cv,fastcv,个人博客">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#7b074b">
    
    <link rel="preload" href="/assets/css/0.styles.d1bed3dc.css" as="style"><link rel="preload" href="/assets/js/app.e1bc90e6.js" as="script"><link rel="preload" href="/assets/js/2.2dfa729a.js" as="script"><link rel="preload" href="/assets/js/27.03291f82.js" as="script"><link rel="prefetch" href="/assets/js/10.35c27e70.js"><link rel="prefetch" href="/assets/js/11.cc577099.js"><link rel="prefetch" href="/assets/js/12.a6e96cf9.js"><link rel="prefetch" href="/assets/js/13.62d81f10.js"><link rel="prefetch" href="/assets/js/14.0634038b.js"><link rel="prefetch" href="/assets/js/15.9b738075.js"><link rel="prefetch" href="/assets/js/16.318f5092.js"><link rel="prefetch" href="/assets/js/17.ef4612a8.js"><link rel="prefetch" href="/assets/js/18.140f718a.js"><link rel="prefetch" href="/assets/js/19.9d1daaf3.js"><link rel="prefetch" href="/assets/js/20.4b6feb7d.js"><link rel="prefetch" href="/assets/js/21.0ed2f2d5.js"><link rel="prefetch" href="/assets/js/22.94066693.js"><link rel="prefetch" href="/assets/js/23.d09c9beb.js"><link rel="prefetch" href="/assets/js/24.1fdf3365.js"><link rel="prefetch" href="/assets/js/25.1b7a2740.js"><link rel="prefetch" href="/assets/js/26.4cfbc8ca.js"><link rel="prefetch" href="/assets/js/28.ee2b7004.js"><link rel="prefetch" href="/assets/js/29.2c8138ce.js"><link rel="prefetch" href="/assets/js/3.4878f8f3.js"><link rel="prefetch" href="/assets/js/30.b1298471.js"><link rel="prefetch" href="/assets/js/31.da38da5f.js"><link rel="prefetch" href="/assets/js/32.3d6eb133.js"><link rel="prefetch" href="/assets/js/33.b6d94bfc.js"><link rel="prefetch" href="/assets/js/34.b6f3263e.js"><link rel="prefetch" href="/assets/js/35.97f4d2e7.js"><link rel="prefetch" href="/assets/js/36.b02e62ca.js"><link rel="prefetch" href="/assets/js/37.d2d7efa3.js"><link rel="prefetch" href="/assets/js/38.6ae288c0.js"><link rel="prefetch" href="/assets/js/39.4fc76e63.js"><link rel="prefetch" href="/assets/js/4.f7f2d443.js"><link rel="prefetch" href="/assets/js/40.284cd7ad.js"><link rel="prefetch" href="/assets/js/41.29df7654.js"><link rel="prefetch" href="/assets/js/42.ba55f3be.js"><link rel="prefetch" href="/assets/js/43.b7195909.js"><link rel="prefetch" href="/assets/js/44.e6098941.js"><link rel="prefetch" href="/assets/js/45.40b8ce81.js"><link rel="prefetch" href="/assets/js/46.f83bf354.js"><link rel="prefetch" href="/assets/js/47.5e550ac5.js"><link rel="prefetch" href="/assets/js/48.c4fb8ab6.js"><link rel="prefetch" href="/assets/js/49.a43055dc.js"><link rel="prefetch" href="/assets/js/5.97835dc3.js"><link rel="prefetch" href="/assets/js/50.9a846d99.js"><link rel="prefetch" href="/assets/js/51.d96445d2.js"><link rel="prefetch" href="/assets/js/52.b569403d.js"><link rel="prefetch" href="/assets/js/53.3ed54ad9.js"><link rel="prefetch" href="/assets/js/54.eb8b3273.js"><link rel="prefetch" href="/assets/js/55.f8d65037.js"><link rel="prefetch" href="/assets/js/56.eb6ad4c4.js"><link rel="prefetch" href="/assets/js/57.b209646e.js"><link rel="prefetch" href="/assets/js/58.b2d0e592.js"><link rel="prefetch" href="/assets/js/59.4af484c7.js"><link rel="prefetch" href="/assets/js/6.866ee092.js"><link rel="prefetch" href="/assets/js/60.671eff60.js"><link rel="prefetch" href="/assets/js/61.400e04cf.js"><link rel="prefetch" href="/assets/js/62.f09e41bc.js"><link rel="prefetch" href="/assets/js/63.90e1dd5a.js"><link rel="prefetch" href="/assets/js/64.5a32ed9a.js"><link rel="prefetch" href="/assets/js/65.8e40013a.js"><link rel="prefetch" href="/assets/js/66.89fc2763.js"><link rel="prefetch" href="/assets/js/67.58b9ef6f.js"><link rel="prefetch" href="/assets/js/68.d01caaf5.js"><link rel="prefetch" href="/assets/js/69.383945cb.js"><link rel="prefetch" href="/assets/js/7.abd87bf8.js"><link rel="prefetch" href="/assets/js/70.a5af60f8.js"><link rel="prefetch" href="/assets/js/71.4c312526.js"><link rel="prefetch" href="/assets/js/72.f250e38c.js"><link rel="prefetch" href="/assets/js/73.d10d7dda.js"><link rel="prefetch" href="/assets/js/74.afa7a2e8.js"><link rel="prefetch" href="/assets/js/75.b52d9fa5.js"><link rel="prefetch" href="/assets/js/76.64654eb8.js"><link rel="prefetch" href="/assets/js/77.b377a166.js"><link rel="prefetch" href="/assets/js/78.f7463089.js"><link rel="prefetch" href="/assets/js/79.051facd4.js"><link rel="prefetch" href="/assets/js/8.ab056171.js"><link rel="prefetch" href="/assets/js/80.16893adb.js"><link rel="prefetch" href="/assets/js/81.4c1bc8e9.js"><link rel="prefetch" href="/assets/js/82.6afcb616.js"><link rel="prefetch" href="/assets/js/83.5324961c.js"><link rel="prefetch" href="/assets/js/84.2eb2e5d2.js"><link rel="prefetch" href="/assets/js/85.31056335.js"><link rel="prefetch" href="/assets/js/86.46ee7480.js"><link rel="prefetch" href="/assets/js/87.ee19866d.js"><link rel="prefetch" href="/assets/js/9.b608f08b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d1bed3dc.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="极速cv" class="logo"> <span class="site-name can-hide">极速cv</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/article/" class="nav-link">编程基础</a></div><div class="nav-item"><a href="/note/" class="nav-link">Android</a></div><div class="nav-item"><a href="/idea/" class="nav-link">iOS</a></div><div class="nav-item"><a href="/other/" class="nav-link">前端</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">软实力</a></div> <a href="https://github.com/CatCatBug/fastcv-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>极速cv</h3> <span>CV操作就是好~</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/article/" class="nav-link">编程基础</a></div><div class="nav-item"><a href="/note/" class="nav-link">Android</a></div><div class="nav-item"><a href="/idea/" class="nav-link">iOS</a></div><div class="nav-item"><a href="/other/" class="nav-link">前端</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">软实力</a></div> <a href="https://github.com/CatCatBug/fastcv-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>四大组件</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Application</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Activity</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67f43d/" aria-current="page" class="active sidebar-link">Activity基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#正常生命周期流程" class="sidebar-link">正常生命周期流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#a进入b" class="sidebar-link">A进入B</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#b退到后台" class="sidebar-link">B退到后台</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#b返回前台" class="sidebar-link">B返回前台</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#b返回a" class="sidebar-link">B返回A</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#a出现不完全覆盖弹窗时" class="sidebar-link">A出现不完全覆盖弹窗时</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#特殊情况" class="sidebar-link">特殊情况</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#activity重新启动" class="sidebar-link">Activity重新启动</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#启动模式导致activity实例复用" class="sidebar-link">启动模式导致Activity实例复用</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#其他回调" class="sidebar-link">其他回调</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#onenteranimationcomplete" class="sidebar-link">onEnterAnimationComplete()</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#onlowmemory" class="sidebar-link">onLowMemory()</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#ontrimmemory-level-int" class="sidebar-link">onTrimMemory(level: Int)</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#onconfigurationchanged-newconfig-configuration" class="sidebar-link">onConfigurationChanged(newConfig: Configuration)</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#onwindowfocuschanged-hasfocus-boolean" class="sidebar-link">onWindowFocusChanged(hasFocus: Boolean)</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#启动模式" class="sidebar-link">启动模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#standard" class="sidebar-link">standard</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#singletop" class="sidebar-link">singleTop</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#singletask" class="sidebar-link">singleTask</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#singleinstance" class="sidebar-link">singleInstance</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#singleinstancepertask" class="sidebar-link">singleInstancePerTask</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#启动其他应用" class="sidebar-link">启动其他应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#android-allowtaskreparenting" class="sidebar-link">android:allowTaskReparenting</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#activity的启动方式" class="sidebar-link">Activity的启动方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#显式启动" class="sidebar-link">显式启动</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#隐式启动" class="sidebar-link">隐式启动</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#启动其他应用-2" class="sidebar-link">启动其他应用</a></li><li class="sidebar-sub-header level4"><a href="/pages/67f43d/#包名-特定activity名拉起" class="sidebar-link">包名，特定Activity名拉起</a></li><li class="sidebar-sub-header level4"><a href="/pages/67f43d/#包名拉起-这里就是进去启动页" class="sidebar-link">包名拉起（这里就是进去启动页）</a></li><li class="sidebar-sub-header level4"><a href="/pages/67f43d/#url拉起" class="sidebar-link">url拉起</a></li><li class="sidebar-sub-header level3"><a href="/pages/67f43d/#子进程启动activity" class="sidebar-link">子进程启动Activity</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#a-b" class="sidebar-link">A -&gt; B</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#b-返回值给-a" class="sidebar-link">B 返回值给 A</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#activity-results-api写法" class="sidebar-link">Activity Results API写法</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#app启动流程" class="sidebar-link">APP启动流程</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#activity启动流程" class="sidebar-link">Activity启动流程</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#生命周期回调的源码逻辑梳理" class="sidebar-link">生命周期回调的源码逻辑梳理</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#如何退出app后不再最近使用中保留" class="sidebar-link">如何退出app后不再最近使用中保留</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#屏蔽所有configchange项" class="sidebar-link">屏蔽所有configChange项</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#硬件加速" class="sidebar-link">硬件加速</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#禁用多窗口" class="sidebar-link">禁用多窗口</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#设置屏幕方向" class="sidebar-link">设置屏幕方向</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#activity不保存数据-避免fragment重新加载出现问题" class="sidebar-link">Activity不保存数据，避免Fragment重新加载出现问题</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#设置通用主题" class="sidebar-link">设置通用主题</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#activity的键盘弹出-收起的处理" class="sidebar-link">Activity的键盘弹出/收起的处理</a></li><li class="sidebar-sub-header level2"><a href="/pages/67f43d/#将一个-activity-设置成窗口的样式" class="sidebar-link">将一个 Activity 设置成窗口的样式</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>BroadcastReceiver</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>ContentProvider</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Service</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/pages/3e5b1b/" class="sidebar-link">Intent-filter</a></li><li><a href="/pages/f7396a/" class="sidebar-link">URL与URI基础</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Fragment</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>UI控件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据持久化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>传感器及连接性</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三方框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编码工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>必会原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编码规范与技巧</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="8498052873"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/note/#Android" data-v-06225672>Android</a></li><li data-v-06225672><a href="/note/#四大组件" data-v-06225672>四大组件</a></li><li data-v-06225672><a href="/note/#Activity" data-v-06225672>Activity</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://fastcv.cc/" target="_blank" title="作者" class="beLink" data-v-06225672>fastcv</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-10-10</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Activity基础<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="写在前面"><a href="#写在前面" class="header-anchor">#</a> 写在前面</h1> <p>我确实无法定位Activity的功能职责，因为我讲不清楚它到底是什么？</p> <p>从代码层次看，它是个基类，我们实现一个新的界面的时候就是从继承它开始，然后结合的它生命周期的接口进行功能开发。</p> <p>从它的职责上看，它就是一个用户交互界面，负责处理用户的点击、滑动、输入等事件并给出相应的UI效果响应。</p> <p>从设计的角度来看，它是窗口(Window)的给出来的代理使者，将复杂的UI相关的数据处理集成在底层， 然后提供上层一个简单的接口<code>setContentView(R.layout.activity_main)</code>来实现界面的搭建。</p> <p>所以，它的基本使用很简单，我们开发者只需要简单一行代码就可以写个界面在手机上跑出效果来了。跑出来的这个界面就是Activity。</p> <p>那么，在应用开发层面，这个庞大的类我们需要掌握多少呢？就我而言，我认为以下几个点必须要掌握：</p> <ul><li>生命周期：在不同的场景下，会有怎样的回调；回调的顺序是怎么样的；结合View的绘制过程，什么时候能对View做操作?</li> <li>任务栈：如果看过一些Activity的文章，就会对任务栈有点印象，但不多！但是这个确认是一个需要掌握的知识点，无它，这涉及到面试里面的必问题：Activity的启动模式有哪几种？简单说下。</li> <li>Activity之间的数据传输：这个很常见了</li> <li>待补充...</li></ul> <p>如果想再深入点，可以学习下以下知识点：</p> <ul><li>APP启动流程</li> <li>Activity启动流程</li> <li>生命周期回调的源码逻辑梳理</li></ul> <h1 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h1> <p>生命周期的文章有很多，我这里没有产生新的东西，如果你已经掌握了，可以直接看下个章节。</p> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/activity_lifecycle.png" alt=""></p> <p>首先，从官网盗张图来镇场子。</p> <p>从图中，可以看出，主要的生命周期有以下几个：</p> <ul><li>onCreate</li> <li>onStart</li> <li>onRestart</li> <li>onResume</li> <li>onPause</li> <li>onStop</li> <li>onDestory</li></ul> <p>从生命周期的角度来看，只有这几个是没有问题的，但是光凭这几个，我们还是无法满足日常开发的一些要求。所以我们在这个基础上面加了以下几个方法回调：</p> <ul><li>attachBaseContext(newBase: Context?)</li> <li>onAttachedToWindow()</li> <li>onDetachedFromWindow()</li> <li>onApplyThemeResource(theme: Resources.Theme?, resid: Int, first: Boolean)</li> <li>onNewIntent(intent: Intent?)</li></ul> <p>还有一部分不常用的但是我觉有有必要记住的，下面会对这部分的回调单独讲解。</p> <ul><li>onEnterAnimationComplete()</li> <li>onLowMemory()</li> <li>onTrimMemory(level: Int)</li> <li>onConfigurationChanged(newConfig: Configuration)</li> <li>onWindowFocusChanged(hasFocus: Boolean)</li></ul> <h2 id="正常生命周期流程"><a href="#正常生命周期流程" class="header-anchor">#</a> 正常生命周期流程</h2> <p>我们假设现在有AActivity，BActivity两个界面。</p> <h3 id="a进入b"><a href="#a进入b" class="header-anchor">#</a> A进入B</h3> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013111042304.png" alt="image-20221013111042304"></p> <h3 id="b退到后台"><a href="#b退到后台" class="header-anchor">#</a> B退到后台</h3> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013111532302.png" alt="image-20221013111532302"></p> <h3 id="b返回前台"><a href="#b返回前台" class="header-anchor">#</a> B返回前台</h3> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013111451680.png" alt="image-20221013111451680"></p> <h3 id="b返回a"><a href="#b返回a" class="header-anchor">#</a> B返回A</h3> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013111822089.png" alt="image-20221013111822089"></p> <h3 id="a出现不完全覆盖弹窗时"><a href="#a出现不完全覆盖弹窗时" class="header-anchor">#</a> A出现不完全覆盖弹窗时</h3> <p>这里需要注意的是：</p> <p><strong>普通弹窗不会回调到 onPause ！！！</strong></p> <p><strong>普通弹窗不会回调到 onPause ！！！</strong></p> <p><strong>普通弹窗不会回调到 onPause ！！！</strong></p> <p>这里我是用的弹出权限申请弹窗测试的。</p> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013114412558.png" alt="image-20221013114412558"></p> <h2 id="特殊情况"><a href="#特殊情况" class="header-anchor">#</a> 特殊情况</h2> <p>特殊情况我把它分为两种：</p> <ul><li>Activity重新启动：也就是其他文章常说Activity在配置发生变化后重新创建的情况</li> <li>启动模式导致Activity实例复用：</li></ul> <h3 id="activity重新启动"><a href="#activity重新启动" class="header-anchor">#</a> Activity重新启动</h3> <p>引起这个现象的原因有很多，我们这里举个最常见的场景来验证它：旋转屏幕。</p> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013112805101.png" alt="image-20221013112805101"></p> <h3 id="启动模式导致activity实例复用"><a href="#启动模式导致activity实例复用" class="header-anchor">#</a> 启动模式导致Activity实例复用</h3> <p>启动模式的影响在两个方面：</p> <ul><li>Activity是否重用</li> <li>任务栈的处理</li></ul> <p>这里我们就不考虑任务栈的问题了，只考虑一种情况：Activity重用情况下的生命周期。</p> <p>那么自己跳转自己的生命周期如下：</p> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/image-20221013133904769.png" alt="image-20221013133904769"></p> <p>这里，我们就补充到了一个新的回调：</p> <ul><li>onNewIntent(intent: Intent?)</li></ul> <p>当复用Activity实例时，就会调用到onNewIntent回调方法。</p> <h2 id="其他回调"><a href="#其他回调" class="header-anchor">#</a> 其他回调</h2> <h3 id="onenteranimationcomplete"><a href="#onenteranimationcomplete" class="header-anchor">#</a> onEnterAnimationComplete()</h3> <p>从名字可以看出：进入动画完成回调</p> <p>其实，这里的进入动画是window的进入动画，简单来说就是，我们的Activity切换到前台后会调用它。（就是Activity的Window从后台切换到前台时）</p> <h3 id="onlowmemory"><a href="#onlowmemory" class="header-anchor">#</a> onLowMemory()</h3> <p>从名字可以看出：低内存回调</p> <p>在这个时候，我们就需要对我们的app做一下内存清除的处理，不然的话，就有可能被kill掉。</p> <h3 id="ontrimmemory-level-int"><a href="#ontrimmemory-level-int" class="header-anchor">#</a> onTrimMemory(level: Int)</h3> <p>从名字可以看出：内存修剪回调</p> <p>作用是提醒开发者系统内存不足了。</p> <p>其中，level的参数有以下几种：</p> <ul><li>TRIM_MEMORY_UI_HIDDEN：App 的所有 UI 界面被隐藏，最常见的就是 App 被 home 键或者 back 键，置换到后台了。</li> <li>TRIM_MEMORY_RUNNING_MODERATE：表示 App 正常运行，并且不会被杀掉，但是目前手机内存已经有点低了，系统可能会根据 LRU List 来开始杀进程。</li> <li>TRIM_MEMORY_RUNNING_LOW：表示 App正常运行，并且不会被杀掉。但是目前手机内存已经非常低了。</li> <li>TRIM_MEMORY_RUNNING_CRITICAL：表示 App 正在正常运行，但是系统已经开始根据 LRU List 的缓存规则杀掉了一部分缓存的进程。这个时候应该尽可能的释放掉不需要的内存资源，否者系统可能会继续杀掉其他缓存中的进程。</li> <li>TRIM_MEMORY_BACKGROUND：表示 App 退出到后台，并且已经处于 LRU List 比较靠后的位置，暂时前面还有一些其他的 App 进程，暂时不用担心被杀掉</li> <li>TRIM_MENORY_MODERATE：表示 App 退出到后台，并且已经处于 LRU List 中间的位置，如果手机内存仍然不够的话，还是有被杀掉的风险的。</li> <li>TRIM_MEMORY_COMPLETE：表示 App 退出到后台，并且已经处于 LRU List 比较考靠前的位置，并且手机内存已经极低，随时都有可能被系统杀掉。</li></ul> <p>系统中LowMemoryKiller 策略：App 退出到后台之后不占用 cpu 资源但是任然会占用内存空间。当系统内存不足的时候，会按照优先级清理进程。</p> <p>App 将内存使用降低可以提高优先级，实现不被系统回收的功能。</p> <h3 id="onconfigurationchanged-newconfig-configuration"><a href="#onconfigurationchanged-newconfig-configuration" class="header-anchor">#</a> onConfigurationChanged(newConfig: Configuration)</h3> <p>从名字可以看出：配置改变回调</p> <p>不过在回调方法之前，我们首先需要在清单文件中配置哪些变化需要回调。</p> <p>列出 Activity 将自行处理的配置变更。在运行时发生配置变更时，默认情况下会关闭 activity 并将其重启，但使用该属性声明配置将阻止 activity 重启。相反，activity 会保持运行状态，并且系统会调用其 <code>onConfigurationChanged()</code> 方法。</p> <p>任何或所有下列字符串均是该属性的有效值。若有多个值，则使用“<code>|</code>”进行分隔，例如“<code>locale|navigation|orientation</code>”。</p> <table><thead><tr><th style="text-align:left;">值</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;">“<code>density</code>”</td> <td style="text-align:left;">显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 API 级别 24 中引入。</td></tr> <tr><td style="text-align:left;">“<code>fontScale</code>”</td> <td style="text-align:left;">字体缩放系数发生变更 - 用户已选择新的全局字号。</td></tr> <tr><td style="text-align:left;">“<code>keyboard</code>”</td> <td style="text-align:left;">键盘类型发生变更 - 例如，用户插入外置键盘。</td></tr> <tr><td style="text-align:left;">“<code>keyboardHidden</code>”</td> <td style="text-align:left;">键盘无障碍功能发生变更 - 例如，用户显示硬键盘。</td></tr> <tr><td style="text-align:left;">“<code>layoutDirection</code>”</td> <td style="text-align:left;">布局方向发生变更 - 例如，自从左至右 (LTR) 更改为从右至左 (RTL)。在 API 级别 17 中引入。</td></tr> <tr><td style="text-align:left;">“<code>locale</code>”</td> <td style="text-align:left;">语言区域发生变更 - 用户已为文本选择新的显示语言。</td></tr> <tr><td style="text-align:left;">“<code>mcc</code>”</td> <td style="text-align:left;">IMSI 移动设备国家/地区代码 (MCC) 发生变更 - 检测到 SIM 并更新 MCC。</td></tr> <tr><td style="text-align:left;">“<code>mnc</code>”</td> <td style="text-align:left;">IMSI 移动设备网络代码 (MNC) 发生变更 - 检测到 SIM 并更新 MNC。</td></tr> <tr><td style="text-align:left;">“<code>navigation</code>”</td> <td style="text-align:left;">导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。）</td></tr> <tr><td style="text-align:left;">“<code>orientation</code>”</td> <td style="text-align:left;">屏幕方向发生变更 - 用户旋转设备。<strong>注意</strong>：如果应用面向 Android 3.2（API 级别 13）或更高版本的系统，则还应声明 <code>&quot;screenLayout&quot;</code> 和 <code>&quot;screenSize&quot;</code> 配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。</td></tr> <tr><td style="text-align:left;">“<code>screenLayout</code>”</td> <td style="text-align:left;">屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。</td></tr> <tr><td style="text-align:left;">“<code>screenSize</code>”</td> <td style="text-align:left;">当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在 API 级别 13 中引入。</td></tr> <tr><td style="text-align:left;">“<code>smallestScreenSize</code>”</td> <td style="text-align:left;">物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应 <a href="https://developer.android.com/guide/topics/resources/providing-resources#SmallestScreenWidthQualifier" target="_blank" rel="noopener noreferrer">smallestWidth 配置<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的变化。在 API 级别 13 中引入。</td></tr> <tr><td style="text-align:left;">“<code>touchscreen</code>”</td> <td style="text-align:left;">触摸屏发生变更。（这种情况通常不会发生。）</td></tr> <tr><td style="text-align:left;">“<code>uiMode</code>”</td> <td style="text-align:left;">界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅 <code>UiModeManager</code>。在 API 级别 8 中引入。</td></tr></tbody></table> <p>所有这些配置变更都可能影响应用所看到的资源值。因此，调用 <code>onConfigurationChanged()</code> 时，通常有必要再次检索所有资源（包括视图布局、可绘制对象等），以正确处理变更。</p> <h3 id="onwindowfocuschanged-hasfocus-boolean"><a href="#onwindowfocuschanged-hasfocus-boolean" class="header-anchor">#</a> onWindowFocusChanged(hasFocus: Boolean)</h3> <p>这个回调就更容易理解了，在当前Activity的焦点变化之后就会回调。</p> <h1 id="任务栈"><a href="#任务栈" class="header-anchor">#</a> 任务栈</h1> <p>首先，什么是任务栈。</p> <p>任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。</p> <p><img src="https://xh-blog.oss-cn-guangzhou.aliyuncs.com/diagram_backstack.png" alt=""></p> <p>那我们怎么知道，当前app的任务栈的内容呢？ 官方提供了这样的命令给到我们</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>adb shell dumpsys activity package &lt;your.package.name&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在输出结果里面，我们可以找到以下信息（简化版）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{4d18976 #798 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}
    * Hist  #3: ActivityRecord{aa59564 u0 cc.fastcv.codelab/.DActivity} t798}
    * Hist  #2: ActivityRecord{bca6d96 u0 cc.fastcv.codelab/.CActivity} t798}
    * Hist  #1: ActivityRecord{c4e05b u0 cc.fastcv.codelab/.BActivity} t798}
    * Hist  #0: ActivityRecord{35fcb7f u0 cc.fastcv.codelab/.MainActivity} t798}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>那这个模块为啥要单独拎出来说呢？这个就涉及到了面试的另外一个重点，Activity的启动模式了。</p> <h2 id="启动模式"><a href="#启动模式" class="header-anchor">#</a> 启动模式</h2> <p>安卓官方文档里面，关于Activity配置的启动模式有五种：</p> <ul><li>standard</li> <li>singleTop</li> <li>singleTask</li> <li>singleInstance</li> <li>singleInstancePerTask</li></ul> <h3 id="standard"><a href="#standard" class="header-anchor">#</a> standard</h3> <p>使用此启动模式的Activity可以实例化多次，每次启动都会在任务栈顶新增一个实例，比如现有有 MainActivity、BActivity、CActivity、DActivity四个Activity。</p> <p>启动顺序为： Main -&gt; B -&gt; C -&gt; D</p> <p>都是standard启动模式时的任务栈是</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{4d18976 #798 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}
    * Hist  #3: ActivityRecord{aa59564 u0 cc.fastcv.codelab/.DActivity} t798}
    * Hist  #2: ActivityRecord{bca6d96 u0 cc.fastcv.codelab/.CActivity} t798}
    * Hist  #1: ActivityRecord{c4e05b u0 cc.fastcv.codelab/.BActivity} t798}
    * Hist  #0: ActivityRecord{35fcb7f u0 cc.fastcv.codelab/.MainActivity} t798}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="singletop"><a href="#singletop" class="header-anchor">#</a> singleTop</h3> <p>这种启动模式跟standard其实差不多，唯一不同的是，如果当前栈顶的示例就是当前Activity的示例，就不会重新创建，直接复用栈顶的示例。，比如现有有 MainActivity、BActivity、CActivity、DActivity四个Activity。</p> <p>standard模式下</p> <p>启动顺序为： Main -&gt; B -&gt; C -&gt;C-&gt;B -&gt; C-&gt;C</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{976512b #847 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=6}
        Hist  #5: ActivityRecord{cbc3787 u0 cc.fastcv.codelab/.CActivity} t847}
        Hist  #5: ActivityRecord{cbc3762 u0 cc.fastcv.codelab/.CActivity} t847}
        Hist  #4: ActivityRecord{31ec276 u0 cc.fastcv.codelab/.BActivity} t847}
        Hist  #3: ActivityRecord{c9e4943 u0 cc.fastcv.codelab/.CActivity} t847}
        Hist  #2: ActivityRecord{a9d611d u0 cc.fastcv.codelab/.CActivity} t847}
        Hist  #1: ActivityRecord{70bdae8 u0 cc.fastcv.codelab/.BActivity} t847}
        Hist  #0: ActivityRecord{da3db5b u0 cc.fastcv.codelab/.MainActivity} t847}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>将C改为singleTop模式之后</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> * Task{76f3d47 #848 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=5}
    * Hist  #4: ActivityRecord{2b85a58 u0 cc.fastcv.codelab/.CActivity} t848}
    * Hist  #3: ActivityRecord{80e2c86 u0 cc.fastcv.codelab/.BActivity} t848}
    * Hist  #2: ActivityRecord{5af6a25 u0 cc.fastcv.codelab/.CActivity} t848}
    * Hist  #1: ActivityRecord{d961f7a u0 cc.fastcv.codelab/.BActivity} t848}
    * Hist  #0: ActivityRecord{c9c37bf u0 cc.fastcv.codelab/.MainActivity} t848}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>对比之后可以看到，C并没有连续的重复出现，而是隔着出现。这个就是singleTop启动模式的作用。</p> <h3 id="singletask"><a href="#singletask" class="header-anchor">#</a> singleTask</h3> <p>在理解了singleTop之后，这个就很好理解了，从名字就可以看出来，任务唯一，意思就是在当前的任务栈里面是唯一的，如果之前存在，就直接退栈退到这个实例为止。</p> <p>启动顺序为： Main -&gt; B -&gt; C -&gt;D，其中，把B的启动模式改为singleTask</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{c4bf0ad #849 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}
    * Hist  #3: ActivityRecord{490860e u0 cc.fastcv.codelab/.DActivity} t849}
    * Hist  #2: ActivityRecord{a9fd862 u0 cc.fastcv.codelab/.CActivity} t849}
    * Hist  #1: ActivityRecord{2452d77 u0 cc.fastcv.codelab/.BActivity} t849}
    * Hist  #0: ActivityRecord{f969540 u0 cc.fastcv.codelab/.MainActivity} t849}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>再从D跳转到B</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{c4bf0ad #849 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{2452d77 u0 cc.fastcv.codelab/.BActivity} t849}
    * Hist  #0: ActivityRecord{f969540 u0 cc.fastcv.codelab/.MainActivity} t849}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从结果可以看出，重新进入B时，会把B上面的所有任务全部推出栈，直到B为止。</p> <p>我们这个时候按返回键会发现，只需要按两次就可以返回到桌面了。</p> <h3 id="singleinstance"><a href="#singleinstance" class="header-anchor">#</a> singleInstance</h3> <p>这个就比较少见了，它的作用就是启动一个单独的任务栈，然后把这个任务放进去，并且不允许其他任务放入。</p> <p>启动顺序为： Main -&gt; B -&gt; C -&gt;D，其中，把B的启动模式改为singleInstance</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{698b7d #850 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=3}
    * Hist  #2: ActivityRecord{dcaa77d u0 cc.fastcv.codelab/.DActivity} t850}
    * Hist  #1: ActivityRecord{b819914 u0 cc.fastcv.codelab/.CActivity} t850}
    * Hist  #0: ActivityRecord{c8610be u0 cc.fastcv.codelab/.MainActivity} t850}

  * Task{4a5f831 #851 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{6308cd8 u0 cc.fastcv.codelab/.BActivity} t851}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到，B处于一个单独的任务栈中。</p> <p>那这里我就有个问题了，我们按返回键的时候，从C返回之后是到哪个？  从B返回之后是到哪个？</p> <p>我们分别来测试下。</p> <ul><li>从C返回 ：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{e33376d #852 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=3}
    * Hist  #2: ActivityRecord{7d2d056 u0 cc.fastcv.codelab/.DActivity} t852}
    * Hist  #1: ActivityRecord{bb0fc21 u0 cc.fastcv.codelab/.CActivity} t852}
    * Hist  #0: ActivityRecord{f9ce443 u0 cc.fastcv.codelab/.MainActivity} t852}

  * Task{20a505b #853 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{e0fe36a u0 cc.fastcv.codelab/.BActivity} t853}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{e33376d #852 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{f9ce443 u0 cc.fastcv.codelab/.MainActivity} t852}

  * Task{20a505b #853 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{e0fe36a u0 cc.fastcv.codelab/.BActivity} t853}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，直接到了MainActivity了，并没有直接到BActivity。</p> <p>那我们再返回呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{20a505b #853 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{e0fe36a u0 cc.fastcv.codelab/.BActivity} t853}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，返回到了BActivity了？ 这个很奇怪呀！！</p> <p>Main返回之后不是到桌面了吗？为啥到B了？</p> <p>这里就又涉及到了一个任务栈的管理，下面再试试，进入B之后返回的操作。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{42c226e #855 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{afa35e9 u0 cc.fastcv.codelab/.BActivity} t855}

  * Task{bdfc544 #854 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{4eeaeb9 u0 cc.fastcv.codelab/.MainActivity} t854}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{e33376d #852 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{f9ce443 u0 cc.fastcv.codelab/.MainActivity} t852}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，如果有多个任务栈时，会随任务栈显示到前台的顺序来排序任务栈，那意思是不是说，如果B、C的启动模式都是singleInstance。</p> <p>然从Main -&gt; B -&gt; C -&gt; D之后，任务栈的顺序就是</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Task{Main、D}
Task{C}
Task{B}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们来验证看看。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{43b0fb4 #856 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{1ae8745 u0 cc.fastcv.codelab/.DActivity} t856}
    * Hist  #0: ActivityRecord{66788eb u0 cc.fastcv.codelab/.MainActivity} t856}

  * Task{5ad4d85 #858 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    mLastPausedActivity: ActivityRecord{b1d52fc u0 cc.fastcv.codelab/.CActivity} t858}
    isSleeping=false
    * Hist  #0: ActivityRecord{b1d52fc u0 cc.fastcv.codelab/.CActivity} t858}

  * Task{3dd45bf #857 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{ad17fde u0 cc.fastcv.codelab/.BActivity} t857}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以看到，和我们的猜想一致。</p> <p>那如果在D的基础上再启动D呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{e4c1fc5 #890 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{d07063c u0 cc.fastcv.codelab/.DActivity} t890}

  * Task{3b2b6bb #889 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}
    * Hist  #2: ActivityRecord{16960ae u0 cc.fastcv.codelab/.CActivity} t889}
    * Hist  #1: ActivityRecord{66caec3 u0 cc.fastcv.codelab/.BActivity} t889}
    * Hist  #0: ActivityRecord{cef070 u0 cc.fastcv.codelab/.MainActivity} t889}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>emmmmmmmmmmmmmmmm...    D是唯一的</p> <p>在D的基础上加上E，再启动D呢？</p> <p>先进入E</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{28f3347 #891 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}
    * Hist  #3: ActivityRecord{6004d77 u0 cc.fastcv.codelab/.EActivity} t891}
    * Hist  #2: ActivityRecord{696b648 u0 cc.fastcv.codelab/.CActivity} t891}
    * Hist  #1: ActivityRecord{12b0869 u0 cc.fastcv.codelab/.BActivity} t891}
    * Hist  #0: ActivityRecord{877ff2d u0 cc.fastcv.codelab/.MainActivity} t891}

  * Task{6b5f8cb #892 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{258279a u0 cc.fastcv.codelab/.DActivity} t892}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>再进入D</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{6b5f8cb #892 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{258279a u0 cc.fastcv.codelab/.DActivity} t892}

  * Task{28f3347 #891 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=4}
    * Hist  #3: ActivityRecord{6004d77 u0 cc.fastcv.codelab/.EActivity} t891}
    * Hist  #2: ActivityRecord{696b648 u0 cc.fastcv.codelab/.CActivity} t891}
    * Hist  #1: ActivityRecord{12b0869 u0 cc.fastcv.codelab/.BActivity} t891}
    * Hist  #0: ActivityRecord{877ff2d u0 cc.fastcv.codelab/.MainActivity} t891}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>emmmmmmmmmmmmmmmm...    D还是唯一的</p> <p>那如果我在E启动D的时候，加上 <strong>FLAG_ACTIVITY_NEW_TASK</strong> 标识呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{91dd7e3 #894 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{7763412 u0 cc.fastcv.codelab/.DActivity} t894}

  * Task{db5d41d #893 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=4}
    mLastPausedActivity: ActivityRecord{dfbeaa5 u0 cc.fastcv.codelab/.EActivity} t893}
    isSleeping=false
    * Hist  #3: ActivityRecord{dfbeaa5 u0 cc.fastcv.codelab/.EActivity} t893}
    * Hist  #2: ActivityRecord{fc90780 u0 cc.fastcv.codelab/.CActivity} t893}
    * Hist  #1: ActivityRecord{a8db5b4 u0 cc.fastcv.codelab/.BActivity} t893}
    * Hist  #0: ActivityRecord{4005d65 u0 cc.fastcv.codelab/.MainActivity} t893}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到，毫无影响，这就刚好验证了这个启动模式的名称（singleInstance：唯一的实例）</p> <p><strong>这里有个点需要注意：当一个被设置为singleInstance的Activity去启动其他的Activity的时候，其默认是自带FLAG_ACTIVITY_NEW_TASK标签的。</strong></p> <h3 id="singleinstancepertask"><a href="#singleinstancepertask" class="header-anchor">#</a> singleInstancePerTask</h3> <p>官方的介绍是这样说的：此 activity 只能作为任务的根 activity、作为创建该任务的第一个 activity 运行，因此在任务中该 activity 只有一个实例；但是 activity 可以在不同的任务中多次实例化。</p> <p>前面的单独的任务和唯一实例和singleTask差不多，那这个可以<strong>在不同的任务中多次实例化</strong>这句话就是个特殊的点了。我们来验证下：</p> <p>Main -&gt; B -&gt; C -&gt; D -&gt; D，D的启动模式为singleInstancePerTask。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{b2463f2 #881 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{f743afd u0 cc.fastcv.codelab/.DActivity} t881}

  * Task{36ac7c1 #880 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}
    * Hist  #2: ActivityRecord{f020e63 u0 cc.fastcv.codelab/.CActivity} t880}
    * Hist  #1: ActivityRecord{bf4893d u0 cc.fastcv.codelab/.BActivity} t880}
    * Hist  #0: ActivityRecord{491e293 u0 cc.fastcv.codelab/.MainActivity} t880}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以看到，如果当前任务栈已经是D了，重启进入的时候并没有多创建一个任务栈，这样就验证了 <strong>在任务中该 activity 只有一个实例</strong> 的说法。</p> <p>那<strong>在不同的任务中多次实例化</strong>这个说法怎么验证呢？</p> <p>Main -&gt; B -&gt; C -&gt; D -&gt; C-&gt;D，D的启动模式为singleInstancePerTask。进入C之后，再进入D会不会重新创建一个任务栈？会不会就是这个意思呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{c6b8698 #883 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{b49487b u0 cc.fastcv.codelab/.DActivity} t883}

  * Task{1a7b6a6 #882 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3
    * Hist  #2: ActivityRecord{b07609b u0 cc.fastcv.codelab/.CActivity} t882}
    * Hist  #1: ActivityRecord{d41c5f2 u0 cc.fastcv.codelab/.BActivity} t882}
    * Hist  #0: ActivityRecord{5dbfbce u0 cc.fastcv.codelab/.MainActivity} t882}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>??? 什么鬼 ？ ，这任务栈怎么看不明白了。</p> <p>不急，我们再看看 Main -&gt; B -&gt; C -&gt; D -&gt; C ，D的启动模式为singleInstancePerTask。这种情况。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{8222ab2 #885 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{c0e54e6 u0 cc.fastcv.codelab/.CActivity} t885}
    * Hist  #0: ActivityRecord{5c5e4bd u0 cc.fastcv.codelab/.DActivity} t885}

  * Task{a694685 #884 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}
    * Hist  #2: ActivityRecord{67e3087 u0 cc.fastcv.codelab/.CActivity} t884}
    * Hist  #1: ActivityRecord{9d8d39a u0 cc.fastcv.codelab/.BActivity} t884}
    * Hist  #0: ActivityRecord{d8491f7 u0 cc.fastcv.codelab/.MainActivity} t884}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>哦，原来后面启动的Activity都会被添加到新的任务栈里面，然后又保证了singleTask的特性。所以出现了上面的那种情况，重新进入D后，由于D在栈底，所以把上面的Activity全部丢弃掉了。</p> <p>那，这还是没有验证到 <strong>不同的任务中多次实例化</strong> 的说法，我们改怎么去验证呢？</p> <p>既然不再它所在的任务栈启动它就会新建一个任务栈，那是不是我在它的基础上，进入另外一个任务栈（不包括它），再启动它就能验证了呢？我们来试下，不过在试之前，我们要学习下，怎么样去新建一个任务栈（自己指定的）。</p> <p>这里就需要一个标签</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:taskAffinity
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>taskAffinity是指Activity的任务栈亲和度，即任务归属，代表该Activity属于哪个任务栈。
使用场景：
1.一般根据taskAffinity重新为Activity选择宿主任务栈（与allowTaskReparenting属性配合使用）
2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据taskAffinity查找或创建一个新的具有对应taskAffinity的任务栈。</p> <p>**注意点：**taskAffinity一般singleTask搭配使用，当启动的Activity使用standard、singleTop属性时，如果只设置一个特殊的taskAffinity，但是启动它的时候不设置FLAG_ACTIVITY_NEW_TASK，是不会创建新任务栈。指定singleInstance模式和singleInstancePerTask加上taskAffinity则为新的任务栈命名。另外这个名字必须以<code>:</code>开头或者一个完整的包名<code>com.fastcv.xxx</code></p> <p>那我们新增一个EActivity，启动它是加上FLAG_ACTIVITY_NEW_TASK，另外单独给它制定一个任务栈名称。</p> <p>Main -&gt; B -&gt; C -&gt; D -&gt; E-&gt;D，D的启动模式为singleInstancePerTask。这里我们分两步看看结果：</p> <p>先只走到E</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{c1fa8be #888 type=standard A=10480:cc.fastcv.codelab:test U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{1e922e6 u0 cc.fastcv.codelab/.EActivity} t888}

  * Task{dc3cc0a #887 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{63e5475 u0 cc.fastcv.codelab/.DActivity} t887}

  * Task{c273b35 #886 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}
    * Hist  #2: ActivityRecord{5fd36d9 u0 cc.fastcv.codelab/.CActivity} t886}
    * Hist  #1: ActivityRecord{63618fd u0 cc.fastcv.codelab/.BActivity} t886}
    * Hist  #0: ActivityRecord{82a217b u0 cc.fastcv.codelab/.MainActivity} t886}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>再进入D</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{dc3cc0a #887 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{63e5475 u0 cc.fastcv.codelab/.DActivity} t887}

  * Task{c1fa8be #888 type=standard A=10480:cc.fastcv.codelab:test U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{1e922e6 u0 cc.fastcv.codelab/.EActivity} t888}

  * Task{c273b35 #886 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}
    * Hist  #2: ActivityRecord{5fd36d9 u0 cc.fastcv.codelab/.CActivity} t886}
    * Hist  #1: ActivityRecord{63618fd u0 cc.fastcv.codelab/.BActivity} t886}
    * Hist  #0: ActivityRecord{82a217b u0 cc.fastcv.codelab/.MainActivity} t886}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>从结果看，还是只存在一个D。暂时无法验证了。</p> <h2 id="启动其他应用"><a href="#启动其他应用" class="header-anchor">#</a> 启动其他应用</h2> <p>如果我们现在打开的是另外一个应用呢？任务堆栈会是怎样的。</p> <p>目标Activity为不同启动模式时：</p> <ul><li>standard</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{ac0d71a u0 com.umeox.myapplication/.BActivity} t944}
    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>singleTop</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{2cf95e0 u0 com.umeox.myapplication/.BActivity} t944}
    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>singleTask</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{90f63d4 u0 com.umeox.myapplication/.BActivity} t944}
    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>singleInstance</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{9b91b31 u0 com.umeox.myapplication/.BActivity} t944}
    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>singleInstancePerTask</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{cea3115 #952 type=standard A=10380:com.umeox.myapplication U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{2a6f35d u0 com.umeox.myapplication/.BActivity} t952}

  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}
    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，在跨应用跳转时，除了singleInstancePerTask还是会新建一个任务外，其他的都会在原来的任务栈里添加。</p> <h3 id="android-allowtaskreparenting"><a href="#android-allowtaskreparenting" class="header-anchor">#</a> android:allowTaskReparenting</h3> <p>这里为啥要提一下这个属性呢？我们先来看看它的介绍。</p> <p>allowTaskReparenting属性的作用是Activity的迁移。当allowTaskReparenting属性和TaskAffinity配合使用时，Activity可以从一个任务栈迁移到另一个任务栈。</p> <p>迁移的规则是：从一个与该Activity TaskAffinity属性不同的任务栈中迁移到与它TaskAffinity相同的任务栈中。</p> <p>具体点来说，现在有两个应用A和B，A启动了B的一个Activity C，然后按Home键回到桌面，然后再单击B的桌面图标，这个时候不是启动了B的主Activity，而是重新显示了已经被应用A启动的Activity C。我们也可以理解为，C从A的任务栈转移到了B的任务栈中。</p> <p>可以这么理解，由于A启动了C，这个时候C只能运行在A的任务栈中，但是C属于B应用，正常情况下，它的TaskAffinity值肯定不可能和A的任务栈相同，所以当B启动后，B会创建自己的任务栈，这个时候系统发现C原本想要的任务栈已经创建了，所以就把C从A的任务栈中转移过来了。</p> <p>我们在上面的基础上实验下，我们给目标Activity加上此属性</p> <p>跳转到目标，但未做打开目标应用的操作时：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}
    * Hist  #1: ActivityRecord{44212a3 u0 com.umeox.myapplication/.BActivity} t944}
    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>打开目标应用的操作时：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  * Task{8ff9047 #955 type=standard A=10380:com.umeox.myapplication U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
    * Hist  #0: ActivityRecord{2250d29 u0 com.umeox.myapplication/.MainActivity} t955}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，确实把目标Activity转移过去了。</p> <h1 id="activity之间的数据传输"><a href="#activity之间的数据传输" class="header-anchor">#</a> Activity之间的数据传输</h1> <p>Activity之间的数据传输是个非常重要的场景知识，因为一些简单的需求或者数据，我们没必要新建个单例去维持临时数据。这个时候就需要Activity之间的数据流通了。</p> <h2 id="activity的启动方式"><a href="#activity的启动方式" class="header-anchor">#</a> Activity的启动方式</h2> <p>我们启动一个Activity时，有两种方式启动</p> <ul><li><strong>显式启动</strong></li> <li><strong>隐式启动</strong></li></ul> <h3 id="显式启动"><a href="#显式启动" class="header-anchor">#</a> 显式启动</h3> <p>首先我们看看显式启动的几种写法。</p> <ul><li>常用的</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>        startActivity(Intent(this,DActivity::class.java))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>通过Intent的ComponentName</strong></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>        startActivity(Intent().apply {
            component = ComponentName(this@CActivity,DActivity::class.java)
        })
        
        startActivity(Intent().apply {
            component = ComponentName(&quot;cc.fastcv.codelab&quot;,&quot;cc.fastcv.codelab.DActivity&quot;)
        })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><strong>初始化Intent时指定包名</strong></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>        startActivity(Intent(&quot;android.intent.action.MAIN&quot;).apply {
            setClassName(&quot;cc.fastcv.codelab&quot;,&quot;cc.fastcv.codelab.DActivity&quot;)
        })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="隐式启动"><a href="#隐式启动" class="header-anchor">#</a> 隐式启动</h3> <p><strong>通过Intent-filter的Action,Category或data来实现 这个是通过Intent的 intent-filter来实现的</strong>，关于Intent-filter，它适用于四大组件，所以不在Activity的范围内讲。</p> <p>举个例子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        startActivity(Intent().apply {
            action = &quot;xxx.xxxx.xxx&quot;
            addCategory(&quot;xxx&quot;)
        })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>intent-filter我们单独梳理一章。</p> <h3 id="启动其他应用-2"><a href="#启动其他应用-2" class="header-anchor">#</a> 启动其他应用</h3> <h4 id="包名-特定activity名拉起"><a href="#包名-特定activity名拉起" class="header-anchor">#</a> 包名，特定Activity名拉起</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>        startActivityForResult(Intent().apply {
            action = Intent.ACTION_MAIN
            component =
                ComponentName(&quot;com.umeox.myapplication&quot;, &quot;com.umeox.myapplication.BActivity&quot;)
            putExtra(&quot;Name&quot;, &quot;xiaohei&quot;)
        }, 1000)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>B应用需要在manifest文件对应Activity添加</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>       android:exported=&quot;true&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="包名拉起-这里就是进去启动页"><a href="#包名拉起-这里就是进去启动页" class="header-anchor">#</a> 包名拉起（这里就是进去启动页）</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>        packageManager.getLaunchIntentForPackage(&quot;com.umeox.myapplication&quot;)?.let {
            startActivity(it.apply {
                putExtra(&quot;Name&quot;, &quot;xiaohei&quot;)
            })
        }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="url拉起"><a href="#url拉起" class="header-anchor">#</a> url拉起</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>        startActivity(Intent().apply {
            data = Uri.parse(&quot;csd://pull.csd.demo/cyn?type=110&quot;)
            putExtra(&quot;Name&quot;, &quot;xiaohei&quot;)
        })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>B应用需要在manifest文件对应Activity添加</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;intent-filter&gt;
    &lt;data
        android:host=&quot;pull.csd.demo&quot;
        android:path=&quot;/cyn&quot;
        android:scheme=&quot;csd&quot; /&gt;
    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="子进程启动activity"><a href="#子进程启动activity" class="header-anchor">#</a> 子进程启动Activity</h3> <p>清单配置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        &lt;activity android:name=&quot;.BActivity&quot;
            android:process=&quot;:test&quot;
            android:taskAffinity=&quot;:test&quot;
            android:exported=&quot;true&quot;/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>启动</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>            startActivity(Intent(this,BActivity::class.java).apply {
                component =
                    ComponentName(&quot;cc.fastcv.codelab&quot;, &quot;cc.fastcv.codelab.BActivity&quot;)
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>此时，子进程奔溃了不会导致主进程奔溃。</p> <h2 id="a-b"><a href="#a-b" class="header-anchor">#</a> A -&gt; B</h2> <p>从A传入数据到B还是比较简单的，还记得Activity的启动方式吗？我们不管怎么操作，都是依赖的 Intent 来启动的Activity。这是因为在安卓平台中， Intent 代表的是意图的意思，我们后面启动其他组件时也需要这个，接收的时候也是解读Intent里面的内容。</p> <p>所以，我们要传入参数时，携带数据的载体就是 Intent。它提供了一系列的putExtra方法。我们只需要传入对应的参数即可。如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    override fun onClick(v: View?) {
        Log.d(TAG, &quot;传入值&quot;)
        startActivity(Intent(this,DActivity::class.java).apply {
            putExtra(&quot;Name&quot;,&quot;xiaohei&quot;)
        })
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>与之对应的是一系列的getXxxxExtra的读取方法。如：在DActivity中的onCreate方法中，我们就可以读取</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d(TAG, &quot;onCreate: &quot;)

        val stringExtra = intent.getStringExtra(&quot;Name&quot;)?:&quot;&quot;
        Log.d(TAG, &quot;onCreate: $stringExtra&quot;)
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>2022-10-14 15:57:23.893 9851-9851/cc.fastcv.codelab D/CActivity: 传入值
2022-10-14 15:57:23.940 9851-9851/cc.fastcv.codelab D/DActivity: onCreate: xiaohei
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>这里需要注意的是：没有读取到的时候，会返回一个空值，需要处理！！</strong></p> <h2 id="b-返回值给-a"><a href="#b-返回值给-a" class="header-anchor">#</a> B 返回值给 A</h2> <p>如果要返回值的话，就需要用到几个新的API。</p> <p>首先，启动Activity的方法从startActivity改为了startActivityForResult，如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        Log.d(TAG, &quot;传入值&quot;)
        startActivityForResult(Intent(this,DActivity::class.java).apply {
            putExtra(&quot;Name&quot;,&quot;xiaohei&quot;)
        },1000)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里的1000是个请求码，用来在接收返回值时做区分时使用的。因为我们可以会有多个返回值过来，在不知道响应码的情况下，我们可以用请求码来做区分。</p> <p>上面的代码是传值，那刚提到的接收值怎么操作呢？这个就是一个新的回调：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == 1000) {
            data?.let {
                Log.d(TAG, &quot;获取返回值: ${it.getStringExtra(&quot;result&quot;)}&quot;)
            }
        }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>我们在Activity中重写这个方法。</p> <p>最后就是DActivity发送返回值的方式了。我们需要这样子传入返回值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        setResult(1000,Intent().putExtra(&quot;result&quot;,&quot;这是返回值&quot;))
        finish()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在关闭Activity的时候，先setResult再finish就可以传入返回值并关闭当前Activity了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>2022-10-14 16:17:44.071 11948-11948/cc.fastcv.codelab D/CActivity: 传入值
2022-10-14 16:17:44.114 11948-11948/cc.fastcv.codelab D/DActivity: onCreate: xiaohei
2022-10-14 16:17:50.456 11948-11948/cc.fastcv.codelab D/CActivity: 获取返回值: 这是返回值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里有些特殊情况：</p> <p><strong>应用内跳转，目标Activity的启动模式不同时。</strong></p> <ul><li>standard：可以正常返回</li> <li>singleTop：可以正常返回</li> <li>singleTask：如果目标Activity未启动，可以正常返回；如果已经启动了且在同一个任务栈，无法正常返回</li> <li>singleInstance：可以正常返回</li> <li>singleInstancePerTask：无法正常返回</li></ul> <p><strong>不同应用内跳转，目标Activity的启动模式不同时。</strong></p> <ul><li>standard：可以正常返回</li> <li>singleTop：可以正常返回</li> <li>singleTask：可以正常返回</li> <li>singleInstance：可以正常返回</li> <li>singleInstancePerTask：无法正常返回</li></ul> <p>总结来说就是：在同一个任务栈中（且调用Activity存在的情况）才能正常返回，否则就无法正常返回。</p> <p><strong>这里需要注意：传值可以跨任务，但是返回值无法跨任务传递，比如我们启动的Activity的启动模式会单独启动一个任务栈，这个时候就会直接回调onActivityResult，并没有返回值。然后传递数据时，需要注意大小限制：通过 intent 发送数据时，应小心地将数据大小限制为几 KB。发送过多数据会导致系统抛出 <code>TransactionTooLargeException</code> 异常。</strong></p> <h2 id="activity-results-api写法"><a href="#activity-results-api写法" class="header-anchor">#</a> Activity Results API写法</h2> <p>在Android应用程序开发中，启动一个Activity不一定是单项操作，从启动的Activity获取数据是常见的场景，最传统的方式是通过<code>Intent</code>携带数据，然后使用<code>startActivityForResult</code>方法来启动下一个Activity，然后通过<code>onActivityResult</code>来接收返回的结果，代码如下：</p> <p>调用<code>startActivityForResult</code>方法启动</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code> <span class="token function">startActivityForResult</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实现<code>onActivityResult</code>方法</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onActivityResult</span><span class="token punctuation">(</span>requestCode<span class="token operator">:</span> Int<span class="token punctuation">,</span> resultCode<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token operator">:</span> Intent<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onActivityResult</span><span class="token punctuation">(</span>requestCode<span class="token punctuation">,</span> resultCode<span class="token punctuation">,</span> <span class="token keyword">data</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>resultCode <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> resultCode <span class="token operator">==</span> Activity<span class="token punctuation">.</span>RESULT_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 处理第二个页面带回的数据</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>以上方式，<code>onActivityResult</code>就能获取从上一个界面返回的数据，这种方式非常有用，不仅能同一个应用中，也可以从其他应用中获取数据，比如我们常见的，调用系统相机、相册获取照片，获取系统通讯录等。</p> <p>这种好是好，但是每次都要处理 requestCode 、resultCode，做区分，代码堆积一堆逻辑判断，查看起来头疼，于是，官方推出了 Activity Results API。</p> <p>这个内容很多，涉及的模块也很广，所以会有一篇文章单独详细的写。这里只挑出 传值相关的 API 来讲。</p> <p>优化之后的代码就是这样的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    private val myActivityLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()){ result -&gt;
        result.data?.let {
            Log.d(TAG, &quot;获取返回值: ${it.getStringExtra(&quot;result&quot;)}&quot;)
        }
    }

    override fun onClick(v: View?) {
        Log.d(TAG, &quot;传入值&quot;)
        myActivityLauncher.launch(Intent().apply {
            data = Uri.parse(&quot;csd://pull.csd.demo/cyn?type=110&quot;)
            putExtra(&quot;Name&quot;, &quot;xiaohei&quot;)
        })
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>不再需要onActivityResult方法来做值回调处理了。</p> <h1 id="深入学习activity"><a href="#深入学习activity" class="header-anchor">#</a> 深入学习Activity</h1> <h2 id="app启动流程"><a href="#app启动流程" class="header-anchor">#</a> APP启动流程</h2> <p>待补充...</p> <h2 id="activity启动流程"><a href="#activity启动流程" class="header-anchor">#</a> Activity启动流程</h2> <p>待补充...</p> <h2 id="生命周期回调的源码逻辑梳理"><a href="#生命周期回调的源码逻辑梳理" class="header-anchor">#</a> 生命周期回调的源码逻辑梳理</h2> <p>待补充...</p> <h1 id="场景小技巧"><a href="#场景小技巧" class="header-anchor">#</a> 场景小技巧</h1> <h2 id="如何退出app后不再最近使用中保留"><a href="#如何退出app后不再最近使用中保留" class="header-anchor">#</a> 如何退出app后不再最近使用中保留</h2> <p>在Activity标签的属性中，有这样一个属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:autoRemoveFromRecents
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由具有该属性的 Activity 启动的任务是否一直保留在最近任务中，直至任务中的最后一个 Activity 完成为止。若为 <code>true</code>，则自动从概览屏幕中移除任务。它会替换调用方使用的 <code>FLAG_ACTIVITY_RETAIN_IN_RECENTS</code>。它必须是布尔值“<code>true</code>”或“<code>false</code>”。</p> <p>所以，我们只需要在根Activity上加上这个属性设置为true即可。</p> <h2 id="屏蔽所有configchange项"><a href="#屏蔽所有configchange项" class="header-anchor">#</a> 屏蔽所有configChange项</h2> <p>稍微做过点开发的都应该知道，在清单文件中的目标Activity上设置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:configChanges
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>标签的值，就可以避免这个Activity在某种场景下不用重新创建。那这些值有哪些呢？</p> <table><thead><tr><th style="text-align:left;">值</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;">“<code>density</code>”</td> <td style="text-align:left;">显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 API 级别 24 中引入。</td></tr> <tr><td style="text-align:left;">“<code>fontScale</code>”</td> <td style="text-align:left;">字体缩放系数发生变更 - 用户已选择新的全局字号。</td></tr> <tr><td style="text-align:left;">“<code>keyboard</code>”</td> <td style="text-align:left;">键盘类型发生变更 - 例如，用户插入外置键盘。</td></tr> <tr><td style="text-align:left;">“<code>keyboardHidden</code>”</td> <td style="text-align:left;">键盘无障碍功能发生变更 - 例如，用户显示硬键盘。</td></tr> <tr><td style="text-align:left;">“<code>layoutDirection</code>”</td> <td style="text-align:left;">布局方向发生变更 - 例如，自从左至右 (LTR) 更改为从右至左 (RTL)。在 API 级别 17 中引入。</td></tr> <tr><td style="text-align:left;">“<code>locale</code>”</td> <td style="text-align:left;">语言区域发生变更 - 用户已为文本选择新的显示语言。</td></tr> <tr><td style="text-align:left;">“<code>mcc</code>”</td> <td style="text-align:left;">IMSI 移动设备国家/地区代码 (MCC) 发生变更 - 检测到 SIM 并更新 MCC。</td></tr> <tr><td style="text-align:left;">“<code>mnc</code>”</td> <td style="text-align:left;">IMSI 移动设备网络代码 (MNC) 发生变更 - 检测到 SIM 并更新 MNC。</td></tr> <tr><td style="text-align:left;">“<code>navigation</code>”</td> <td style="text-align:left;">导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。）</td></tr> <tr><td style="text-align:left;">“<code>orientation</code>”</td> <td style="text-align:left;">屏幕方向发生变更 - 用户旋转设备。<strong>注意</strong>：如果应用面向 Android 3.2（API 级别 13）或更高版本的系统，则还应声明 <code>&quot;screenLayout&quot;</code> 和 <code>&quot;screenSize&quot;</code> 配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。</td></tr> <tr><td style="text-align:left;">“<code>screenLayout</code>”</td> <td style="text-align:left;">屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。</td></tr> <tr><td style="text-align:left;">“<code>screenSize</code>”</td> <td style="text-align:left;">当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在 API 级别 13 中引入。</td></tr> <tr><td style="text-align:left;">“<code>smallestScreenSize</code>”</td> <td style="text-align:left;">物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应 <a href="https://developer.android.com/guide/topics/resources/providing-resources#SmallestScreenWidthQualifier" target="_blank" rel="noopener noreferrer">smallestWidth 配置<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的变化。在 API 级别 13 中引入。</td></tr> <tr><td style="text-align:left;">“<code>touchscreen</code>”</td> <td style="text-align:left;">触摸屏发生变更。（这种情况通常不会发生。）</td></tr> <tr><td style="text-align:left;">“<code>uiMode</code>”</td> <td style="text-align:left;">界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅 <code>UiModeManager</code>。在 API 级别 8 中引入。</td></tr></tbody></table> <p>如果，你屏蔽它不是为了防止Activity重新创建，而是想自己单独处理的话，请在Activity中重写 <strong>onConfigurationChanged</strong> 方法，然后做区分处理即可。</p> <h2 id="硬件加速"><a href="#硬件加速" class="header-anchor">#</a> 硬件加速</h2> <p>相信大家在解决某些UI问题的时候，经常会看到说 <strong>关闭/开启硬件加速</strong> 的说法，有个一劳永逸的方法，我们直接在Activity层面 <strong>关闭/开启硬件加速</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:hardwareAccelerated
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>是否应为此 Activity 启用硬件加速渲染 -“<code>true</code>”表示应启用，“<code>false</code>”表示不应启用。默认值为“<code>false</code>”。</p> <p>自 Android 3.0 开始，应用可使用经硬件加速的 OpenGL 渲染器，从而提高许多常见 2D 图形运算的性能。启用硬件加速的渲染程序后，Canvas、Paint、Xfermode、ColorFilter、Shader 和 Camera 中的大多数操作都会加速。这样可使动画和滚动更流畅并且可提高整体响应能力，即使对于没有明确使用框架的 OpenGL 库的应用也是如此。启用硬件加速需要更多资源，因此应用会占用更多内存。</p> <p>请注意，并非所有 OpenGL 2D 操作都会加速。如果您启用硬件加速的渲染程序，请对应用进行测试，以确保它可以毫无错误地使用该渲染程序。</p> <h2 id="禁用多窗口"><a href="#禁用多窗口" class="header-anchor">#</a> 禁用多窗口</h2> <p>我们可以直接使用</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>resizeableActivity
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>去设置即可。</p> <h2 id="设置屏幕方向"><a href="#设置屏幕方向" class="header-anchor">#</a> 设置屏幕方向</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:screenOrientation
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Activity 在设备上的显示方向。如果 Activity 是在<a href="https://developer.android.com/guide/topics/ui/multi-window" target="_blank" rel="noopener noreferrer">多窗口模式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>下运行，则系统会忽略该属性。</p> <p>其值可以是下列任一字符串：</p> <table><thead><tr><th>“<code>unspecified</code>”</th> <th>默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文中所做的选择可能会有所差异。</th></tr></thead> <tbody><tr><td>“<code>behind</code>”</td> <td>与 activity 堆栈中紧接其后的 activity 的方向相同。</td></tr> <tr><td>“<code>landscape</code>”</td> <td>屏幕方向为横向（显示的宽度大于高度）。</td></tr> <tr><td>“<code>portrait</code>”</td> <td>屏幕方向为纵向（显示的高度大于宽度）。</td></tr> <tr><td>“<code>reverseLandscape</code>”</td> <td>屏幕方向是与正常横向方向相反的横向。 <em>在 API 级别 9 中引入。</em></td></tr> <tr><td>“<code>reversePortrait</code>”</td> <td>屏幕方向是与正常纵向方向相反的纵向。 <em>在 API 级别 9 中引入。</em></td></tr> <tr><td>“<code>sensorLandscape</code>”</td> <td>屏幕方向为横向，但可根据设备传感器调整为正常或反向的横向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 <em>在 API 级别 9 中引入。</em></td></tr> <tr><td>“<code>sensorPortrait</code>”</td> <td>屏幕方向为纵向，但可根据设备传感器调整为正常或反向的纵向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 <em>在 API 级别 9 中引入。</em></td></tr> <tr><td>“<code>userLandscape</code>”</td> <td>屏幕方向为横向，但可根据设备传感器和用户首选项调整为正常或反向的横向。在 API 级别 18 中引入。</td></tr> <tr><td>“<code>userPortrait</code>”</td> <td>屏幕方向为纵向，但可根据设备传感器和用户首选项调整为正常或反向的纵向。 在 API 级别 18 中引入。</td></tr> <tr><td>“<code>sensor</code>”</td> <td>屏幕方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。但在默认情况下，一些设备不会旋转为所有四种可能的方向。如要支持所有这四种方向，请使用 <code>&quot;fullSensor&quot;</code>。即使用户锁定基于传感器的旋转，系统仍可使用传感器。</td></tr> <tr><td>“<code>fullSensor</code>”</td> <td>屏幕方向由使用 4 种方向中任一方向的设备方向传感器决定。 这与 <code>&quot;sensor&quot;</code> 类似，不同之处在于无论设备在正常情况下使用哪种方向，该值均支持所有 4 种可能的屏幕方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但其支持这些方向）。<em>在 API 级别 9 中引入。</em></td></tr> <tr><td>“<code>nosensor</code>”</td> <td>确定屏幕方向时不考虑物理方向传感器。系统会忽略传感器，因此显示内容不会随用户手持设备的方向而旋转。</td></tr> <tr><td>“<code>user</code>”</td> <td>用户当前的首选方向。</td></tr> <tr><td>“<code>fullUser</code>”</td> <td>如果用户锁定基于传感器的旋转，则其行为与 <code>user</code> 相同，否则，其行为与 <code>fullSensor</code> 相同，并且支持所有 4 种可能的屏幕方向。 在 API 级别 18 中引入。</td></tr> <tr><td>“<code>locked</code>”</td> <td>将方向锁定在其当前的任意旋转方向。在 API 级别 18 中引入。</td></tr></tbody></table> <h2 id="activity不保存数据-避免fragment重新加载出现问题"><a href="#activity不保存数据-避免fragment重新加载出现问题" class="header-anchor">#</a> Activity不保存数据，避免Fragment重新加载出现问题</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:screenOrientation
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>能否在不保存 Activity 状态的情况下将其终止并成功重新启动 -“<code>true</code>”表示可在不考虑其之前状态的情况下重新启动，“<code>false</code>”表示需要之前状态。默认值为“<code>false</code>”。</p> <p>正常情况下，为保存资源而暂时关闭 Activity 前，系统会调用其 <code>onSaveInstanceState()</code> 方法。该方法会将 Activity 的当前状态存储在一个 <code>Bundle</code> 对象中，然后在 Activity 重启时将其传递给 <code>onCreate()</code>。如果将该属性设置为“<code>true</code>”，则系统可能不会调用 <code>onSaveInstanceState()</code>，并且会向 <code>onCreate()</code> 传递 <code>null</code>（而非 Bundle）- 这与 activity 首次启动时的情况完全相同。</p> <p>“<code>true</code>”设置可确保 Activity 能够在未保留状态时重启。例如，显示主屏幕的 Activity 可以使用该设置，确保系统不会在该 Activity 因某种原因而崩溃时将其移除。</p> <h2 id="设置通用主题"><a href="#设置通用主题" class="header-anchor">#</a> 设置通用主题</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:theme
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>对定义 Activity 总体主题的样式资源的引用。此属性会自动将 Activity 的场景设置为使用该主题（请参阅 <code>setTheme()</code>），并且还可引发 Activity 启动前的“启动”动画（以更加符合 Activity 的实际外观）。</p> <p>如果未设置该属性，则 Activity 会继承通过 <code>&lt;application&gt;</code> 元素的 <code>theme</code> 属性为应用整体设置的主题。如果同样未设置该属性，则使用默认系统主题。</p> <h2 id="activity的键盘弹出-收起的处理"><a href="#activity的键盘弹出-收起的处理" class="header-anchor">#</a> Activity的键盘弹出/收起的处理</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>android:windowSoftInputMode
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Activity 的主窗口与包含屏幕软键盘的窗口之间的交互方式。该属性的设置会影响两点内容：</p> <ul><li>当 Activity 成为用户注意的焦点时软键盘的状态 - 隐藏还是可见。</li> <li>对 Activity 主窗口所做的调整 - 是否将其尺寸调小，为软键盘腾出空间；或当软键盘遮盖部分窗口时，是否平移其内容以使当前焦点可见。</li></ul> <p>该设置必须是下表所列的其中一项值，或一个“<code>state...</code>”值加上一个“<code>adjust...</code>”值的组合。在任一组中设置多个值（例如，多个“<code>state...</code>”值）均会产生未定义的结果。各个值之间用竖线 (<code>|</code>) 分隔。例如：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>windowSoftInputMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stateVisible|adjustResize<span class="token punctuation">&quot;</span></span> <span class="token attr-name">...</span> <span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>此处设置的值（“<code>stateUnspecified</code>”和“<code>adjustUnspecified</code>”除外）会替换主题中设置的值。</p> <table><thead><tr><th style="text-align:left;">值</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;">“<code>stateUnspecified</code>”</td> <td style="text-align:left;">不指定软键盘的状态（隐藏还是可见）。系统会选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。</td></tr> <tr><td style="text-align:left;">“<code>stateUnchanged</code>”</td> <td style="text-align:left;">当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。</td></tr> <tr><td style="text-align:left;">“<code>stateHidden</code>”</td> <td style="text-align:left;">当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时）隐藏软键盘。</td></tr> <tr><td style="text-align:left;">“<code>stateAlwaysHidden</code>”</td> <td style="text-align:left;">当 activity 的主窗口有输入焦点时始终隐藏软键盘。</td></tr> <tr><td style="text-align:left;">“<code>stateVisible</code>”</td> <td style="text-align:left;">当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时）显示软键盘。</td></tr> <tr><td style="text-align:left;">“<code>stateAlwaysVisible</code>”</td> <td style="text-align:left;">当窗口获得输入焦点时，会显示软键盘。</td></tr> <tr><td style="text-align:left;">“<code>adjustUnspecified</code>”</td> <td style="text-align:left;">不指定 Activity 的主窗口是否通过调整尺寸为软键盘腾出空间，或者是否通过平移窗口内容以在屏幕上显示当前焦点。根据窗口的内容是否存在任何可滚动其内容的布局视图，系统会自动选择其中一种模式。如果存在这种视图，系统会调整窗口尺寸，前提是可通过滚动操作在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。</td></tr> <tr><td style="text-align:left;">“<code>adjustResize</code>”</td> <td style="text-align:left;">始终调整 Activity 主窗口的尺寸，以为屏幕上的软键盘腾出空间。</td></tr> <tr><td style="text-align:left;">“<code>adjustPan</code>”</td> <td style="text-align:left;">不通过调整 Activity 主窗口的尺寸为软键盘腾出空间。相反，窗口的内容会自动平移，使键盘永远无法遮盖当前焦点，以便用户始终能看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之进行交互。</td></tr></tbody></table> <h2 id="将一个-activity-设置成窗口的样式"><a href="#将一个-activity-设置成窗口的样式" class="header-anchor">#</a> 将一个 Activity 设置成窗口的样式</h2> <p>只需要给我们的 <code>Activity</code> 配置如下属性即可。 <code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code></p></div></div> <div class="page-slot page-slot-bottom"></br><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="auto"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="7043271566"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">10/29/2022</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/0d8b25/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Application基础</div></a> <a href="/pages/73feed/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">广播基础</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/0d8b25/" class="prev">Application基础</a></span> <span class="next"><a href="/pages/73feed/">广播基础</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/1e535d/"><div>
            JavaPoet的学习使用
            <!----></div></a> <span class="date">12-26</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/8f05cf/"><div>
            Java反射
            <!----></div></a> <span class="date">12-26</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/767133/"><div>
            Java集合
            <!----></div></a> <span class="date">12-26</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/CatCatBug/fastcv-blog" title="Star我" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/playlist?id=5161366267" title="有品位的歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2022
    <span>极速cv | <a href="https://beian.miit.gov.cn/" target="_blank" style="font-weight:normal">粤ICP备2022111699号-1</a> </span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----><div></div></div></div>
    <script src="/assets/js/app.e1bc90e6.js" defer></script><script src="/assets/js/2.2dfa729a.js" defer></script><script src="/assets/js/27.03291f82.js" defer></script>
  </body>
</html>
