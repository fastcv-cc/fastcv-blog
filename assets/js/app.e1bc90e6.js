(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],c=e[1],l=e[2],u=0,p=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(a in c)Object.prototype.hasOwnProperty.call(c,a)&&(n[a]=c[a]);for(d&&d(e);p.length;)p.shift()();return r.push.apply(r,l||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],a=!0,s=1;s<t.length;s++){var c=t[s];0!==i[c]&&(a=!1)}a&&(r.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},i={1:0},r=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=i[n]=[e,a]}));e.push(t[2]=a);var r,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"2dfa729a",3:"4878f8f3",4:"f7f2d443",5:"97835dc3",6:"866ee092",7:"abd87bf8",8:"ab056171",9:"b608f08b",10:"35c27e70",11:"cc577099",12:"a6e96cf9",13:"62d81f10",14:"0634038b",15:"9b738075",16:"318f5092",17:"ef4612a8",18:"140f718a",19:"9d1daaf3",20:"4b6feb7d",21:"0ed2f2d5",22:"94066693",23:"d09c9beb",24:"1fdf3365",25:"1b7a2740",26:"4cfbc8ca",27:"03291f82",28:"ee2b7004",29:"2c8138ce",30:"b1298471",31:"da38da5f",32:"3d6eb133",33:"b6d94bfc",34:"b6f3263e",35:"97f4d2e7",36:"b02e62ca",37:"d2d7efa3",38:"6ae288c0",39:"4fc76e63",40:"284cd7ad",41:"29df7654",42:"ba55f3be",43:"b7195909",44:"e6098941",45:"40b8ce81",46:"f83bf354",47:"5e550ac5",48:"c4fb8ab6",49:"a43055dc",50:"9a846d99",51:"d96445d2",52:"b569403d",53:"3ed54ad9",54:"eb8b3273",55:"f8d65037",56:"eb6ad4c4",57:"b209646e",58:"b2d0e592",59:"4af484c7",60:"671eff60",61:"400e04cf",62:"f09e41bc",63:"90e1dd5a",64:"5a32ed9a",65:"8e40013a",66:"89fc2763",67:"58b9ef6f",68:"d01caaf5",69:"383945cb",70:"a5af60f8",71:"4c312526",72:"f250e38c",73:"d10d7dda",74:"afa7a2e8",75:"b52d9fa5",76:"64654eb8",77:"b377a166",78:"f7463089",79:"051facd4",80:"16893adb",81:"4c1bc8e9",82:"6afcb616",83:"5324961c",84:"2eb2e5d2",85:"31056335",86:"46ee7480",87:"ee19866d"}[n]+".js"}(n);var c=new Error;r=function(e){s.onerror=s.onload=null,clearTimeout(l);var t=i[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),r=e&&e.target&&e.target.src;c.message="Loading chunk "+n+" failed.\n("+a+": "+r+")",c.name="ChunkLoadError",c.type=a,c.request=r,t[1](c)}i[n]=void 0}};var l=setTimeout((function(){r({type:"timeout",target:s})}),12e4);s.onerror=s.onload=r,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var d=c;r.push([105,0]),t()}([function(n,e,t){var a=t(56),i=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";function a(n,e,t,a,i,r,o,s){var c,l="function"==typeof n?n.options:n;if(e&&(l.render=e,l.staticRenderFns=t,l._compiled=!0),a&&(l.functional=!0),r&&(l._scopeId="data-v-"+r),o?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},l._ssrRegister=c):i&&(c=s?function(){i.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(l.functional){l._injectStyles=c;var d=l.render;l.render=function(n,e){return c.call(e),d(n,e)}}else{var u=l.beforeCreate;l.beforeCreate=u?[].concat(u,c):[c]}return{exports:n,options:l}}t.d(e,"a",(function(){return a}))},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var a=t(30),i=Function.prototype,r=i.call,o=a&&i.bind.bind(r,r);n.exports=a?o:function(n){return function(){return r.apply(n,arguments)}}},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(4),i=t(32),r=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return r(i(n),e)}},function(n,e,t){var a=t(70),i="object"==typeof self&&self&&self.Object===Object&&self,r=a||i||Function("return this")();n.exports=r},function(n,e,t){var a=t(0),i=t(56),r=i.all;n.exports=i.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===r}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(164),i=t(167);n.exports=function(n,e){var t=i(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return r})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return c})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return v})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return h})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return k}));t(16);const a=/#.*$/,i=/\.(md|html)$/,r=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(i,"")}function c(n){return o.test(n)}function l(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(c(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",i=s(n);return r.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(i&&t!==i)return!1;return s(n.path)===s(e)}function v(n,e,t){if(c(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const r=n.replace(/^\//,"").split("/");for(let n=0;n<r.length;n++){const e=r[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,a){const{pages:i,themeConfig:r}=t,o=a&&r.locales&&r.locales[a]||r;if("auto"===(n.frontmatter.sidebar||o.sidebar||r.sidebar))return f(n);const s=o.sidebar||r.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?f(n):a?a.map(n=>function n(e,t,a,i=1){if("string"==typeof e)return v(t,e,a);if(Array.isArray(e))return Object.assign(v(t,e[0],a),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const r=e.children||[];return 0===r.length&&e.path?Object.assign(v(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:r.map(e=>n(e,t,a,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function f(n){const e=h(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function h(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(5),i=t(65),r=t(101),o=t(29),s=t(55),c=TypeError,l=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?r?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return l(n,e,t)}:l:function(n,e,t){if(o(n),e=s(e),o(t),i)try{return l(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(15),i=t(149),r=t(150),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):r(n)}},function(n,e,t){var a=t(8).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(17),i=t(32),r=t(33),o=t(130),s=t(132),c=t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),l=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();a({target:"Array",proto:!0,arity:1,forced:c||l},{push:function(n){var e=i(this),t=r(e),a=arguments.length;s(t+a);for(var c=0;c<a;c++)e[t]=arguments[c],t++;return o(e,t),t}})},function(n,e,t){var a=t(2),i=t(52).f,r=t(21),o=t(113),s=t(37),c=t(66),l=t(126);n.exports=function(n,e){var t,d,u,p,v,m=n.target,f=n.global,h=n.stat;if(t=f?a:h?a[m]||s(m,{}):(a[m]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(v=i(t,d))&&v.value:t[d],!l(f?d:m+(h?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;c(p,u)}(n.sham||u&&u.sham)&&r(p,"sham",!0),o(t,d,p,n)}}},function(n,e,t){var a=t(4),i=a({}.toString),r=a("".slice);n.exports=function(n){return r(i(n),8,-1)}},function(n,e,t){var a=t(2),i=t(0),r=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?r(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(2),i=t(62),r=t(7),o=t(64),s=t(60),c=t(59),l=i("wks"),d=a.Symbol,u=d&&d.for,p=c?d:d&&d.withoutSetter||o;n.exports=function(n){if(!r(l,n)||!s&&"string"!=typeof l[n]){var e="Symbol."+n;s&&r(d,n)?l[n]=d[n]:l[n]=c&&u?u(e):p(e)}return l[n]}},function(n,e,t){var a=t(5),i=t(13),r=t(35);n.exports=a?function(n,e,t){return i.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(154),i=t(155),r=t(156),o=t(157),s=t(158);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=r,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,e,t){var a=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(176);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(45);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function r(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,a.minimum,1),t.status=1===n?null:n;var c=t.render(!e),l=c.querySelector(a.barSelector),d=a.speed,u=a.easing;return c.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(l,function(n,e,t){var i;return(i="translate3d"===a.positionUsing?{transform:"translate3d("+r(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+r(n)+"%,0)"}:{"margin-left":r(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var i,o=e.querySelector(a.barSelector),c=n?"-100":r(t.status||0),d=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),a.showSpinner||(i=e.querySelector(a.spinnerSelector))&&p(i),d!=document.body&&l(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,i=n.length,r=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((a=n[i]+r)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,i,r=arguments;if(2==r.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&a(n,t,i);else a(n,r[1],r[2])}}();function c(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function l(n,e){var t=u(n),a=t+e;c(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=u(n);c(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=i)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/fastcv-blog/fastcv-blog","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){var a=t(9),i=String,r=TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not an object")}},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(47),i=t(53);n.exports=function(n){return a(i(n))}},function(n,e,t){var a=t(53),i=Object;n.exports=function(n){return i(a(n))}},function(n,e,t){var a=t(124);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(30),i=Function.prototype.call;n.exports=a?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(2),i=t(37),r=a["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=r},function(n,e,t){var a=t(2),i=Object.defineProperty;n.exports=function(n,e){try{i(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(148),i=t(12),r=Object.prototype,o=r.hasOwnProperty,s=r.propertyIsEnumerable,c=a(function(){return arguments}())?a:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,e,t){var a=t(10)(t(8),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(168),i=t(175),r=t(177),o=t(178),s=t(179);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=r,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(6),i=t(45),r=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!r.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(14),i=t(12);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(4),i=t(3),r=t(18),o=Object,s=a("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==r(n)?s(n,""):o(n)}:o},function(n,e,t){var a=t(0),i=t(111),r=TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,r=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,v=function(){return l.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||r.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,i,r,o,s,c,l=0,d=!1,h=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,r=i;return a=i=void 0,l=e,o=n.apply(r,t)}function y(n){return l=n,s=setTimeout(A,e),d?b(n):o}function k(n){var t=n-c;return void 0===c||t>=e||t<0||h&&n-l>=r}function A(){var n=v();if(k(n))return x(n);s=setTimeout(A,function(n){var t=e-(n-c);return h?p(t,r-(n-l)):t}(n))}function x(n){return s=void 0,g&&a?b(n):(a=i=void 0,o)}function _(){var n=v(),t=k(n);if(a=arguments,i=this,c=n,t){if(void 0===s)return y(c);if(h)return s=setTimeout(A,e),b(c)}return void 0===s&&(s=setTimeout(A,e)),o}return e=f(e)||0,m(t)&&(d=!!t.leading,r=(h="maxWait"in t)?u(f(t.maxWait)||0,e):r,g="trailing"in t?!!t.trailing:g),_.cancel=function(){void 0!==s&&clearTimeout(s),l=0,a=c=i=s=void 0},_.flush=function(){return void 0===s?o:x(v())},_}},function(n,e,t){var a=t(5),i=t(34),r=t(107),o=t(35),s=t(31),c=t(55),l=t(7),d=t(65),u=Object.getOwnPropertyDescriptor;e.f=a?u:function(n,e){if(n=s(n),e=c(e),d)try{return u(n,e)}catch(n){}if(l(n,e))return o(!i(r.f,n,e),n[e])}},function(n,e,t){var a=t(54),i=TypeError;n.exports=function(n){if(a(n))throw i("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(108),i=t(57);n.exports=function(n){var e=a(n,"string");return i(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(19),i=t(0),r=t(58),o=t(59),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&r(e.prototype,s(n))}},function(n,e,t){var a=t(4);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(60);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(61),i=t(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,i,r=t(2),o=t(109),s=r.process,c=r.Deno,l=s&&s.versions||c&&c.version,d=l&&l.v8;d&&(i=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!i&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(i=+a[1]),n.exports=i},function(n,e,t){var a=t(63),i=t(36);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.27.0",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.27.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(4),i=0,r=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+r,36)}},function(n,e,t){var a=t(5),i=t(3),r=t(100);n.exports=!a&&!i((function(){return 7!=Object.defineProperty(r("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(7),i=t(119),r=t(52),o=t(13);n.exports=function(n,e,t){for(var s=i(e),c=o.f,l=r.f,d=0;d<s.length;d++){var u=s[d];a(n,u)||t&&a(t,u)||c(n,u,l(e,u))}}},function(n,e,t){var a=t(123);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(4),i=t(29),r=t(136);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return i(t),r(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,i=n.length;++t<a;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(22),i=t(159),r=t(160),o=t(161),s=t(162),c=t(163);function l(n){var e=this.__data__=new a(n);this.size=e.size}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(14),i=t(40);n.exports=function(n){if(!i(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(180),i=t(12);n.exports=function n(e,t,r,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:a(e,t,r,o,n,s))}},function(n,e,t){var a=t(77),i=t(183),r=t(78);n.exports=function(n,e,t,o,s,c){var l=1&t,d=n.length,u=e.length;if(d!=u&&!(l&&u>d))return!1;var p=c.get(n),v=c.get(e);if(p&&v)return p==e&&v==n;var m=-1,f=!0,h=2&t?new a:void 0;for(c.set(n,e),c.set(e,n);++m<d;){var g=n[m],b=e[m];if(o)var y=l?o(b,g,m,e,n,c):o(g,b,m,n,e,c);if(void 0!==y){if(y)continue;f=!1;break}if(h){if(!i(e,(function(n,e){if(!r(h,e)&&(g===n||s(g,n,t,o,c)))return h.push(e)}))){f=!1;break}}else if(g!==b&&!s(g,b,t,o,c)){f=!1;break}}return c.delete(n),c.delete(e),f}},function(n,e,t){var a=t(41),i=t(181),r=t(182);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=r,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(193),i=t(199),r=t(83);n.exports=function(n){return r(n)?a(n):i(n)}},function(n,e,t){(function(n){var a=t(8),i=t(195),r=e&&!e.nodeType&&e,o=r&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===r?a.Buffer:void 0,c=(s?s.isBuffer:void 0)||i;n.exports=c}).call(this,t(50)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(196),i=t(197),r=t(198),o=r&&r.isTypedArray,s=o?i(o):a;n.exports=s},function(n,e,t){var a=t(73),i=t(43);n.exports=function(n){return null!=n&&i(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(8),"Set");n.exports=a},function(n,e,t){var a=t(40);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(88),i=t(26);n.exports=function(n,e){for(var t=0,r=(e=a(e,n)).length;null!=n&&t<r;)n=n[i(e[t++])];return t&&t==r?n:void 0}},function(n,e,t){var a=t(6),i=t(44),r=t(210),o=t(213);n.exports=function(n,e){return a(n)?n:i(n,e)?[n]:r(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(146),i=t(151),r=t(222),o=t(230),s=t(239),c=t(104),l=r((function(n){var e=c(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),i(e,2))}));n.exports=l},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=a.exec(t);if(!i)return t;var r="",o=0,s=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(r+=t.substring(s,o)),s=o+1,r+=e}return s!==o?r+t.substring(s,o):r}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var a=t(249),i=t(250),r=t(251),o=!1,s=t(252).version,c=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],l=c.concat("cache"),d=/^\uFEFF/;function u(n,t){var i,r,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)i=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(r=e.resolveInclude(n,t.filename),a.existsSync(r)&&(i=r)),i||Array.isArray(o)&&o.some((function(t){return r=e.resolveInclude(n,t,!0),a.existsSync(r)}))&&(i=r),!i)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return i}function p(n,t){var a,i=n.filename,r=arguments.length>1;if(n.cache){if(!i)throw new Error("cache option requires a filename");if(a=e.cache.get(i))return a;r||(t=m(i).toString().replace(d,""))}else if(!r){if(!i)throw new Error("Internal EJS error: no file name or template provided");t=m(i).toString().replace(d,"")}return a=e.compile(t,n),n.cache&&e.cache.set(i,a),a}function v(n,t,a){var i;if(!a){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,a){try{e(i=p(n)(t))}catch(n){a(n)}}));throw new Error("Please provide a callback function")}try{i=p(n)(t)}catch(n){return a(n)}a(null,i)}function m(n){return e.fileLoader(n)}function f(n,e,t,a,i){var r=e.split("\n"),o=Math.max(a-3,0),s=Math.min(r.length,a+3),c=i(t),l=r.slice(o,s).map((function(n,e){var t=e+o+1;return(t==a?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=c,n.message=(c||"ejs")+":"+a+"\n"+l+"\n\n"+n.message,n}function h(n){return n.replace(/;(\s*$)/,"$1")}function g(n,t){t=t||{};var a={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],a.client=t.client||!1,a.escapeFunction=t.escape||t.escapeFunction||r.escapeXML,a.compileDebug=!1!==t.compileDebug,a.debug=!!t.debug,a.filename=t.filename,a.openDelimiter=t.openDelimiter||e.openDelimiter||"<",a.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",a.delimiter=t.delimiter||e.delimiter||"%",a.strict=t.strict||!1,a.context=t.context,a.cache=t.cache||!1,a.rmWhitespace=t.rmWhitespace,a.root=t.root,a.outputFunctionName=t.outputFunctionName,a.localsName=t.localsName||e.localsName||"locals",a.views=t.views,a.async=t.async,a.destructuredLocals=t.destructuredLocals,a.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,a.strict?a._with=!1:a._with=void 0===t._with||t._with,this.opts=a,this.regex=this.createRegex()}e.cache=r.cache,e.fileLoader=a.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var a=i.dirname,r=i.extname,o=(0,i.resolve)(t?e:a(e),n);return r(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new g(n,e).compile()},e.render=function(n,e,t){var a=e||{},i=t||{};return 2==arguments.length&&r.shallowCopyFromList(i,a,c),p(i,n)(a)},e.renderFile=function(){var n,e,t,a=Array.prototype.slice.call(arguments),i=a.shift(),o={filename:i};return"function"==typeof arguments[arguments.length-1]&&(n=a.pop()),a.length?(e=a.shift(),a.length?r.shallowCopy(o,a.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&r.shallowCopy(o,t)),r.shallowCopyFromList(o,e,l)),o.filename=i):e={},v(o,e,n)},e.Template=g,e.clearCache=function(){e.cache.reset()},g.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},g.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=r.escapeRegExpChars(this.opts.delimiter),t=r.escapeRegExpChars(this.opts.openDelimiter),a=r.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,a),new RegExp(n)},compile:function(){var n,e,t,a=this.opts,o="",s="",c=a.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',a.outputFunctionName&&(o+="  var "+a.outputFunctionName+" = __append;\n"),a.destructuredLocals&&a.destructuredLocals.length){for(var l="  var __locals = ("+a.localsName+" || {}),\n",d=0;d<a.destructuredLocals.length;d++){var v=a.destructuredLocals[d];d>0&&(l+=",\n  "),l+=v+" = __locals."+v}o+=l+";\n"}!1!==a._with&&(o+="  with ("+a.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=a.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(a.filename?JSON.stringify(a.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,a.client&&(n="escapeFn = escapeFn || "+c.toString()+";\n"+n,a.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),a.strict&&(n='"use strict";\n'+n),a.debug&&console.log(n),a.compileDebug&&a.filename&&(n=n+"\n//# sourceURL="+a.filename+"\n");try{if(a.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(a.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(a.filename&&(n.message+=" in "+a.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",a.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var m=a.client?e:function(n){return e.apply(a.context,[n||{},c,function(e,t){var i=r.shallowCopy({},n);return t&&(i=r.shallowCopy(i,t)),function(n,e){var t=r.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,a)(i)},f])};if(m.dependencies=this.dependencies,a.filename&&"function"==typeof Object.defineProperty){var h=a.filename,g=i.basename(h,i.extname(h));try{Object.defineProperty(m,"name",{value:g,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return m},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,a=this.parseTemplateText(),i=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;a&&a.length&&a.forEach((function(c,l){var p,v,f,h,b,y;if(0===c.indexOf(o+i)&&0!==c.indexOf(o+i+i)&&(v=a[l+2])!=i+s&&v!="-"+i+s&&v!="_"+i+s)throw new Error('Could not find matching close tag for "'+c+'".');if(n.legacyInclude&&(f=c.match(/^\s*include\s+(\S+)/))&&(p=a[l-1])&&(p==o+i||p==o+i+"-"||p==o+i+"_"))return h=r.shallowCopy({},t.opts),b=function(n,e){var t,a,i=r.shallowCopy({},e);a=m(t=u(n,i)).toString().replace(d,""),i.filename=t;var o=new g(a,i);return o.generateSource(),{source:o.source,filename:t,template:a}}(f[1],h),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(f[1],h.filename));t.scanLine(c)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,a=t.exec(e),i=[];a;)0!==(n=a.index)&&(i.push(e.substring(0,n)),e=e.slice(n)),i.push(a[0]),e=e.slice(a[0].length),a=t.exec(e);return e&&i.push(e),i},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,a=this.opts.openDelimiter,i=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case a+t:case a+t+"_":this.mode=g.modes.EVAL;break;case a+t+"=":this.mode=g.modes.ESCAPED;break;case a+t+"-":this.mode=g.modes.RAW;break;case a+t+"#":this.mode=g.modes.COMMENT;break;case a+t+t:this.mode=g.modes.LITERAL,this.source+='    ; __append("'+n.replace(a+t+t,a+t)+'")\n';break;case t+t+i:this.mode=g.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+i,t+i)+'")\n';break;case t+i:case"-"+t+i:case"_"+t+i:this.mode==g.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case g.modes.EVAL:case g.modes.ESCAPED:case g.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case g.modes.EVAL:this.source+="    ; "+n+"\n";break;case g.modes.ESCAPED:this.source+="    ; __append(escapeFn("+h(n)+"))\n";break;case g.modes.RAW:this.source+="    ; __append("+h(n)+")\n";break;case g.modes.COMMENT:break;case g.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=r.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(242),t(1)),r=Object(i.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=r.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(243),t(1)),r=Object(i.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=r.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(2),i=t(9),r=a.document,o=i(r)&&i(r.createElement);n.exports=function(n){return o?r.createElement(n):{}}},function(n,e,t){var a=t(5),i=t(3);n.exports=a&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(62),i=t(64),r=a("keys");n.exports=function(n){return r[n]||(r[n]=i(n))}},function(n,e,t){var a=t(4),i=t(7),r=t(31),o=t(121).indexOf,s=t(49),c=a([].push);n.exports=function(n,e){var t,a=r(n),l=0,d=[];for(t in a)!i(s,t)&&i(a,t)&&c(d,t);for(;e.length>l;)i(a,t=e[l++])&&(~o(d,t)||c(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(255)},function(n,e,t){"use strict";var a=t(17),i=t(127).left,r=t(128),o=t(61),s=t(129);a({target:"Array",proto:!0,forced:!r("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,r=i&&!a.call({1:2},1);e.f=r?function(n){var e=i(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(34),i=t(9),r=t(57),o=t(110),s=t(112),c=t(20),l=TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!i(n)||r(n))return n;var t,c=o(n,d);if(c){if(void 0===e&&(e="default"),t=a(c,n,e),!i(t)||r(t))return t;throw l("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var a=t(19);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(48),i=t(54);n.exports=function(n,e){var t=n[e];return i(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(34),i=t(0),r=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&i(t=n.toString)&&!r(s=a(t,n)))return s;if(i(t=n.valueOf)&&!r(s=a(t,n)))return s;if("string"!==e&&i(t=n.toString)&&!r(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),i=t(13),r=t(114),o=t(37);n.exports=function(n,e,t,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:e;if(a(t)&&r(t,l,s),s.global)c?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(c=!0):delete n[e]}catch(n){}c?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(3),i=t(0),r=t(7),o=t(5),s=t(115).CONFIGURABLE,c=t(116),l=t(117),d=l.enforce,u=l.get,p=Object.defineProperty,v=o&&!a((function(){return 8!==p((function(){}),"length",{value:8}).length})),m=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!r(n,"name")||s&&n.name!==e)&&(o?p(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&r(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity});try{t&&r(t,"constructor")&&t.constructor?o&&p(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return r(a,"source")||(a.source=m.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return i(this)&&u(this).source||c(this)}),"toString")},function(n,e,t){var a=t(5),i=t(7),r=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=i(r,"name"),c=s&&"something"===function(){}.name,l=s&&(!a||a&&o(r,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,e,t){var a=t(4),i=t(0),r=t(36),o=a(Function.toString);i(r.inspectSource)||(r.inspectSource=function(n){return o(n)}),n.exports=r.inspectSource},function(n,e,t){var a,i,r,o=t(118),s=t(2),c=t(9),l=t(21),d=t(7),u=t(36),p=t(102),v=t(49),m=s.TypeError,f=s.WeakMap;if(o||u.state){var h=u.state||(u.state=new f);h.get=h.get,h.has=h.has,h.set=h.set,a=function(n,e){if(h.has(n))throw m("Object already initialized");return e.facade=n,h.set(n,e),e},i=function(n){return h.get(n)||{}},r=function(n){return h.has(n)}}else{var g=p("state");v[g]=!0,a=function(n,e){if(d(n,g))throw m("Object already initialized");return e.facade=n,l(n,g,e),e},i=function(n){return d(n,g)?n[g]:{}},r=function(n){return d(n,g)}}n.exports={set:a,get:i,has:r,enforce:function(n){return r(n)?i(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=i(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(2),i=t(0),r=a.WeakMap;n.exports=i(r)&&/native code/.test(String(r))},function(n,e,t){var a=t(19),i=t(4),r=t(120),o=t(125),s=t(29),c=i([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=r.f(s(n)),t=o.f;return t?c(e,t(n)):e}},function(n,e,t){var a=t(103),i=t(99).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,i)}},function(n,e,t){var a=t(31),i=t(122),r=t(33),o=function(n){return function(e,t,o){var s,c=a(e),l=r(c),d=i(o,l);if(n&&t!=t){for(;l>d;)if((s=c[d++])!=s)return!0}else for(;l>d;d++)if((n||d in c)&&c[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(67),i=Math.max,r=Math.min;n.exports=function(n,e){var t=a(n);return t<0?i(t+e,0):r(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(67),i=Math.min;n.exports=function(n){return n>0?i(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(3),i=t(0),r=/#|\.prototype\./,o=function(n,e){var t=c[s(n)];return t==d||t!=l&&(i(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(r,".").toLowerCase()},c=o.data={},l=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(48),i=t(32),r=t(47),o=t(33),s=TypeError,c=function(n){return function(e,t,c,l){a(t);var d=i(e),u=r(d),p=o(d),v=n?p-1:0,m=n?-1:1;if(c<2)for(;;){if(v in u){l=u[v],v+=m;break}if(v+=m,n?v<0:p<=v)throw s("Reduce of empty array with no initial value")}for(;n?v>=0:p>v;v+=m)v in u&&(l=t(l,u[v],v,d));return l}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(18),i=t(2);n.exports="process"==a(i.process)},function(n,e,t){"use strict";var a=t(5),i=t(131),r=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(i(n)&&!o(n,"length").writable)throw r("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(18);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(17),i=t(2),r=t(134),o=t(135),s=i.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,e){var t={};t[n]=o(n,e,c),a({global:!0,constructor:!0,arity:1,forced:c},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,c),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},t)}};l("Error",(function(n){return function(e){return r(n,this,arguments)}})),l("EvalError",(function(n){return function(e){return r(n,this,arguments)}})),l("RangeError",(function(n){return function(e){return r(n,this,arguments)}})),l("ReferenceError",(function(n){return function(e){return r(n,this,arguments)}})),l("SyntaxError",(function(n){return function(e){return r(n,this,arguments)}})),l("TypeError",(function(n){return function(e){return r(n,this,arguments)}})),l("URIError",(function(n){return function(e){return r(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return r(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return r(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return r(n,this,arguments)}}))},function(n,e,t){var a=t(30),i=Function.prototype,r=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(r):function(){return o.apply(r,arguments)})},function(n,e,t){"use strict";var a=t(19),i=t(7),r=t(21),o=t(58),s=t(68),c=t(66),l=t(137),d=t(138),u=t(139),p=t(143),v=t(144),m=t(145),f=t(5),h=t(63);n.exports=function(n,e,t,g){var b=g?2:1,y=n.split("."),k=y[y.length-1],A=a.apply(null,y);if(A){var x=A.prototype;if(!h&&i(x,"cause")&&delete x.cause,!t)return A;var _=a("Error"),w=e((function(n,e){var t=u(g?e:n,void 0),a=g?new A(n):new A;return void 0!==t&&r(a,"message",t),m&&r(a,"stack",v(a.stack,2)),this&&o(x,this)&&d(a,this,w),arguments.length>b&&p(a,arguments[b]),a}));if(w.prototype=x,"Error"!==k?s?s(w,_):c(w,_,{name:!0}):f&&"stackTraceLimit"in A&&(l(w,A,"stackTraceLimit"),l(w,A,"prepareStackTrace")),c(w,A),!h)try{x.name!==k&&r(x,"name",k),x.constructor=w}catch(n){}return w}}},function(n,e,t){var a=t(0),i=String,r=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw r("Can't set "+i(n)+" as a prototype")}},function(n,e,t){var a=t(13).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),i=t(9),r=t(68);n.exports=function(n,e,t){var o,s;return r&&a(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&r(n,s),n}},function(n,e,t){var a=t(140);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(141),i=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var a=t(142),i=t(0),r=t(18),o=t(20)("toStringTag"),s=Object,c="Arguments"==r(function(){return arguments}());n.exports=a?r:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:c?r(e):"Object"==(a=r(e))&&i(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(20)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),i=t(21);n.exports=function(n,e){a(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var a=t(4),i=Error,r=a("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(o);n.exports=function(n,e){if(c&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=r(n,s,"");return n}},function(n,e,t){var a=t(3),i=t(35);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(69),i=t(147);n.exports=function n(e,t,r,o,s){var c=-1,l=e.length;for(r||(r=i),s||(s=[]);++c<l;){var d=e[c];t>0&&r(d)?t>1?n(d,t-1,r,o,s):a(s,d):o||(s[s.length]=d)}return s}},function(n,e,t){var a=t(15),i=t(38),r=t(6),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return r(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(14),i=t(12);n.exports=function(n){return i(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),i=Object.prototype,r=i.hasOwnProperty,o=i.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=r.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var i=o.call(n);return a&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(152),i=t(208),r=t(46),o=t(6),s=t(219);n.exports=function(n){return"function"==typeof n?n:null==n?r:"object"==typeof n?o(n)?i(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(153),i=t(207),r=t(86);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?r(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(71),i=t(75);n.exports=function(n,e,t,r){var o=t.length,s=o,c=!r;if(null==n)return!s;for(n=Object(n);o--;){var l=t[o];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++o<s;){var d=(l=t[o])[0],u=n[d],p=l[1];if(c&&l[2]){if(void 0===u&&!(d in n))return!1}else{var v=new a;if(r)var m=r(u,p,d,n,e,v);if(!(void 0===m?i(p,u,3,r,v):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(23),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(23);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(23);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(23);n.exports=function(n,e){var t=this.__data__,i=a(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var a=t(22);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(22),i=t(39),r=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new r(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(73),i=t(165),r=t(40),o=t(74),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,d=c.toString,u=l.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!r(n)||i(n))&&(a(n)?p:s).test(o(n))}},function(n,e,t){var a,i=t(166),r=(a=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!r&&r in n}},function(n,e,t){var a=t(8)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(169),i=t(22),r=t(39);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(r||i),string:new a}}},function(n,e,t){var a=t(170),i=t(171),r=t(172),o=t(173),s=t(174);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=r,c.prototype.has=o,c.prototype.set=s,n.exports=c},function(n,e,t){var a=t(24);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(24),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(24),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var a=t(24);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(25);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(25);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(25);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(25);n.exports=function(n,e){var t=a(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var a=t(71),i=t(76),r=t(184),o=t(187),s=t(203),c=t(6),l=t(80),d=t(82),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,v,m,f){var h=c(n),g=c(e),b=h?"[object Array]":s(n),y=g?"[object Array]":s(e),k=(b="[object Arguments]"==b?u:b)==u,A=(y="[object Arguments]"==y?u:y)==u,x=b==y;if(x&&l(n)){if(!l(e))return!1;h=!0,k=!1}if(x&&!k)return f||(f=new a),h||d(n)?i(n,e,t,v,m,f):r(n,e,b,t,v,m,f);if(!(1&t)){var _=k&&p.call(n,"__wrapped__"),w=A&&p.call(e,"__wrapped__");if(_||w){var S=_?n.value():n,E=w?e.value():e;return f||(f=new a),m(S,E,t,v,f)}}return!!x&&(f||(f=new a),o(n,e,t,v,m,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),i=t(185),r=t(72),o=t(76),s=t(186),c=t(42),l=a?a.prototype:void 0,d=l?l.valueOf:void 0;n.exports=function(n,e,t,a,l,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return r(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var v=s;case"[object Set]":var m=1&a;if(v||(v=c),n.size!=e.size&&!m)return!1;var f=p.get(n);if(f)return f==e;a|=2,p.set(n,e);var h=o(v(n),v(e),a,l,u,p);return p.delete(n),h;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(8).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(188),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,r,o,s){var c=1&t,l=a(n),d=l.length;if(d!=a(e).length&&!c)return!1;for(var u=d;u--;){var p=l[u];if(!(c?p in e:i.call(e,p)))return!1}var v=s.get(n),m=s.get(e);if(v&&m)return v==e&&m==n;var f=!0;s.set(n,e),s.set(e,n);for(var h=c;++u<d;){var g=n[p=l[u]],b=e[p];if(r)var y=c?r(b,g,p,e,n,s):r(g,b,p,n,e,s);if(!(void 0===y?g===b||o(g,b,t,r,s):y)){f=!1;break}h||(h="constructor"==p)}if(f&&!h){var k=n.constructor,A=e.constructor;k==A||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof A&&A instanceof A||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var a=t(189),i=t(190),r=t(79);n.exports=function(n){return a(n,r,i)}},function(n,e,t){var a=t(69),i=t(6);n.exports=function(n,e,t){var r=e(n);return i(n)?r:a(r,t(n))}},function(n,e,t){var a=t(191),i=t(192),r=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return r.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=0,r=[];++t<a;){var o=n[t];e(o,t,n)&&(r[i++]=o)}return r}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(194),i=t(38),r=t(6),o=t(80),s=t(81),c=t(82),l=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=r(n),d=!t&&i(n),u=!t&&!d&&o(n),p=!t&&!d&&!u&&c(n),v=t||d||u||p,m=v?a(n.length,String):[],f=m.length;for(var h in n)!e&&!l.call(n,h)||v&&("length"==h||u&&("offset"==h||"parent"==h)||p&&("buffer"==h||"byteLength"==h||"byteOffset"==h)||s(h,f))||m.push(h);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(14),i=t(43),r=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return r(n)&&i(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(70),i=e&&!e.nodeType&&e,r=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=r&&r.exports===i&&a.process,s=function(){try{var n=r&&r.require&&r.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(50)(n))},function(n,e,t){var a=t(200),i=t(201),r=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return i(n);var e=[];for(var t in Object(n))r.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(202)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(204),i=t(39),r=t(205),o=t(84),s=t(206),c=t(14),l=t(74),d=l(a),u=l(i),p=l(r),v=l(o),m=l(s),f=c;(a&&"[object DataView]"!=f(new a(new ArrayBuffer(1)))||i&&"[object Map]"!=f(new i)||r&&"[object Promise]"!=f(r.resolve())||o&&"[object Set]"!=f(new o)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=c(n),t="[object Object]"==e?n.constructor:void 0,a=t?l(t):"";if(a)switch(a){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case v:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var a=t(10)(t(8),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(8),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(8),"WeakMap");n.exports=a},function(n,e,t){var a=t(85),i=t(79);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var r=e[t],o=n[r];e[t]=[r,o,a(o)]}return e}},function(n,e,t){var a=t(75),i=t(209),r=t(216),o=t(44),s=t(85),c=t(86),l=t(26);n.exports=function(n,e){return o(n)&&s(e)?c(l(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?r(t,n):a(e,o,3)}}},function(n,e,t){var a=t(87);n.exports=function(n,e,t){var i=null==n?void 0:a(n,e);return void 0===i?t:i}},function(n,e,t){var a=t(211),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,r=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,a,i){e.push(a?i.replace(r,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(212);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(41);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,i=e?e.apply(this,a):a[0],r=t.cache;if(r.has(i))return r.get(i);var o=n.apply(this,a);return t.cache=r.set(i,o)||r,o};return t.cache=new(i.Cache||a),t}i.Cache=a,n.exports=i},function(n,e,t){var a=t(214);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),i=t(215),r=t(6),o=t(45),s=a?a.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(r(e))return i(e,n)+"";if(o(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=Array(a);++t<a;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var a=t(217),i=t(218);n.exports=function(n,e){return null!=n&&i(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(88),i=t(38),r=t(6),o=t(81),s=t(43),c=t(26);n.exports=function(n,e,t){for(var l=-1,d=(e=a(e,n)).length,u=!1;++l<d;){var p=c(e[l]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++l!=d?u:!!(d=null==n?0:n.length)&&s(d)&&o(p,d)&&(r(n)||i(n))}},function(n,e,t){var a=t(220),i=t(221),r=t(44),o=t(26);n.exports=function(n){return r(n)?a(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(87);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(46),i=t(223),r=t(225);n.exports=function(n,e){return r(i(n,e,a),n+"")}},function(n,e,t){var a=t(224),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var r=arguments,o=-1,s=i(r.length-e,0),c=Array(s);++o<s;)c[o]=r[e+o];o=-1;for(var l=Array(e+1);++o<e;)l[o]=r[o];return l[e]=t(c),a(n,this,l)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(226),i=t(229)(a);n.exports=i},function(n,e,t){var a=t(227),i=t(228),r=t(46),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:r;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),i=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var i=t(),r=16-(i-a);if(a=i,r>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(77),i=t(231),r=t(236),o=t(78),s=t(237),c=t(42);n.exports=function(n,e,t){var l=-1,d=i,u=n.length,p=!0,v=[],m=v;if(t)p=!1,d=r;else if(u>=200){var f=e?null:s(n);if(f)return c(f);p=!1,d=o,m=new a}else m=e?[]:v;n:for(;++l<u;){var h=n[l],g=e?e(h):h;if(h=t||0!==h?h:0,p&&g==g){for(var b=m.length;b--;)if(m[b]===g)continue n;e&&m.push(g),v.push(h)}else d(m,g,t)||(m!==v&&m.push(g),v.push(h))}return v}},function(n,e,t){var a=t(232);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(233),i=t(234),r=t(235);n.exports=function(n,e,t){return e==e?r(n,e,t):a(n,i,t)}},function(n,e){n.exports=function(n,e,t,a){for(var i=n.length,r=t+(a?1:-1);a?r--:++r<i;)if(e(n[r],r,n))return r;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,i=n.length;++a<i;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,i=null==n?0:n.length;++a<i;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(84),i=t(238),r=t(42),o=a&&1/r(new a([,-0]))[1]==1/0?function(n){return new a(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(83),i=t(12);n.exports=function(n){return i(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){var a=t(17),i=t(2),r=t(248);a({global:!0},{Reflect:{}}),r(i.Reflect,"Reflect",!0)},function(n,e,t){var a=t(13).f,i=t(7),r=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,r)&&a(n,r,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,a=n.length-1;a>=0;a--){var i=n[a];"."===i?n.splice(a,1):".."===i?(n.splice(a,1),t++):t&&(n.splice(a,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function a(n,e){if(n.filter)return n.filter(e);for(var t=[],a=0;a<n.length;a++)e(n[a],a,n)&&t.push(n[a]);return t}e.resolve=function(){for(var n="",e=!1,i=arguments.length-1;i>=-1&&!e;i--){var r=i>=0?arguments[i]:process.cwd();if("string"!=typeof r)throw new TypeError("Arguments to path.resolve must be strings");r&&(n=r+"/"+n,e="/"===r.charAt(0))}return(e?"/":"")+(n=t(a(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var r=e.isAbsolute(n),o="/"===i(n,-1);return(n=t(a(n.split("/"),(function(n){return!!n})),!r).join("/"))||r||(n="."),n&&o&&(n+="/"),(r?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(a(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function a(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var i=a(n.split("/")),r=a(t.split("/")),o=Math.min(i.length,r.length),s=o,c=0;c<o;c++)if(i[c]!==r[c]){s=c;break}var l=[];for(c=s;c<i.length;c++)l.push("..");return(l=l.concat(r.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,a=-1,i=!0,r=n.length-1;r>=1;--r)if(47===(e=n.charCodeAt(r))){if(!i){a=r;break}}else i=!1;return-1===a?t?"/":".":t&&1===a?"/":n.slice(0,a)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,a=-1,i=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!i){t=e+1;break}}else-1===a&&(i=!1,a=e+1);return-1===a?"":n.slice(t,a)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,a=-1,i=!0,r=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===a&&(i=!1,a=o+1),46===s?-1===e?e=o:1!==r&&(r=1):-1!==e&&(r=-1);else if(!i){t=o+1;break}}return-1===e||-1===a||0===r||1===r&&e===a-1&&e===t+1?"":n.slice(e,a)};var i="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var a=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(a,"\\$&"):""};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},r=/[&<>'"]/g;function o(n){return i[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(r,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var a=0;a<t.length;a++){var i=t[a];void 0!==e[i]&&(n[i]=e[i])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/fastcv-blog/fastcv-blog/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),i=Array.isArray;function r(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function v(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),a=n.split(","),i=0;i<a.length;i++)t[a[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var A=Object.prototype.hasOwnProperty;function x(n,e){return A.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,S=_((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),E=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,C=_((function(n){return n.replace(I,"-$1").toLowerCase()}));var T=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function B(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function P(n,e){for(var t in e)n[t]=e[t];return n}function R(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function j(n,e,t){}var M=function(n,e,t){return!1},L=function(n){return n};function O(n,e){if(n===e)return!0;var t=d(n),a=d(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var i=Array.isArray(n),r=Array.isArray(e);if(i&&r)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||r)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function N(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function z(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:M,isReservedAttr:M,isUnknownElement:M,getTagNamespace:j,parsePlatformTagName:L,mustUseProp:M,async:!0,_lifecycleHooks:$},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function W(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(H.source,".$_\\d]"));var J="__proto__"in{},G="undefined"!=typeof window,K=G&&window.navigator.userAgent.toLowerCase(),Y=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Z=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Q=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(G)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);ln="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var vn=function(){function n(n,e,t,a,i,r,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=i,this.ns=void 0,this.context=r,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function fn(n){return new vn(void 0,void 0,void 0,String(n))}function hn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var gn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=gn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var kn=[];function An(n){kn.push(n),yn.target=n}function xn(){kn.pop(),yn.target=kn[kn.length-1]}var _n=Array.prototype,wn=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=_n[n];W(wn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var i,r=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),r}))}));var Sn=Object.getOwnPropertyNames(wn),En={},In=!0;function Cn(n){In=n}var Tn={notify:j,depend:j,addSub:j,removeSub:j},Bn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Tn:new yn,this.vmCount=0,W(n,"__ob__",this),i(n)){if(!t)if(J)n.__proto__=wn;else for(var a=0,r=Sn.length;a<r;a++){W(n,s=Sn[a],wn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;Rn(n,s=o[a],En,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&x(n,"__ob__")&&n.__ob__ instanceof Bn?n.__ob__:!In||!t&&on()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||zn(n)||n instanceof vn?void 0:new Bn(n,e,t)}function Rn(n,e,t,a,r,o){var s=new yn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var l=c&&c.get,d=c&&c.set;l&&!d||t!==En&&2!==arguments.length||(t=n[e]);var u=!r&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return yn.target&&(s.depend(),u&&(u.dep.depend(),i(e)&&Ln(e))),zn(e)&&!r?e.value:e},set:function(e){var a=l?l.call(n):t;if(z(a,e)){if(d)d.call(n,e);else{if(l)return;if(!r&&zn(a)&&!zn(e))return void(a.value=e);t=e}u=!r&&Pn(e,!1,o),s.notify()}}}),s}}function jn(n,e,t){if(!Nn(n)){var a=n.__ob__;return i(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Rn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Mn(n,e){if(i(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Nn(n)||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function Ln(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Ln(e)}function On(n){return Dn(n,!0),W(n,"__v_isShallow",!0),n}function Dn(n,e){if(!Nn(n)){Pn(n,e,on());0}}function Nn(n){return!(!n||!n.__v_isReadonly)}function zn(n){return!(!n||!0!==n.__v_isRef)}function Un(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(zn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];zn(a)&&!zn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var $n;var Fn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=$n,!n&&$n&&(this.index=($n.scopes||($n.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=$n;try{return $n=this,n()}finally{$n=e}}else 0},n.prototype.on=function(){$n=this},n.prototype.off=function(){$n=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var qn=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Wn(n,e){function t(){var n=t.fns;if(!i(n))return Ie(n,null,arguments,e,"v-on handler");for(var a=n.slice(),r=0;r<a.length;r++)Ie(a[r],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,a,i,o){var c,l,d,u;for(c in n)l=n[c],d=e[c],u=qn(c),r(l)||(r(d)?(r(l.fns)&&(l=n[c]=Wn(l,o)),s(u.once)&&(l=n[c]=i(u.name,l,u.capture)),t(u.name,l,u.capture,u.passive,u.params)):l!==d&&(d.fns=l,n[c]=d));for(c in e)r(n[c])&&a((u=qn(c)).name,e[c],u.capture)}function Jn(n,e,t){var a;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function c(){t.apply(this,arguments),k(a.fns,c)}r(i)?a=Wn([c]):o(i.fns)&&s(i.merged)?(a=i).fns.push(c):a=Wn([i,c]),a.merged=!0,n[e]=a}function Gn(n,e,t,a,i){if(o(e)){if(x(e,t))return n[t]=e[t],i||delete e[t],!0;if(x(e,a))return n[t]=e[a],i||delete e[a],!0}return!1}function Kn(n){return c(n)?[fn(n)]:i(n)?function n(e,t){var a,l,d,u,p=[];for(a=0;a<e.length;a++)r(l=e[a])||"boolean"==typeof l||(d=p.length-1,u=p[d],i(l)?l.length>0&&(Yn((l=n(l,"".concat(t||"","_").concat(a)))[0])&&Yn(u)&&(p[d]=fn(u.text+l[0].text),l.shift()),p.push.apply(p,l)):c(l)?Yn(u)?p[d]=fn(u.text+l):""!==l&&p.push(fn(l)):Yn(l)&&Yn(u)?p[d]=fn(u.text+l.text):(s(e._isVList)&&o(l.tag)&&r(l.key)&&o(t)&&(l.key="__vlist".concat(t,"_").concat(a,"__")),p.push(l)));return p}(n):void 0}function Yn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Xn(n,e){var t,a,r,s,c=null;if(i(n)||"string"==typeof n)for(c=new Array(n.length),t=0,a=n.length;t<a;t++)c[t]=e(n[t],t);else if("number"==typeof n)for(c=new Array(n),t=0;t<n;t++)c[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){c=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)c.push(e(u.value,c.length)),u=l.next()}else for(r=Object.keys(n),c=new Array(r.length),t=0,a=r.length;t<a;t++)s=r[t],c[t]=e(n[s],s,t);return o(c)||(c=[]),c._isVList=!0,c}function Zn(n,e,t,a){var i,r=this.$scopedSlots[n];r?(t=t||{},a&&(t=P(P({},a),t)),i=r(t)||(l(e)?e():e)):i=this.$slots[n]||(l(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function Qn(n){return Bt(this.$options,"filters",n,!0)||L}function ne(n,e){return i(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,i){var r=F.keyCodes[e]||t;return i&&a&&!F.keyCodes[e]?ne(i,a):r?ne(r,n):a?C(a)!==e:void 0===n}function te(n,e,t,a,r){if(t)if(d(t)){i(t)&&(t=R(t));var o=void 0,s=function(i){if("class"===i||"style"===i||y(i))o=n;else{var s=n.attrs&&n.attrs.type;o=a||F.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=S(i),l=C(i);c in o||l in o||(o[i]=t[i],r&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var c in t)s(c)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||re(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ie(n,e,t){return re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function re(n,e,t){if(i(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&oe(n[a],"".concat(e,"_").concat(a),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?P({},n.on):{};for(var a in e){var i=t[a],r=e[a];t[a]=i?[].concat(i,r):r}}else;return n}function ce(n,e,t,a){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var o=n[r];i(o)?ce(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function le(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ie,n._n=g,n._s=h,n._l=Xn,n._t=Zn,n._q=O,n._i=D,n._m=ae,n._f=Qn,n._k=ee,n._b=te,n._v=fn,n._e=mn,n._u=ce,n._g=se,n._d=le,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,i=n.length;a<i;a++){var r=n[a],o=r.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,r.context!==e&&r.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(r);else{var s=o.slot,c=t[s]||(t[s]=[]);"template"===r.tag?c.push.apply(c,r.children||[]):c.push(r)}}for(var l in t)t[l].every(ve)&&delete t[l];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,i){var r,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,c=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&i&&i!==a&&c===i.$key&&!o&&!i.$hasNormal)return i;for(var l in r={},e)e[l]&&"$"!==l[0]&&(r[l]=he(n,t,l,e[l]))}else r={};for(var d in t)d in r||(r[d]=ge(t,d));return e&&Object.isExtensible(e)&&(e._normalized=r),W(r,"$stable",s),W(r,"$key",c),W(r,"$hasNormal",o),r}function he(n,e,t,a){var r=function(){var e=un;pn(n);var t=arguments.length?a.apply(null,arguments):a({}),r=(t=t&&"object"==typeof t&&!i(t)?[t]:Kn(t))&&t[0];return pn(e),t&&(!r||1===t.length&&r.isComment&&!me(r))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:r,enumerable:!0,configurable:!0}),r}function ge(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};W(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Ae(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:T(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Un(n,e,t)}))}}}function ye(n,e,t,a,i){var r=!1;for(var o in e)o in n?e[o]!==t[o]&&(r=!0):(r=!0,ke(n,o,a,i));for(var o in n)o in e||(r=!0,delete n[o]);return r}function ke(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function Ae(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var xe=null;function _e(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function we(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||me(t)))return t}}function Se(n,e,t,a,u,p){return(i(t)||c(t))&&(u=a,a=t,t=void 0),s(p)&&(u=2),function(n,e,t,a,c){if(o(t)&&o(t.__ob__))return mn();o(t)&&o(t.is)&&(e=t.is);if(!e)return mn();0;i(a)&&l(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===c?a=Kn(a):1===c&&(a=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var u,p;if("string"==typeof e){var v=void 0;p=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),u=F.isReservedTag(e)?new vn(F.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(v=Bt(n.$options,"components",e))?new vn(e,t,a,void 0,void 0,n):kt(v,t,n,a,e)}else u=kt(e,t,n,a);return i(u)?u:o(u)?(o(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var i=0,c=e.children.length;i<c;i++){var l=e.children[i];o(l.tag)&&(r(l.ns)||s(a)&&"svg"!==l.tag)&&n(l,t,a)}}(u,p),o(t)&&function(n){d(n.style)&&Fe(n.style);d(n.class)&&Fe(n.class)}(t),u):mn()}(n,e,t,a,u)}function Ee(n,e,t){An();try{if(e)for(var a=e;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var r=0;r<i.length;r++)try{if(!1===i[r].call(a,n,e,t))return}catch(n){Ce(n,a,"errorCaptured hook")}}Ce(n,e,t)}finally{xn()}}function Ie(n,e,t,a,i){var r;try{(r=t?n.apply(e,t):n.call(e))&&!r._isVue&&f(r)&&!r._handled&&(r.catch((function(n){return Ee(n,a,i+" (Promise/async)")})),r._handled=!0)}catch(n){Ee(n,a,i)}return r}function Ce(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Te(e,null,"config.errorHandler")}Te(n,e,t)}function Te(n,e,t){if(!G||"undefined"==typeof console)throw n;console.error(n)}var Be,Pe=!1,Re=[],je=!1;function Me(){je=!1;var n=Re.slice(0);Re.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Le=Promise.resolve();Be=function(){Le.then(Me),Q&&setTimeout(j)},Pe=!0}else if(Y||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Be="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Me)}:function(){setTimeout(Me,0)};else{var Oe=1,De=new MutationObserver(Me),Ne=document.createTextNode(String(Oe));De.observe(Ne,{characterData:!0}),Be=function(){Oe=(Oe+1)%2,Ne.data=String(Oe)},Pe=!0}function ze(n,e){var t;if(Re.push((function(){if(n)try{n.call(e)}catch(n){Ee(n,e,"nextTick")}else t&&t(e)})),je||(je=!0,Be()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ue(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=Et(a[e],t)}(t,n,e)}}Ue("beforeMount"),Ue("mounted"),Ue("beforeUpdate"),Ue("updated"),Ue("beforeDestroy"),Ue("destroyed"),Ue("activated"),Ue("deactivated"),Ue("serverPrefetch"),Ue("renderTracked"),Ue("renderTriggered"),Ue("errorCaptured");var $e=new ln;function Fe(n){return function n(e,t){var a,r,o=i(e);if(!o&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(zn(e))n(e.value,t);else for(r=Object.keys(e),a=r.length;a--;)n(e[r[a]],t)}(n,$e),$e.clear(),n}var He,qe=0,We=function(){function n(n,e,t,a,i){var r,o;r=this,void 0===(o=$n&&!$n._vm?$n:n?n._scope:void 0)&&(o=$n),o&&o.active&&o.effects.push(r),(this.vm=n)&&i&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++qe,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="",l(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=j)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;An(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ee(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Fe(n),xn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){He.$on(n,e)}function Je(n,e){He.$off(n,e)}function Ge(n,e){var t=He;return function a(){var i=e.apply(null,arguments);null!==i&&t.$off(n,a)}}function Ke(n,e,t){He=n,Vn(e,t||{},Ve,Je,Ge,n),He=void 0}var Ye=null;function Xe(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),An();var i=un;a&&pn(n);var r=n.$options[e],o="".concat(e," hook");if(r)for(var s=0,c=r.length;s<c;s++)Ie(r[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&pn(i),xn()}var et=[],tt=[],at={},it=!1,rt=!1,ot=0;var st=0,ct=Date.now;if(G&&!Y){var lt=window.performance;lt&&"function"==typeof lt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return lt.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=ct(),rt=!0,et.sort(dt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();ot=et.length=tt.length=0,at={},it=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&F.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,rt){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);it||(it=!0,ze(ut))}}function vt(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<a.length;i++){var r=a[i];if("__ob__"!==r){var o=n[r].from;if(o in e._provided)t[r]=e._provided[o];else if("default"in n[r]){var s=n[r].default;t[r]=l(s)?s.call(e):s}else 0}}return t}}function mt(n,e,t,r,o){var c,l=this,d=o.options;x(r,"_uid")?(c=Object.create(r))._original=r:(c=r,r=r._original);var u=s(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=vt(d.inject,r),this.slots=function(){return l.$slots||fe(r,n.scopedSlots,l.$slots=pe(t,r)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(r,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=fe(r,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,a){var o=Se(c,n,e,t,a,p);return o&&!i(o)&&(o.fnScopeId=d._scopeId,o.fnContext=r),o}:this._c=function(n,e,t,a){return Se(c,n,e,t,a,p)}}function ft(n,e,t,a,i){var r=hn(n);return r.fnContext=t,r.fnOptions=a,e.slot&&((r.data||(r.data={})).slot=e.slot),r}function ht(n,e){for(var t in e)n[S(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}ue(mt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,r){var o=i.data.scopedSlots,s=n.$scopedSlots,c=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),l=!!(r||n.$options._renderChildren||c),d=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=r;var u=i.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,u,d.data&&d.data.attrs||a,n,"$attrs")&&(l=!0),n.$attrs=u,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){Cn(!1);for(var v=n._props,m=n.$options._propKeys||[],f=0;f<m.length;f++){var h=m[f],g=n.$options.props;v[h]=Pt(h,g,e,n)}Cn(!0),n.$options.propsData=e}l&&(n.$slots=pe(r,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Qe(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function kt(n,e,t,c,l){if(!r(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(r(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=xe;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],i=!0,c=null,l=null;t.$on("hook:destroyed",(function(){return k(a,t)}));var u=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},p=N((function(t){n.resolved=_e(t,e),i?a.length=0:u(!0)})),v=N((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),m=n(p,v);return d(m)&&(f(m)?r(n.resolved)&&m.then(p,v):f(m.component)&&(m.component.then(p,v),o(m.error)&&(n.errorComp=_e(m.error,e)),o(m.loading)&&(n.loadingComp=_e(m.loading,e),0===m.delay?n.loading=!0:c=setTimeout((function(){c=null,r(n.resolved)&&r(n.error)&&(n.loading=!0,u(!1))}),m.delay||200)),o(m.timeout)&&(l=setTimeout((function(){l=null,r(n.resolved)&&v(null)}),m.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,a,i){var r=mn();return r.asyncFactory=n,r.asyncMeta={data:e,context:t,children:a,tag:i},r}(p,e,t,c,l);e=e||{},Wt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),s=r[a],c=e.model.callback;o(s)?(i(s)?-1===s.indexOf(c):s!==c)&&(r[a]=[c].concat(s)):r[a]=c}(n.options,e);var v=function(n,e,t){var a=e.options.props;if(!r(a)){var i={},s=n.attrs,c=n.props;if(o(s)||o(c))for(var l in a){var d=C(l);Gn(i,c,l,d,!0)||Gn(i,s,l,d,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,r,s){var c=n.options,l={},d=c.props;if(o(d))for(var u in d)l[u]=Pt(u,d,e||a);else o(t.attrs)&&ht(l,t.attrs),o(t.props)&&ht(l,t.props);var p=new mt(t,l,s,r,n),v=c.render.call(null,p._c,p);if(v instanceof vn)return ft(v,t,p.parent,c,p);if(i(v)){for(var m=Kn(v)||[],f=new Array(m.length),h=0;h<m.length;h++)f[h]=ft(m[h],t,p.parent,c,p);return f}}(n,v,e,t,c);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],i=e[a],r=bt[a];i===r||i&&i._merged||(e[a]=i?At(r,i):r)}}(e);var g=gt(n.options)||l;return new vn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:v,listeners:m,tag:l,children:c},p)}}}function At(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var xt=j,_t=F.optionMergeStrategies;function wt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,i,r,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(a=o[s])&&(i=n[a],r=e[a],t&&x(n,a)?i!==r&&p(i)&&p(r)&&wt(i,r):jn(n,a,r));return n}function St(n,e,t){return t?function(){var a=l(e)?e.call(t,t):e,i=l(n)?n.call(t,t):n;return a?wt(a,i):i}:e?n?function(){return wt(l(e)?e.call(this,this):e,l(n)?n.call(this,this):n)}:e:n}function Et(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,a){var i=Object.create(n||null);return e?P(i,e):i}_t.data=function(n,e,t){return t?St(n,e,t):e&&"function"!=typeof e?n:St(n,e)},$.forEach((function(n){_t[n]=Et})),U.forEach((function(n){_t[n+"s"]=It})),_t.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var o in P(r,n),e){var s=r[o],c=e[o];s&&!i(s)&&(s=[s]),r[o]=s?s.concat(c):i(c)?c:[c]}return r},_t.props=_t.methods=_t.inject=_t.computed=function(n,e,t,a){if(!n)return e;var i=Object.create(null);return P(i,n),e&&P(i,e),i},_t.provide=function(n,e){return n?function(){var t=Object.create(null);return wt(t,l(n)?n.call(this):n),e&&wt(t,l(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function Tt(n,e,t){if(l(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,r,o={};if(i(t))for(a=t.length;a--;)"string"==typeof(r=t[a])&&(o[S(r)]={type:null});else if(p(t))for(var s in t)r=t[s],o[S(s)]=p(r)?r:{type:r};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(i(t))for(var r=0;r<t.length;r++)a[t[r]]={from:t[r]};else if(p(t))for(var o in t){var s=t[o];a[o]=p(s)?P({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];l(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Tt(n,e.extends,t)),e.mixins))for(var a=0,r=e.mixins.length;a<r;a++)n=Tt(n,e.mixins[a],t);var o,s={};for(o in n)c(o);for(o in e)x(n,o)||c(o);function c(a){var i=_t[a]||Ct;s[a]=i(n[a],e[a],t,a)}return s}function Bt(n,e,t,a){if("string"==typeof t){var i=n[e];if(x(i,t))return i[t];var r=S(t);if(x(i,r))return i[r];var o=E(r);return x(i,o)?i[o]:i[t]||i[r]||i[o]}}function Pt(n,e,t,a){var i=e[n],r=!x(t,n),o=t[n],s=Lt(Boolean,i.type);if(s>-1)if(r&&!x(i,"default"))o=!1;else if(""===o||o===C(n)){var c=Lt(String,i.type);(c<0||s<c)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!x(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return l(a)&&"Function"!==jt(e.type)?a.call(n):a}(a,i,n);var d=In;Cn(!0),Pn(o),Cn(d)}return o}var Rt=/^\s*function (\w+)/;function jt(n){var e=n&&n.toString().match(Rt);return e?e[1]:""}function Mt(n,e){return jt(n)===jt(e)}function Lt(n,e){if(!i(e))return Mt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Mt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:j,set:j};function Dt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Nt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=On({}),i=n.$options._propKeys=[];n.$parent&&Cn(!1);var r=function(r){i.push(r);var o=Pt(r,e,t,n);Rn(a,r,o),r in n||Dt(n,"_props",r)};for(var o in e)r(o);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=be(n);pn(n),An();var i=Ie(t,null,[n._props||On({}),a],n,"setup");if(xn(),pn(),l(i))e.render=i;else if(d(i))if(n._setupState=i,i.__sfc){var r=n._setupProxy={};for(var o in i)"__sfc"!==o&&Un(r,i,o)}else for(var o in i)q(o)||Un(n,i,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?j:T(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=l(e)?function(n,e){An();try{return n.call(e,e)}catch(n){return Ee(n,e,"data()"),{}}finally{xn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var r=t[i];0,a&&x(a,r)||q(r)||Dt(n,"_data",r)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var i in e){var r=e[i],o=l(r)?r:r.get;0,a||(t[i]=new We(n,o||j,j,zt)),i in n||Ut(n,i,r)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(i(a))for(var r=0;r<a.length;r++)Ht(n,t,a[r]);else Ht(n,t,a)}}(n,e.watch)}var zt={lazy:!0};function Ut(n,e,t){var a=!on();l(t)?(Ot.get=a?$t(e):Ft(t),Ot.set=j):(Ot.get=t.get?a&&!1!==t.cache?$t(e):Ft(t.get):j,Ot.set=t.set||j),Object.defineProperty(n,e,Ot)}function $t(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ft(n){return function(){return n.call(this,this)}}function Ht(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var qt=0;function Wt(n){var e=n.options;if(n.super){var t=Wt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var i in t)t[i]!==a[i]&&(e||(e={}),e[i]=t[i]);return e}(n);a&&P(n.extendOptions,a),(e=n.options=Tt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,i=n._Ctor||(n._Ctor={});if(i[a])return i[a];var r=gt(n)||gt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Tt(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Dt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ut(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,U.forEach((function(n){o[n]=t[n]})),r&&(o.options.components[r]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=P({},o.options),i[a]=o,o}}function Gt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Kt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!v(n)&&n.test(e)}function Yt(n,e){var t=n.cache,a=n.keys,i=n._vnode;for(var r in t){var o=t[r];if(o){var s=o.name;s&&!e(s)&&Xt(t,r,a,i)}}}function Xt(n,e,t,a){var i=n[e];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),n[e]=null,k(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=qt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Fn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var i=a.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Tt(Wt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=pe(e._renderChildren,i),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,i){return Se(n,e,t,a,i,!1)},n.$createElement=function(e,t,a,i){return Se(n,e,t,a,i,!0)};var r=t&&t.data;Rn(n,"$attrs",r&&r.attrs||a,null,!0),Rn(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=vt(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){Rn(n,t,e[t])})),Cn(!0))}(e),Nt(e),function(n){var e=n.$options.provide;if(e){var t=l(e)?e.call(n):e;if(!d(t))return;for(var a=Hn(n),i=dn?Reflect.ownKeys(t):Object.keys(t),r=0;r<i.length;r++){var o=i[r];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=jn,n.prototype.$delete=Mn,n.prototype.$watch=function(n,e,t){if(p(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var a=new We(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(a.expression,'"');An(),Ie(e,this,[a.value],this,i),xn()}return function(){a.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(i(n))for(var r=0,o=n.length;r<o;r++)a.$on(n[r],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var a=0,r=n.length;a<r;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var c=s.length;c--;)if((o=s[c])===e||o.fn===e){s.splice(c,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?B(t):t;for(var a=B(arguments,1),i='event handler for "'.concat(n,'"'),r=0,o=t.length;r<o;r++)Ie(t[r],e,a,e,i)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,i=t._vnode,r=Xe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),r(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return ze(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,r=t._parentVnode;r&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,r.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Ae(e._slotsProxy,e.$scopedSlots)),e.$vnode=r;try{pn(e),xe=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Ee(t,e,"render"),n=e._vnode}finally{xe=null,pn()}return i(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=mn()),n.parent=r,n}}(Vt);var Zt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var i=t.tag,r=t.componentInstance,o=t.componentOptions;n[a]={name:Gt(o),tag:i,componentInstance:r},e.push(a),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=we(n),t=e&&e.componentOptions;if(t){var a=Gt(t),i=this.include,r=this.exclude;if(i&&(!a||!Kt(i,a))||r&&a&&Kt(r,a))return e;var o=this.cache,s=this.keys,c=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[c]?(e.componentInstance=o[c].componentInstance,k(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:xt,extend:P,mergeOptions:Tt,defineReactive:Rn},n.set=jn,n.delete=Mn,n.nextTick=ze,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=B(arguments,1);return t.unshift(this),l(n.install)?n.install.apply(n,t):l(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Tt(this.options,n),this}}(n),Jt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&l(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:mt}),Vt.version="2.7.14";var na=b("style,class"),ea=b("input,textarea,option,select,progress"),ta=b("contenteditable,draggable,spellcheck"),aa=b("events,caret,typing,plaintext-only"),ia=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ra="http://www.w3.org/1999/xlink",oa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sa=function(n){return oa(n)?n.slice(6,n.length):""},ca=function(n){return null==n||!1===n};function la(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=da(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=da(e,t.data));return function(n,e){if(o(n)||o(e))return ua(n,pa(e));return""}(e.staticClass,e.class)}function da(n,e){return{staticClass:ua(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ua(n,e){return n?e?n+" "+e:n:e||""}function pa(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,i=n.length;a<i;a++)o(e=pa(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var va={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ma=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fa=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ha=function(n){return ma(n)||fa(n)};var ga=Object.create(null);var ba=b("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(va[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),ka={create:function(n,e){Aa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Aa(n,!0),Aa(e))},destroy:function(n){Aa(n,!0)}};function Aa(n,e){var t=n.data.ref;if(o(t)){var a=n.context,r=n.componentInstance||n.elm,s=e?null:r,c=e?void 0:r;if(l(t))Ie(t,a,[s],a,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=zn(t),v=a.$refs;if(u||p)if(d){var m=u?v[t]:t.value;e?i(m)&&k(m,r):i(m)?m.includes(r)||m.push(r):u?(v[t]=[r],xa(a,t,v[t])):t.value=[r]}else if(u){if(e&&v[t]!==r)return;v[t]=c,xa(a,t,s)}else if(p){if(e&&t.value!==r)return;t.value=s}else 0}}}function xa(n,e,t){var a=n._setupState;a&&x(a,e)&&(zn(a[e])?a[e].value=t:a[e]=t)}var _a=new vn("",{},[]),wa=["create","activate","update","remove","destroy"];function Sa(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===i||ba(a)&&ba(i)}(n,e)||s(n.isAsyncPlaceholder)&&r(e.asyncFactory.error))}function Ea(n,e,t){var a,i,r={};for(a=e;a<=t;++a)o(i=n[a].key)&&(r[i]=a);return r}var Ia={create:Ca,update:Ca,destroy:function(n){Ca(n,_a)}};function Ca(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,i,r=n===_a,o=e===_a,s=Ba(n.data.directives,n.context),c=Ba(e.data.directives,e.context),l=[],d=[];for(t in c)a=s[t],i=c[t],a?(i.oldValue=a.value,i.oldArg=a.arg,Ra(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(Ra(i,"bind",e,n),i.def&&i.def.inserted&&l.push(i));if(l.length){var u=function(){for(var t=0;t<l.length;t++)Ra(l[t],"inserted",e,n)};r?Jn(e,"insert",u):u()}d.length&&Jn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Ra(d[t],"componentUpdated",e,n)}));if(!r)for(t in s)c[t]||Ra(s[t],"unbind",n,n,o)}(n,e)}var Ta=Object.create(null);function Ba(n,e){var t,a,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Ta),i[Pa(a)]=a,e._setupState&&e._setupState.__sfc){var r=a.def||Bt(e,"_setupState","v-"+a.name);a.def="function"==typeof r?{bind:r,update:r}:r}a.def=a.def||Bt(e.$options,"directives",a.name)}return i}function Pa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ra(n,e,t,a,i){var r=n.def&&n.def[e];if(r)try{r(t.elm,n,t,a,i)}catch(a){Ee(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var ja=[ka,Ia];function Ma(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||r(n.data.attrs)&&r(e.data.attrs))){var a,i,c=e.elm,l=n.data.attrs||{},d=e.data.attrs||{};for(a in(o(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)i=d[a],l[a]!==i&&La(c,a,i,e.data.pre);for(a in(Y||Z)&&d.value!==l.value&&La(c,"value",d.value),l)r(d[a])&&(oa(a)?c.removeAttributeNS(ra,sa(a)):ta(a)||c.removeAttribute(a))}}function La(n,e,t,a){a||n.tagName.indexOf("-")>-1?Oa(n,e,t):ia(e)?ca(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return ca(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):oa(e)?ca(t)?n.removeAttributeNS(ra,sa(e)):n.setAttributeNS(ra,e,t):Oa(n,e,t)}function Oa(n,e,t){if(ca(t))n.removeAttribute(e);else{if(Y&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Da={create:Ma,update:Ma};function Na(n,e){var t=e.elm,a=e.data,i=n.data;if(!(r(a.staticClass)&&r(a.class)&&(r(i)||r(i.staticClass)&&r(i.class)))){var s=la(e),c=t._transitionClasses;o(c)&&(s=ua(s,pa(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var za,Ua={create:Na,update:Na};function $a(n,e,t){var a=za;return function i(){var r=e.apply(null,arguments);null!==r&&qa(n,i,t,a)}}var Fa=Pe&&!(en&&Number(en[1])<=53);function Ha(n,e,t,a){if(Fa){var i=st,r=e;e=r._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return r.apply(this,arguments)}}za.addEventListener(n,e,an?{capture:t,passive:a}:t)}function qa(n,e,t,a){(a||za).removeEventListener(n,e._wrapper||e,t)}function Wa(n,e){if(!r(n.data.on)||!r(e.data.on)){var t=e.data.on||{},a=n.data.on||{};za=e.elm||n.elm,function(n){if(o(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,a,Ha,qa,$a,e.context),za=void 0}}var Va,Ja={create:Wa,update:Wa,destroy:function(n){return Wa(n,_a)}};function Ga(n,e){if(!r(n.data.domProps)||!r(e.data.domProps)){var t,a,i=e.elm,c=n.data.domProps||{},l=e.data.domProps||{};for(t in(o(l.__ob__)||s(l._v_attr_proxy))&&(l=e.data.domProps=P({},l)),c)t in l||(i[t]="");for(t in l){if(a=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===c[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=a;var d=r(a)?"":String(a);Ka(i,d)&&(i.value=d)}else if("innerHTML"===t&&fa(i.tagName)&&r(i.innerHTML)){(Va=Va||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=Va.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(a!==c[t])try{i[t]=a}catch(n){}}}}function Ka(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return g(t)!==g(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ya={create:Ga,update:Ga},Xa=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Za(n){var e=Qa(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Qa(n){return Array.isArray(n)?R(n):"string"==typeof n?Xa(n):n}var ni,ei=/^--/,ti=/\s*!important$/,ai=function(n,e,t){if(ei.test(e))n.style.setProperty(e,t);else if(ti.test(t))n.style.setProperty(C(e),t.replace(ti,""),"important");else{var a=ri(e);if(Array.isArray(t))for(var i=0,r=t.length;i<r;i++)n.style[a]=t[i];else n.style[a]=t}},ii=["Webkit","Moz","ms"],ri=_((function(n){if(ni=ni||document.createElement("div").style,"filter"!==(n=S(n))&&n in ni)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ii.length;t++){var a=ii[t]+e;if(a in ni)return a}}));function oi(n,e){var t=e.data,a=n.data;if(!(r(t.staticStyle)&&r(t.style)&&r(a.staticStyle)&&r(a.style))){var i,s,c=e.elm,l=a.staticStyle,d=a.normalizedStyle||a.style||{},u=l||d,p=Qa(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?P({},p):p;var v=function(n,e){var t,a={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Za(i.data))&&P(a,t);(t=Za(n.data))&&P(a,t);for(var r=n;r=r.parent;)r.data&&(t=Za(r.data))&&P(a,t);return a}(e,!0);for(s in u)r(v[s])&&ai(c,s,"");for(s in v)(i=v[s])!==u[s]&&ai(c,s,null==i?"":i)}}var si={create:oi,update:oi},ci=/\s+/;function li(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ui(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,pi(n.name||"v")),P(e,n),e}return"string"==typeof n?pi(n):void 0}}var pi=_((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),vi=G&&!X,mi="transition",fi="transitionend",hi="animation",gi="animationend";vi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mi="WebkitTransition",fi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(hi="WebkitAnimation",gi="webkitAnimationEnd"));var bi=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yi(n){bi((function(){bi(n)}))}function ki(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),li(n,e))}function Ai(n,e){n._transitionClasses&&k(n._transitionClasses,e),di(n,e)}function xi(n,e,t){var a=wi(n,e),i=a.type,r=a.timeout,o=a.propCount;if(!i)return t();var s="transition"===i?fi:gi,c=0,l=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++c>=o&&l()};setTimeout((function(){c<o&&l()}),r+1),n.addEventListener(s,d)}var _i=/\b(transform|all)(,|$)/;function wi(n,e){var t,a=window.getComputedStyle(n),i=(a[mi+"Delay"]||"").split(", "),r=(a[mi+"Duration"]||"").split(", "),o=Si(i,r),s=(a[hi+"Delay"]||"").split(", "),c=(a[hi+"Duration"]||"").split(", "),l=Si(s,c),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=r.length):"animation"===e?l>0&&(t="animation",d=l,u=c.length):u=(t=(d=Math.max(o,l))>0?o>l?"transition":"animation":null)?"transition"===t?r.length:c.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&_i.test(a[mi+"Property"])}}function Si(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ei(e)+Ei(n[t])})))}function Ei(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ii(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=ui(n.data.transition);if(!r(a)&&!o(t._enterCb)&&1===t.nodeType){for(var i=a.css,s=a.type,c=a.enterClass,u=a.enterToClass,p=a.enterActiveClass,v=a.appearClass,m=a.appearToClass,f=a.appearActiveClass,h=a.beforeEnter,b=a.enter,y=a.afterEnter,k=a.enterCancelled,A=a.beforeAppear,x=a.appear,_=a.afterAppear,w=a.appearCancelled,S=a.duration,E=Ye,I=Ye.$vnode;I&&I.parent;)E=I.context,I=I.parent;var C=!E._isMounted||!n.isRootInsert;if(!C||x||""===x){var T=C&&v?v:c,B=C&&f?f:p,P=C&&m?m:u,R=C&&A||h,j=C&&l(x)?x:b,M=C&&_||y,L=C&&w||k,O=g(d(S)?S.enter:S);0;var D=!1!==i&&!X,z=Bi(j),U=t._enterCb=N((function(){D&&(Ai(t,P),Ai(t,B)),U.cancelled?(D&&Ai(t,T),L&&L(t)):M&&M(t),t._enterCb=null}));n.data.show||Jn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),j&&j(t,U)})),R&&R(t),D&&(ki(t,T),ki(t,B),yi((function(){Ai(t,T),U.cancelled||(ki(t,P),z||(Ti(O)?setTimeout(U,O):xi(t,s,U)))}))),n.data.show&&(e&&e(),j&&j(t,U)),D||z||U()}}}function Ci(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=ui(n.data.transition);if(r(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=a.css,s=a.type,c=a.leaveClass,l=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,v=a.leave,m=a.afterLeave,f=a.leaveCancelled,h=a.delayLeave,b=a.duration,y=!1!==i&&!X,k=Bi(v),A=g(d(b)?b.leave:b);0;var x=t._leaveCb=N((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Ai(t,l),Ai(t,u)),x.cancelled?(y&&Ai(t,c),f&&f(t)):(e(),m&&m(t)),t._leaveCb=null}));h?h(_):_()}function _(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(ki(t,c),ki(t,u),yi((function(){Ai(t,c),x.cancelled||(ki(t,l),k||(Ti(A)?setTimeout(x,A):xi(t,s,x)))}))),v&&v(t,x),y||k||x())}}function Ti(n){return"number"==typeof n&&!isNaN(n)}function Bi(n){if(r(n))return!1;var e=n.fns;return o(e)?Bi(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pi(n,e){!0!==e.data.show&&Ii(e)}var Ri=function(n){var e,t,a={},l=n.modules,d=n.nodeOps;for(e=0;e<wa.length;++e)for(a[wa[e]]=[],t=0;t<l.length;++t)o(l[t][wa[e]])&&a[wa[e]].push(l[t][wa[e]]);function u(n){var e=d.parentNode(n);o(e)&&d.removeChild(e,n)}function p(n,e,t,i,r,c,l){if(o(n.elm)&&o(c)&&(n=c[l]=hn(n)),n.isRootInsert=!r,!function(n,e,t,i){var r=n.data;if(o(r)){var c=o(n.componentInstance)&&r.keepAlive;if(o(r=r.hook)&&o(r=r.init)&&r(n,!1),o(n.componentInstance))return v(n,e),m(t,n.elm,i),s(c)&&function(n,e,t,i){var r,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(r=s.data)&&o(r=r.transition)){for(r=0;r<a.activate.length;++r)a.activate[r](_a,s);e.push(s);break}m(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,p=n.children,h=n.tag;o(h)?(n.elm=n.ns?d.createElementNS(n.ns,h):d.createElement(h,n),y(n),f(n,p,e),o(u)&&g(n,e),m(t,n.elm,i)):s(n.isComment)?(n.elm=d.createComment(n.text),m(t,n.elm,i)):(n.elm=d.createTextNode(n.text),m(t,n.elm,i))}}function v(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,h(n)?(g(n,e),y(n)):(Aa(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(i(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else c(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function h(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function g(n,t){for(var i=0;i<a.create.length;++i)a.create[i](_a,n);o(e=n.data.hook)&&(o(e.create)&&e.create(_a,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;o(e=Ye)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function k(n,e,t,a,i,r){for(;a<=i;++a)p(t[a],r,n,e,!1,t,a)}function A(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)A(n.children[t])}function x(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(_(a),A(a)):u(a.elm))}}function _(n,e){if(o(e)||o(n.data)){var t,i=a.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&_(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function w(n,e,t,a){for(var i=t;i<a;i++){var r=e[i];if(o(r)&&Sa(n,r))return i}}function S(n,e,t,i,c,l){if(n!==e){o(e.elm)&&o(i)&&(e=i[c]=hn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var v,m=e.data;o(m)&&o(v=m.hook)&&o(v=v.prepatch)&&v(n,e);var f=n.children,g=e.children;if(o(m)&&h(e)){for(v=0;v<a.update.length;++v)a.update[v](n,e);o(v=m.hook)&&o(v=v.update)&&v(n,e)}r(e.text)?o(f)&&o(g)?f!==g&&function(n,e,t,a,i){var s,c,l,u=0,v=0,m=e.length-1,f=e[0],h=e[m],g=t.length-1,b=t[0],y=t[g],A=!i;for(0;u<=m&&v<=g;)r(f)?f=e[++u]:r(h)?h=e[--m]:Sa(f,b)?(S(f,b,a,t,v),f=e[++u],b=t[++v]):Sa(h,y)?(S(h,y,a,t,g),h=e[--m],y=t[--g]):Sa(f,y)?(S(f,y,a,t,g),A&&d.insertBefore(n,f.elm,d.nextSibling(h.elm)),f=e[++u],y=t[--g]):Sa(h,b)?(S(h,b,a,t,v),A&&d.insertBefore(n,h.elm,f.elm),h=e[--m],b=t[++v]):(r(s)&&(s=Ea(e,u,m)),r(c=o(b.key)?s[b.key]:w(b,e,u,m))?p(b,a,n,f.elm,!1,t,v):Sa(l=e[c],b)?(S(l,b,a,t,v),e[c]=void 0,A&&d.insertBefore(n,l.elm,f.elm)):p(b,a,n,f.elm,!1,t,v),b=t[++v]);u>m?k(n,r(t[g+1])?null:t[g+1].elm,t,v,g,a):v>g&&x(e,u,m)}(u,f,g,t,l):o(g)?(o(n.text)&&d.setTextContent(u,""),k(u,null,g,0,g.length-1,t)):o(f)?x(f,0,f.length-1):o(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),o(m)&&o(v=m.hook)&&o(v=v.postpatch)&&v(n,e)}}}function E(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var I=b("attrs,class,staticClass,staticStyle,key");function C(n,e,t,a){var i,r=e.tag,c=e.data,l=e.children;if(a=a||c&&c.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(c)&&(o(i=c.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return v(e,t),!0;if(o(r)){if(o(l))if(n.hasChildNodes())if(o(i=c)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<l.length;p++){if(!u||!C(u,l[p],t,a)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,l,t);if(o(c)){var m=!1;for(var h in c)if(!I(h)){m=!0,g(e,t);break}!m&&c.class&&Fe(c.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!r(e)){var c,l=!1,u=[];if(r(n))l=!0,p(e,u);else{var v=o(n.nodeType);if(!v&&Sa(n,e))S(n,e,u,null,null,i);else{if(v){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,u))return E(e,u,!0),n;c=n,n=new vn(d.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,f=d.parentNode(m);if(p(e,u,m._leaveCb?null:f,d.nextSibling(m)),o(e.parent))for(var g=e.parent,b=h(e);g;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](g);if(g.elm=e.elm,b){for(var k=0;k<a.create.length;++k)a.create[k](_a,g);var _=g.data.hook.insert;if(_.merged)for(var w=1;w<_.fns.length;w++)_.fns[w]()}else Aa(g);g=g.parent}o(f)?x([n],0,0):o(n.tag)&&A(n)}}return E(e,u,l),e.elm}o(n)&&A(n)}}({nodeOps:ya,modules:[Da,Ua,Ja,Ya,si,G?{create:Pi,activate:Pi,remove:function(n,e){!0!==n.data.show?Ci(n,e):e()}}:{}].concat(ja)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ui(n,"input")}));var ji={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Jn(t,"postpatch",(function(){ji.componentUpdated(n,e,t)})):Mi(n,e,t.context),n._vOptions=[].map.call(n.options,Di)):("textarea"===t.tag||ba(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ni),n.addEventListener("compositionend",zi),n.addEventListener("change",zi),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Mi(n,e,t.context);var a=n._vOptions,i=n._vOptions=[].map.call(n.options,Di);if(i.some((function(n,e){return!O(n,a[e])})))(n.multiple?e.value.some((function(n){return Oi(n,i)})):e.value!==e.oldValue&&Oi(e.value,i))&&Ui(n,"change")}}};function Mi(n,e,t){Li(n,e,t),(Y||Z)&&setTimeout((function(){Li(n,e,t)}),0)}function Li(n,e,t){var a=e.value,i=n.multiple;if(!i||Array.isArray(a)){for(var r,o,s=0,c=n.options.length;s<c;s++)if(o=n.options[s],i)r=D(a,Di(o))>-1,o.selected!==r&&(o.selected=r);else if(O(Di(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function Oi(n,e){return e.every((function(e){return!O(e,n)}))}function Di(n){return"_value"in n?n._value:n.value}function Ni(n){n.target.composing=!0}function zi(n){n.target.composing&&(n.target.composing=!1,Ui(n.target,"input"))}function Ui(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function $i(n){return!n.componentInstance||n.data&&n.data.transition?n:$i(n.componentInstance._vnode)}var Fi={model:ji,show:{bind:function(n,e,t){var a=e.value,i=(t=$i(t)).data&&t.data.transition,r=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&i?(t.data.show=!0,Ii(t,(function(){n.style.display=r}))):n.style.display=a?r:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=$i(t)).data&&t.data.transition?(t.data.show=!0,a?Ii(t,(function(){n.style.display=n.__vOriginalDisplay})):Ci(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,i){i||(n.style.display=n.__vOriginalDisplay)}}},Hi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function qi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?qi(we(e.children)):n}function Wi(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var i=t._parentListeners;for(var a in i)e[S(a)]=i[a];return e}function Vi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ji=function(n){return n.tag||me(n)},Gi=function(n){return"show"===n.name},Ki={name:"transition",props:Hi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ji)).length){0;var a=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var r=qi(i);if(!r)return i;if(this._leaving)return Vi(n,i);var o="__transition-".concat(this._uid,"-");r.key=null==r.key?r.isComment?o+"comment":o+r.tag:c(r.key)?0===String(r.key).indexOf(o)?r.key:o+r.key:r.key;var s=(r.data||(r.data={})).transition=Wi(this),l=this._vnode,d=qi(l);if(r.data.directives&&r.data.directives.some(Gi)&&(r.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(r,d)&&!me(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=P({},s);if("out-in"===a)return this._leaving=!0,Jn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vi(n,i);if("in-out"===a){if(me(r))return l;var p,v=function(){p()};Jn(s,"afterEnter",v),Jn(s,"enterCancelled",v),Jn(u,"delayLeave",(function(n){p=n}))}}return i}}},Yi=P({tag:String,moveClass:String},Hi);function Xi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Zi(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qi(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,i=e.top-t.top;if(a||i){n.data.moved=!0;var r=n.elm.style;r.transform=r.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),r.transitionDuration="0s"}}delete Yi.mode;var nr={Transition:Ki,TransitionGroup:{props:Yi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var i=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],r=this.children=[],o=Wi(this),s=0;s<i.length;s++){if((d=i[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))r.push(d),t[d.key]=d,(d.data||(d.data={})).transition=o;else;}if(a){var c=[],l=[];for(s=0;s<a.length;s++){var d;(d=a[s]).data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?c.push(d):l.push(d)}this.kept=n(e,null,c),this.removed=l}return n(e,null,r)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xi),n.forEach(Zi),n.forEach(Qi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;ki(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(fi,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(fi,n),t._moveCb=null,Ai(t,e))})}})))},methods:{hasMove:function(n,e){if(!vi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){di(t,n)})),li(t,e),t.style.display="none",this.$el.appendChild(t);var a=wi(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function er(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=ha,Vt.config.isReservedAttr=na,Vt.config.getTagNamespace=function(n){return fa(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!G)return!0;if(ha(n))return!1;if(n=n.toLowerCase(),null!=ga[n])return ga[n];var e=document.createElement(n);return n.indexOf("-")>-1?ga[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ga[n]=/HTMLUnknownElement/.test(e.toString())},P(Vt.options.directives,Fi),P(Vt.options.components,nr),Vt.prototype.__patch__=G?Ri:j,Vt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=mn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new We(n,a,j,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var r=0;r<i.length;r++)i[r].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Vt)}),0);var tr=/[!'()*]/g,ar=function(n){return"%"+n.charCodeAt(0).toString(16)},ir=/%2C/g,rr=function(n){return encodeURIComponent(n).replace(tr,ar).replace(ir,",")};function or(n){try{return decodeURIComponent(n)}catch(n){0}return n}var sr=function(n){return null==n||"object"==typeof n?n:String(n)};function cr(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=or(t.shift()),i=t.length>0?or(t.join("=")):null;void 0===e[a]?e[a]=i:Array.isArray(e[a])?e[a].push(i):e[a]=[e[a],i]})),e):e}function lr(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return rr(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(rr(e)):a.push(rr(e)+"="+rr(n)))})),a.join("&")}return rr(e)+"="+rr(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var dr=/\/?$/;function ur(n,e,t,a){var i=a&&a.options.stringifyQuery,r=e.query||{};try{r=pr(r)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:r,params:e.params||{},fullPath:fr(e,i),matched:n?mr(n):[]};return t&&(o.redirectedFrom=fr(t,i)),Object.freeze(o)}function pr(n){if(Array.isArray(n))return n.map(pr);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pr(n[t]);return e}return n}var vr=ur(null,{path:"/"});function mr(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fr(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||lr)(a)+i}function hr(n,e,t){return e===vr?n===e:!!e&&(n.path&&e.path?n.path.replace(dr,"")===e.path.replace(dr,"")&&(t||n.hash===e.hash&&gr(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&gr(n.query,e.query)&&gr(n.params,e.params))))}function gr(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,i){var r=n[t];if(a[i]!==t)return!1;var o=e[t];return null==r||null==o?r===o:"object"==typeof r&&"object"==typeof o?gr(r,o):String(r)===String(o)}))}function br(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var i=t.instances[a],r=t.enteredCbs[a];if(i&&r){delete t.enteredCbs[a];for(var o=0;o<r.length;o++)i._isBeingDestroyed||r[o](i)}}}}var yr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,r=e.data;r.routerView=!0;for(var o=i.$createElement,s=t.name,c=i.$route,l=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&d++,p.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(r.routerViewDepth=d,u){var v=l[s],m=v&&v.component;return m?(v.configProps&&kr(m,r,v.route,v.configProps),o(m,r,a)):o()}var f=c.matched[d],h=f&&f.components[s];if(!f||!h)return l[s]=null,o();l[s]={component:h},r.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(r.hook||(r.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},r.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),br(c)};var g=f.props&&f.props[s];return g&&(er(l[s],{route:c,configProps:g}),kr(h,r,c,g)),o(h,r,a)}};function kr(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=er({},i);var r=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(r[o]=i[o],delete i[o])}}function Ar(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var r=n.replace(/^\//,"").split("/"),o=0;o<r.length;o++){var s=r[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function xr(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var _r=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},wr=Nr,Sr=Br,Er=function(n,e){return Rr(Br(n,e),e)},Ir=Rr,Cr=Dr,Tr=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Br(n,e){for(var t,a=[],i=0,r=0,o="",s=e&&e.delimiter||"/";null!=(t=Tr.exec(n));){var c=t[0],l=t[1],d=t.index;if(o+=n.slice(r,d),r=d+c.length,l)o+=l[1];else{var u=n[r],p=t[2],v=t[3],m=t[4],f=t[5],h=t[6],g=t[7];o&&(a.push(o),o="");var b=null!=p&&null!=u&&u!==p,y="+"===h||"*"===h,k="?"===h||"*"===h,A=t[2]||s,x=m||f;a.push({name:v||i++,prefix:p||"",delimiter:A,optional:k,repeat:y,partial:b,asterisk:!!g,pattern:x?Mr(x):g?".*":"[^"+jr(A)+"]+?"})}}return r<n.length&&(o+=n.substr(r)),o&&a.push(o),a}function Pr(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Rr(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Or(e)));return function(e,a){for(var i="",r=e||{},o=(a||{}).pretty?Pr:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,d=r[c.name];if(null==d){if(c.optional){c.partial&&(i+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(_r(d)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(l=o(d[u]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");i+=(0===u?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');i+=c.prefix+l}}else i+=c}return i}}function jr(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Mr(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Lr(n,e){return n.keys=e,n}function Or(n){return n&&n.sensitive?"":"i"}function Dr(n,e,t){_r(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,i=!1!==t.end,r="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)r+=jr(s);else{var c=jr(s.prefix),l="(?:"+s.pattern+")";e.push(s),s.repeat&&(l+="(?:"+c+l+")*"),r+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var d=jr(t.delimiter||"/"),u=r.slice(-d.length)===d;return a||(r=(u?r.slice(0,-d.length):r)+"(?:"+d+"(?=$))?"),r+=i?"$":a&&u?"":"(?="+d+"|$)",Lr(new RegExp("^"+r,Or(t)),e)}function Nr(n,e,t){return _r(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Lr(n,e)}(n,e):_r(n)?function(n,e,t){for(var a=[],i=0;i<n.length;i++)a.push(Nr(n[i],e,t).source);return Lr(new RegExp("(?:"+a.join("|")+")",Or(t)),e)}(n,e,t):function(n,e,t){return Dr(Br(n,t),e,t)}(n,e,t)}wr.parse=Sr,wr.compile=Er,wr.tokensToFunction=Ir,wr.tokensToRegExp=Cr;var zr=Object.create(null);function Ur(n,e,t){e=e||{};try{var a=zr[n]||(zr[n]=wr.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function $r(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var r=(i=er({},n)).params;return r&&"object"==typeof r&&(i.params=er({},r)),i}if(!i.path&&i.params&&e){(i=er({},i))._normalized=!0;var o=er(er({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=Ur(s,o,e.path)}else 0;return i}var c=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),l=e&&e.path||"/",d=c.path?Ar(c.path,l,t||i.append):l,u=function(n,e,t){void 0===e&&(e={});var a,i=t||cr;try{a=i(n||"")}catch(n){a={}}for(var r in e){var o=e[r];a[r]=Array.isArray(o)?o.map(sr):sr(o)}return a}(c.query,i.query,a&&a.options.parseQuery),p=i.hash||c.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Fr,Hr=function(){},qr={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),r=i.location,o=i.route,s=i.href,c={},l=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==l?"router-link-active":l,p=null==d?"router-link-exact-active":d,v=null==this.activeClass?u:this.activeClass,m=null==this.exactActiveClass?p:this.exactActiveClass,f=o.redirectedFrom?ur(null,$r(o.redirectedFrom),null,t):o;c[m]=hr(a,f,this.exactPath),c[v]=this.exact||this.exactPath?c[m]:function(n,e){return 0===n.path.replace(dr,"/").indexOf(e.path.replace(dr,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,f);var h=c[m]?this.ariaCurrentValue:null,g=function(n){Wr(n)&&(e.replace?t.replace(r,Hr):t.push(r,Hr))},b={click:Wr};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var y={class:c},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:g,isActive:c[v],isExactActive:c[m]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":h};else{var A=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(A){A.isStatic=!1;var x=A.data=er({},A.data);for(var _ in x.on=x.on||{},x.on){var w=x.on[_];_ in b&&(x.on[_]=Array.isArray(w)?w:[w])}for(var S in b)S in x.on?x.on[S].push(b[S]):x.on[S]=g;var E=A.data.attrs=er({},A.data.attrs);E.href=s,E["aria-current"]=h}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Wr(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Vr="undefined"!=typeof window;function Jr(n,e,t,a,i){var r=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,i,r,o){var s=i.path,c=i.name;0;var l=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return xr(e.path+"/"+n)}(s,r,l.strict);"boolean"==typeof i.caseSensitive&&(l.sensitive=i.caseSensitive);var u={path:d,regex:Gr(d,l),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:c,parent:r,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var r=o?xr(o+"/"+i.path):void 0;n(e,t,a,i,u,r)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],v=0;v<p.length;++v){0;var m={path:p[v],children:i.children};n(e,t,a,m,r,u.path||"/")}c&&(a[c]||(a[c]=u))}(r,o,s,n,i)}));for(var c=0,l=r.length;c<l;c++)"*"===r[c]&&(r.push(r.splice(c,1)[0]),l--,c--);return{pathList:r,pathMap:o,nameMap:s}}function Gr(n,e){return wr(n,[],e)}function Kr(n,e){var t=Jr(n),a=t.pathList,i=t.pathMap,r=t.nameMap;function o(n,t,o){var s=$r(n,t,!1,e),l=s.name;if(l){var d=r[l];if(!d)return c(null,s);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Ur(d.path,s.params),c(d,s,o)}if(s.path){s.params={};for(var v=0;v<a.length;v++){var m=a[v],f=i[m];if(Yr(f.regex,s.path,s.params))return c(f,s,o)}}return c(null,s)}function s(n,t){var a=n.redirect,i="function"==typeof a?a(ur(n,t,null,e)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return c(null,t);var s=i,l=s.name,d=s.path,u=t.query,p=t.hash,v=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,v=s.hasOwnProperty("params")?s.params:v,l){r[l];return o({_normalized:!0,name:l,query:u,hash:p,params:v},void 0,t)}if(d){var m=function(n,e){return Ar(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:Ur(m,v),query:u,hash:p},void 0,t)}return c(null,t)}function c(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Ur(t,e.params)});if(a){var i=a.matched,r=i[i.length-1];return e.params=a.params,c(r,e)}return c(null,e)}(0,t,n.matchAs):ur(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?r[n]:void 0;Jr([e||n],a,i,r,t),t&&t.alias.length&&Jr(t.alias.map((function(n){return{path:n,children:[e]}})),a,i,r,t)},getRoutes:function(){return a.map((function(n){return i[n]}))},addRoutes:function(n){Jr(n,a,i,r)}}}function Yr(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var i=1,r=a.length;i<r;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[i]?or(a[i]):a[i])}return!0}var Xr=Vr&&window.performance&&window.performance.now?window.performance:Date;function Zr(){return Xr.now().toFixed(3)}var Qr=Zr();function no(){return Qr}function eo(n){return Qr=n}var to=Object.create(null);function ao(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=er({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function io(n,e,t,a){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var r=function(){var n=no();if(n)return to[n]}(),o=i.call(n,e,t,a?r:null);o&&("function"==typeof o.then?o.then((function(n){po(n,r)})).catch((function(n){0})):po(o,r))}))}}function ro(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){ro(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return lo(n.x)||lo(n.y)}function co(n){return{x:lo(n.x)?n.x:window.pageXOffset,y:lo(n.y)?n.y:window.pageYOffset}}function lo(n){return"number"==typeof n}var uo=/^#\d/;function po(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var i=uo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var r=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(i,r={x:lo((t=r).x)?t.x:0,y:lo(t.y)?t.y:0})}else so(n)&&(e=co(n))}else a&&so(n)&&(e=co(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var vo,mo=Vr&&((-1===(vo=window.navigator.userAgent).indexOf("Android 2.")&&-1===vo.indexOf("Android 4.0")||-1===vo.indexOf("Mobile Safari")||-1!==vo.indexOf("Chrome")||-1!==vo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fo(n,e){ro();var t=window.history;try{if(e){var a=er({},t.state);a.key=no(),t.replaceState(a,"",n)}else t.pushState({key:eo(Zr())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ho(n){fo(n,!0)}var go={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return ko(n,e,go.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Ao.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return ko(n,e,go.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ko(n,e,t,a){var i=new Error(a);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var Ao=["params","query","hash"];function xo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function _o(n,e){return xo(n)&&n._isRouter&&(null==e||n.type===e)}function wo(n,e,t){var a=function(i){i>=n.length?t():n[i]?e(n[i],(function(){a(i+1)})):a(i+1)};a(0)}function So(n){return function(e,t,a){var i=!1,r=0,o=null;Eo(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,r++;var c,l=To((function(e){var i;((i=e).__esModule||Co&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Fr.extend(e),t.components[s]=e,--r<=0&&a()})),d=To((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=xo(n)?n:new Error(e),a(o))}));try{c=n(l,d)}catch(n){d(n)}if(c)if("function"==typeof c.then)c.then(l,d);else{var u=c.component;u&&"function"==typeof u.then&&u.then(l,d)}}})),i||a()}}function Eo(n,e){return Io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Io(n){return Array.prototype.concat.apply([],n)}var Co="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function To(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Bo=function(n,e){this.router=n,this.base=function(n){if(!n)if(Vr){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=vr,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Po(n,e,t,a){var i=Eo(n,(function(n,a,i,r){var o=function(n,e){"function"!=typeof n&&(n=Fr.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,i,r)})):t(o,a,i,r)}));return Io(a?i.reverse():i)}function Ro(n,e){if(e)return function(){return n.apply(e,arguments)}}Bo.prototype.listen=function(n){this.cb=n},Bo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Bo.prototype.onError=function(n){this.errorCbs.push(n)},Bo.prototype.transitionTo=function(n,e,t){var a,i=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var r=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),e&&e(a),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(a,r)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!i.ready&&(_o(n,go.redirected)&&r===vr||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},Bo.prototype.confirmTransition=function(n,e,t){var a=this,i=this.current;this.pending=n;var r,o,s=function(n){!_o(n)&&xo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,l=i.matched.length-1;if(hr(n,i)&&c===l&&n.matched[c]===i.matched[l])return this.ensureURL(),n.hash&&io(this.router,i,n,!1),s(((o=ko(r=i,n,go.duplicated,'Avoided redundant navigation to current location: "'+r.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,v=d.activated,m=[].concat(function(n){return Po(n,"beforeRouteLeave",Ro,!0)}(p),this.router.beforeHooks,function(n){return Po(n,"beforeRouteUpdate",Ro)}(u),v.map((function(n){return n.beforeEnter})),So(v)),f=function(e,t){if(a.pending!==n)return s(yo(i,n));try{e(n,i,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return ko(n,e,go.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):xo(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bo(i,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};wo(m,f,(function(){wo(function(n){return Po(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,i,r){return n(a,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),r(n)}))}}(n,t,a)}))}(v).concat(a.router.resolveHooks),f,(function(){if(a.pending!==n)return s(yo(i,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){br(n)}))}))}))},Bo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Bo.prototype.setupListeners=function(){},Bo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=vr,this.pending=null};var jo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Mo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=mo&&t;a&&this.listeners.push(ao());var i=function(){var t=n.current,i=Mo(n.base);n.current===vr&&i===n._startLocation||n.transitionTo(i,(function(n){a&&io(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){fo(xr(a.base+n.fullPath)),io(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){ho(xr(a.base+n.fullPath)),io(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Mo(this.base)!==this.current.fullPath){var e=xr(this.base+this.current.fullPath);n?fo(e):ho(e)}},e.prototype.getCurrentLocation=function(){return Mo(this.base)},e}(Bo);function Mo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(xr(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Lo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Mo(n);if(!/^\/#/.test(e))return window.location.replace(xr(n+"/#"+e)),!0}(this.base)||Oo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=mo&&e;t&&this.listeners.push(ao());var a=function(){var e=n.current;Oo()&&n.transitionTo(Do(),(function(a){t&&io(n.router,a,e,!0),mo||Uo(a.fullPath)}))},i=mo?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){zo(n.fullPath),io(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Uo(n.fullPath),io(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Do()!==e&&(n?zo(e):Uo(e))},e.prototype.getCurrentLocation=function(){return Do()},e}(Bo);function Oo(){var n=Do();return"/"===n.charAt(0)||(Uo("/"+n),!1)}function Do(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function No(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function zo(n){mo?fo(No(n)):window.location.hash=n}function Uo(n){mo?ho(No(n)):window.location.replace(No(n))}var $o=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){_o(n,go.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Bo),Fo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Kr(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!mo&&!1!==n.fallback,this.fallback&&(e="hash"),Vr||(e="abstract"),this.mode=e,e){case"history":this.history=new jo(this,n.base);break;case"hash":this.history=new Lo(this,n.base,this.fallback);break;case"abstract":this.history=new $o(this,n.base);break;default:0}},Ho={currentRoute:{configurable:!0}};Fo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ho.currentRoute.get=function(){return this.history&&this.history.current},Fo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof jo||t instanceof Lo){var a=function(n){t.setupListeners(),function(n){var a=t.current,i=e.options.scrollBehavior;mo&&i&&"fullPath"in n&&io(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fo.prototype.beforeEach=function(n){return Wo(this.beforeHooks,n)},Fo.prototype.beforeResolve=function(n){return Wo(this.resolveHooks,n)},Fo.prototype.afterEach=function(n){return Wo(this.afterHooks,n)},Fo.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fo.prototype.onError=function(n){this.history.onError(n)},Fo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Fo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fo.prototype.go=function(n){this.history.go(n)},Fo.prototype.back=function(){this.go(-1)},Fo.prototype.forward=function(){this.go(1)},Fo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fo.prototype.resolve=function(n,e,t){var a=$r(n,e=e||this.history.current,t,this),i=this.match(a,e),r=i.redirectedFrom||i.fullPath;return{location:a,route:i,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?xr(n+"/"+a):a}(this.history.base,r,this.mode),normalizedTo:a,resolved:i}},Fo.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==vr&&this.history.transitionTo(this.history.getCurrentLocation())},Fo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==vr&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fo.prototype,Ho);var qo=Fo;function Wo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fo.install=function n(e){if(!n.installed||Fr!==e){n.installed=!0,Fr=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yr),e.component("RouterLink",qr);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Fo.version="3.6.5",Fo.isNavigationFailure=_o,Fo.NavigationFailureType=go,Fo.START_LOCATION=vr,Vr&&window.Vue&&window.Vue.use(Fo);t(106);t(16),t(133);var Vo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,339)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,338))},Jo={"v-0b35ed3d":()=>t.e(5).then(t.bind(null,340)),"v-6acc0b14":()=>t.e(6).then(t.bind(null,341)),"v-49da62b4":()=>t.e(7).then(t.bind(null,342)),"v-0df4d5eb":()=>t.e(8).then(t.bind(null,343)),"v-0f201c8d":()=>t.e(9).then(t.bind(null,344)),"v-ce7afb70":()=>t.e(10).then(t.bind(null,345)),"v-5d44ccb7":()=>t.e(11).then(t.bind(null,346)),"v-187f426b":()=>t.e(12).then(t.bind(null,347)),"v-5d3712d8":()=>t.e(13).then(t.bind(null,348)),"v-44ce66a4":()=>t.e(14).then(t.bind(null,349)),"v-2754d04e":()=>t.e(15).then(t.bind(null,350)),"v-52d5efdf":()=>t.e(16).then(t.bind(null,351)),"v-a6a1ae9e":()=>t.e(17).then(t.bind(null,352)),"v-d0b19c14":()=>t.e(18).then(t.bind(null,353)),"v-09c5e121":()=>t.e(19).then(t.bind(null,354)),"v-3bbd0907":()=>t.e(20).then(t.bind(null,355)),"v-1d5b13d5":()=>t.e(21).then(t.bind(null,356)),"v-7568ef57":()=>t.e(22).then(t.bind(null,357)),"v-76f45877":()=>t.e(23).then(t.bind(null,358)),"v-72defc83":()=>t.e(24).then(t.bind(null,359)),"v-9b28a652":()=>t.e(25).then(t.bind(null,360)),"v-8c4a9152":()=>t.e(26).then(t.bind(null,361)),"v-5cbd4661":()=>t.e(27).then(t.bind(null,362)),"v-1ba8e18a":()=>t.e(28).then(t.bind(null,363)),"v-53802a1d":()=>t.e(29).then(t.bind(null,364)),"v-f7c2420a":()=>t.e(30).then(t.bind(null,365)),"v-da2a9fc6":()=>t.e(31).then(t.bind(null,366)),"v-2054c408":()=>t.e(32).then(t.bind(null,367)),"v-09bc8f71":()=>t.e(33).then(t.bind(null,368)),"v-77fac728":()=>t.e(34).then(t.bind(null,369)),"v-79c90a7b":()=>t.e(35).then(t.bind(null,370)),"v-71574ded":()=>t.e(36).then(t.bind(null,371)),"v-30bf3c37":()=>t.e(37).then(t.bind(null,372)),"v-c0c40344":()=>t.e(38).then(t.bind(null,373)),"v-7a275079":()=>t.e(39).then(t.bind(null,374)),"v-4a5cfa03":()=>t.e(40).then(t.bind(null,375)),"v-4c534fbf":()=>t.e(41).then(t.bind(null,376)),"v-69f10f6e":()=>t.e(42).then(t.bind(null,377)),"v-3c10a1ee":()=>t.e(43).then(t.bind(null,378)),"v-8f64580a":()=>t.e(44).then(t.bind(null,379)),"v-49b9a1be":()=>t.e(45).then(t.bind(null,380)),"v-39fe8849":()=>t.e(46).then(t.bind(null,381)),"v-05549976":()=>t.e(47).then(t.bind(null,382)),"v-2c8ff229":()=>t.e(48).then(t.bind(null,383)),"v-3627a1ae":()=>t.e(49).then(t.bind(null,384)),"v-6943f57e":()=>t.e(50).then(t.bind(null,385)),"v-20c332bc":()=>t.e(51).then(t.bind(null,386)),"v-8c83b362":()=>t.e(52).then(t.bind(null,387)),"v-f171761e":()=>t.e(53).then(t.bind(null,388)),"v-30c1718e":()=>t.e(54).then(t.bind(null,389)),"v-52ed6d9a":()=>t.e(55).then(t.bind(null,390)),"v-86deda42":()=>t.e(56).then(t.bind(null,391)),"v-45233dfe":()=>t.e(57).then(t.bind(null,392)),"v-3b3f506b":()=>t.e(58).then(t.bind(null,393)),"v-3845c3dc":()=>t.e(59).then(t.bind(null,394)),"v-7b951ec0":()=>t.e(60).then(t.bind(null,395)),"v-5437b4e6":()=>t.e(61).then(t.bind(null,396)),"v-20657ba0":()=>t.e(62).then(t.bind(null,397)),"v-e799e854":()=>t.e(63).then(t.bind(null,398)),"v-028118fc":()=>t.e(64).then(t.bind(null,399)),"v-5b1d5cfe":()=>t.e(65).then(t.bind(null,400)),"v-c2aabbf8":()=>t.e(66).then(t.bind(null,401)),"v-c835727c":()=>t.e(67).then(t.bind(null,402)),"v-92baed56":()=>t.e(68).then(t.bind(null,403)),"v-5eeceb01":()=>t.e(69).then(t.bind(null,404)),"v-5adcfe41":()=>t.e(70).then(t.bind(null,405)),"v-e55e3eb4":()=>t.e(71).then(t.bind(null,406)),"v-a44de862":()=>t.e(72).then(t.bind(null,407)),"v-71a9328d":()=>t.e(73).then(t.bind(null,408)),"v-bae276c8":()=>t.e(74).then(t.bind(null,409)),"v-d12388be":()=>t.e(75).then(t.bind(null,410)),"v-6207de52":()=>t.e(76).then(t.bind(null,411)),"v-7413e683":()=>t.e(77).then(t.bind(null,412)),"v-546e9ad7":()=>t.e(78).then(t.bind(null,413)),"v-f32c04aa":()=>t.e(79).then(t.bind(null,414)),"v-6c0f4a9d":()=>t.e(80).then(t.bind(null,415)),"v-2957f703":()=>t.e(81).then(t.bind(null,416)),"v-a9a3f93a":()=>t.e(82).then(t.bind(null,417)),"v-34308afa":()=>t.e(83).then(t.bind(null,418)),"v-7ecc48c8":()=>t.e(84).then(t.bind(null,419))};function Go(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ko=/-(\w)/g,Yo=Go(n=>n.replace(Ko,(n,e)=>e?e.toUpperCase():"")),Xo=/\B([A-Z])/g,Zo=Go(n=>n.replace(Xo,"-$1").toLowerCase()),Qo=Go(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Qo(Yo(e))):n(Qo(e))||n(Zo(e))}const es=Object.assign({},Vo,Jo),ts=n=>es[n],as=n=>Jo[n],is=n=>Vo[n],rs=n=>Vt.component(n);function os(n){return ns(as,n)}function ss(n){return ns(is,n)}function cs(n){return ns(ts,n)}function ls(n){return ns(rs,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ls(n)&&cs(n)){const e=await cs(n)();Vt.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(94),vs=t.n(ps),ms=t(95),fs=t.n(ms),hs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return vs()([{name:"description",content:this.$description}],n,this.siteMeta,ks)},updateCanonicalLink(){gs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),gs()}};function gs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ks(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var As=t(51),xs={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(As)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const r=e[n],o=e[n+1],s=0===n&&0===t||t>=r.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(r.hash)){const t=r;if(i===a)for(let t=n+1;t<e.length;t++)if(c===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},_s=t(27),ws=t.n(_s),Ss={mounted(){ws.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||ws.a.start(),t()}),this.$router.afterEach(()=>{ws.a.done(),this.isSidebarOpen=!1})}};t(240),t(241);class Es{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Is={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Es).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&a.firstChild?a.insertBefore(i,a.firstChild):a.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Cs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Ts={},Bs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ps=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Cs[n]},Rs=function n(e,t,a){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,r=e.children;i.appendChild(n(t,a,r))})),i},js=function(n,e,t){var a,i=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==i.length||t?i:i[0]},Ms=function(n,e){var t,a,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Bs(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,r=[eval][0](i);return r.template=e,r}(s.js,s.html);var c=Ps("vue");return s.jsLib.unshift(c),s},Ls=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),r=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:r&&r[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Os=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ds(){var n=js(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=js(n,"vuepress-plugin-demo-block__code"),t=js(n,"vuepress-plugin-demo-block__display"),a=js(n,"vuepress-plugin-demo-block__footer"),i=js(t,"vuepress-plugin-demo-block__app"),r=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var c=e.querySelector("div").clientHeight,l="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(a))(),r={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Os(n),htmlTpl:Bs("")},o=Ps("react"),s=Ps("reactDOM");return r.jsLib.unshift(o,s),r}(r,o):"vanilla"===s?Ls(r,o):Ms(r,o),d=Rs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Ns.bind(null,d,c,e,a)),Ps("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,i=n.jsLib,r=n.cssLib,o=i.concat(r).concat(Ps("cssLib")).concat(Ps("jsLib")).join(",");return Rs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),Ps("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,i=n.jsLib,r=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:i.concat(Ps("jsLib")).join(";"),css_external:r.concat(Ps("cssLib")).join(";"),layout:Ps("codepenLayout"),js_pre_processor:Ps("codepenJsProcessor"),editors:Ps("codepenEditors")});return Rs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==o.horizontal?o.horizontal:Ps("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(l.css&&function(n){if(!Ts[n]){var e=Rs("style",{innerHTML:n});document.body.appendChild(e),Ts[n]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),i);else if("vue"===s){var p=(new(Vue.extend(l.script))).$mount();i.appendChild(p.$el)}else"vanilla"===s&&(i.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ds()}),300)}function Ns(n,e,t,a){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var zs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ds()},updated:function(){Ds()}},Us="auto",$s="zoom-in",Fs="zoom-out",Hs="grab",qs="move";function Ws(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};a?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Js(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Gs(n,e,t){!function(n){var e=Ks,t=Ys;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var a=n.style,i={};for(var r in e)t&&(i[r]=a[r]||""),a[r]=e[r];return i}var Ks="transition",Ys="transform",Xs="transform",Zs="transitionend";var Qs=function(){},nc={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Qs,onClose:Qs,onGrab:Qs,onMove:Qs,onRelease:Qs,onBeforeOpen:Qs,onBeforeClose:Qs,onBeforeGrab:Qs,onBeforeRelease:Qs,onImageLoading:Qs,onImageLoaded:Qs},ec={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),ac(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,r=this.options.scrollThreshold;(Math.abs(i)>=r||Math.abs(a)>=r)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tc(n)&&!ac(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tc(n)&&!ac(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tc(n){return 0===n.button}function ac(n){return n.metaKey||n.ctrlKey}var ic={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Gs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ws(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Gs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},rc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},oc=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),sc=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},cc={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Js(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Hs:Fs,transition:Xs+"\n        "+a+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Gs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Gs(this.el,{transform:"none"})},grab:function(n,e,t){var a=lc(),i=a.x-n,r=a.y-e;Gs(this.el,{cursor:qs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=lc(),i=a.x-n,r=a.y-e;Gs(this.el,{transition:Xs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Gs(this.el,this.styleClose)},restoreOpenStyle:function(){Gs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=lc(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,i=a.customSize,r=a.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":rc(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,c=lc(),l={x:c.x-o,y:c.y-s},d=l.x/o,u=l.y/s,p=r+Math.min(d,u);if(i&&"string"==typeof i){var v=t||this.el.naturalWidth,m=e||this.el.naturalHeight,f=parseFloat(i)*v/(100*this.rect.width),h=parseFloat(i)*m/(100*this.rect.height);if(p>f||p>h)return{x:f,y:h}}return{x:p,y:p}}};function lc(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dc(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Ws(n,a,e[a],t)}))}var uc=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(cc),this.overlay=Object.create(ic),this.handler=Object.create(ec),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sc({},nc,e),this.overlay.init(this),this.handler.init(this)}return oc(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=$s,Ws(n,"click",this.handler.click),this.options.preloadImage&&Vs(Js(n)));return this}},{key:"config",value:function(n){return n?(sc(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(a),Vs(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ws(document,"scroll",this.handler.scroll),Ws(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ws(window,"resize",this.handler.resizeWindow);var r=function n(){Ws(a,Zs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dc(document,e.handler,!0),t(a)};return Ws(a,Zs,r),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Us,this.overlay.fadeOut(),this.target.zoomOut(),Ws(document,"scroll",this.handler.scroll,!1),Ws(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ws(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Ws(t,Zs,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dc(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ws(t,Zs,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var r=function n(){Ws(i,Zs,n,!1),a(i)};return Ws(i,Zs,r),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=qs,this.target.move(n,e,t);var i=this.target.el,r=function n(){Ws(i,Zs,n,!1),a(i)};return Ws(i,Zs,r),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Us,this.target.restoreOpenStyle();var a=function a(){Ws(t,Zs,a,!1),n.lock=!1,n.released=!0,e(t)};return Ws(t,Zs,a),this}}}]),n}();const pc=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),vc=Number("500");class mc{constructor(){this.instance=new uc(pc)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=vc){setTimeout(()=>this.update(n),e)}}var fc=[hs,xs,Ss,Is,zs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new mc,this.$vuepress.zooming.updateDelay()}}],hc={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},gc=t(1),bc=Object(gc.a)(hc,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bc,"mixins",fc);const yc=[{name:"v-0b35ed3d",path:"/article/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-0b35ed3d").then(t)}},{path:"/article/index.html",redirect:"/article/"},{path:"/00.目录页/01. 编程基础.html",redirect:"/article/"},{name:"v-6acc0b14",path:"/note/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-6acc0b14").then(t)}},{path:"/note/index.html",redirect:"/note/"},{path:"/00.目录页/02.Android.html",redirect:"/note/"},{name:"v-49da62b4",path:"/idea/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-49da62b4").then(t)}},{path:"/idea/index.html",redirect:"/idea/"},{path:"/00.目录页/03.iOS.html",redirect:"/idea/"},{name:"v-0df4d5eb",path:"/other/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-0df4d5eb").then(t)}},{path:"/other/index.html",redirect:"/other/"},{path:"/00.目录页/04.前端.html",redirect:"/other/"},{name:"v-0f201c8d",path:"/favorites/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-0f201c8d").then(t)}},{path:"/favorites/index.html",redirect:"/favorites/"},{path:"/00.目录页/05.软实力.html",redirect:"/favorites/"},{name:"v-ce7afb70",path:"/pages/43d909/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-ce7afb70").then(t)}},{path:"/pages/43d909/index.html",redirect:"/pages/43d909/"},{path:"/01.编程基础/01.数据结构与算法/00.测试.html",redirect:"/pages/43d909/"},{name:"v-5d44ccb7",path:"/pages/e8e456/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5d44ccb7").then(t)}},{path:"/pages/e8e456/index.html",redirect:"/pages/e8e456/"},{path:"/01.编程基础/01.数据结构与算法/01.数据结构/00.线性表.html",redirect:"/pages/e8e456/"},{name:"v-187f426b",path:"/pages/be0b6b/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-187f426b").then(t)}},{path:"/pages/be0b6b/index.html",redirect:"/pages/be0b6b/"},{path:"/01.编程基础/02.计算机组成原理/00.测试.html",redirect:"/pages/be0b6b/"},{name:"v-5d3712d8",path:"/pages/540b0e/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5d3712d8").then(t)}},{path:"/pages/540b0e/index.html",redirect:"/pages/540b0e/"},{path:"/01.编程基础/03.操作系统/00.测试.html",redirect:"/pages/540b0e/"},{name:"v-44ce66a4",path:"/pages/e5a034/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-44ce66a4").then(t)}},{path:"/pages/e5a034/index.html",redirect:"/pages/e5a034/"},{path:"/01.编程基础/04.网络/00.测试.html",redirect:"/pages/e5a034/"},{name:"v-2754d04e",path:"/pages/f6820e/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-2754d04e").then(t)}},{path:"/pages/f6820e/index.html",redirect:"/pages/f6820e/"},{path:"/01.编程基础/05.数据库原理/00.测试.html",redirect:"/pages/f6820e/"},{name:"v-52d5efdf",path:"/pages/586d36/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-52d5efdf").then(t)}},{path:"/pages/586d36/index.html",redirect:"/pages/586d36/"},{path:"/01.编程基础/06.C语言/00.测试.html",redirect:"/pages/586d36/"},{name:"v-a6a1ae9e",path:"/pages/1e535d/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-a6a1ae9e").then(t)}},{path:"/pages/1e535d/index.html",redirect:"/pages/1e535d/"},{path:"/01.编程基础/07.Java/00.JavaPoet的学习使用.html",redirect:"/pages/1e535d/"},{name:"v-d0b19c14",path:"/pages/8f05cf/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-d0b19c14").then(t)}},{path:"/pages/8f05cf/index.html",redirect:"/pages/8f05cf/"},{path:"/01.编程基础/07.Java/01.Java反射.html",redirect:"/pages/8f05cf/"},{name:"v-09c5e121",path:"/pages/767133/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-09c5e121").then(t)}},{path:"/pages/767133/index.html",redirect:"/pages/767133/"},{path:"/01.编程基础/07.Java/02.Java集合.html",redirect:"/pages/767133/"},{name:"v-3bbd0907",path:"/pages/88149c/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-3bbd0907").then(t)}},{path:"/pages/88149c/index.html",redirect:"/pages/88149c/"},{path:"/01.编程基础/07.Java/03.Java正则表达式.html",redirect:"/pages/88149c/"},{name:"v-1d5b13d5",path:"/pages/2882fd/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-1d5b13d5").then(t)}},{path:"/pages/2882fd/index.html",redirect:"/pages/2882fd/"},{path:"/01.编程基础/07.Java/04.Properties的学习.html",redirect:"/pages/2882fd/"},{name:"v-7568ef57",path:"/pages/870746/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-7568ef57").then(t)}},{path:"/pages/870746/index.html",redirect:"/pages/870746/"},{path:"/01.编程基础/08.Kotlin/00.测试.html",redirect:"/pages/870746/"},{name:"v-76f45877",path:"/pages/96e35a/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-76f45877").then(t)}},{path:"/pages/96e35a/index.html",redirect:"/pages/96e35a/"},{path:"/01.编程基础/09.Dart/00.测试.html",redirect:"/pages/96e35a/"},{name:"v-72defc83",path:"/pages/952ffa/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-72defc83").then(t)}},{path:"/pages/952ffa/index.html",redirect:"/pages/952ffa/"},{path:"/01.编程基础/10.C++/00.测试.html",redirect:"/pages/952ffa/"},{name:"v-9b28a652",path:"/pages/478433/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-9b28a652").then(t)}},{path:"/pages/478433/index.html",redirect:"/pages/478433/"},{path:"/01.编程基础/11.Js/00.测试.html",redirect:"/pages/478433/"},{name:"v-8c4a9152",path:"/pages/0d8b25/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-8c4a9152").then(t)}},{path:"/pages/0d8b25/index.html",redirect:"/pages/0d8b25/"},{path:"/02.Android/00.四大组件/00.Application/00.Application基础.html",redirect:"/pages/0d8b25/"},{name:"v-5cbd4661",path:"/pages/67f43d/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5cbd4661").then(t)}},{path:"/pages/67f43d/index.html",redirect:"/pages/67f43d/"},{path:"/02.Android/00.四大组件/01.Activity/00.Activity基础.html",redirect:"/pages/67f43d/"},{name:"v-1ba8e18a",path:"/pages/73feed/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-1ba8e18a").then(t)}},{path:"/pages/73feed/index.html",redirect:"/pages/73feed/"},{path:"/02.Android/00.四大组件/02.BroadcastReceiver/00.广播基础.html",redirect:"/pages/73feed/"},{name:"v-53802a1d",path:"/pages/f49146/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-53802a1d").then(t)}},{path:"/pages/f49146/index.html",redirect:"/pages/f49146/"},{path:"/02.Android/00.四大组件/03.ContentProvider/00.内容提供者基础.html",redirect:"/pages/f49146/"},{name:"v-f7c2420a",path:"/pages/575d07/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-f7c2420a").then(t)}},{path:"/pages/575d07/index.html",redirect:"/pages/575d07/"},{path:"/02.Android/00.四大组件/04.Service/00.服务基础.html",redirect:"/pages/575d07/"},{name:"v-da2a9fc6",path:"/pages/3e5b1b/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-da2a9fc6").then(t)}},{path:"/pages/3e5b1b/index.html",redirect:"/pages/3e5b1b/"},{path:"/02.Android/00.四大组件/05.Intent-filter.html",redirect:"/pages/3e5b1b/"},{name:"v-2054c408",path:"/pages/f7396a/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-2054c408").then(t)}},{path:"/pages/f7396a/index.html",redirect:"/pages/f7396a/"},{path:"/02.Android/00.四大组件/06.URL与URI基础.html",redirect:"/pages/f7396a/"},{name:"v-09bc8f71",path:"/pages/208508/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-09bc8f71").then(t)}},{path:"/pages/208508/index.html",redirect:"/pages/208508/"},{path:"/02.Android/01.Fragment/00.Fragment基础.html",redirect:"/pages/208508/"},{name:"v-77fac728",path:"/pages/095150/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-77fac728").then(t)}},{path:"/pages/095150/index.html",redirect:"/pages/095150/"},{path:"/02.Android/02.UI控件/00.基础布局/00.RelativeLayout.html",redirect:"/pages/095150/"},{name:"v-79c90a7b",path:"/pages/868569/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-79c90a7b").then(t)}},{path:"/pages/868569/index.html",redirect:"/pages/868569/"},{path:"/02.Android/02.UI控件/01.基础控件/00.TextView.html",redirect:"/pages/868569/"},{name:"v-71574ded",path:"/pages/8c2382/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-71574ded").then(t)}},{path:"/pages/8c2382/index.html",redirect:"/pages/8c2382/"},{path:"/02.Android/02.UI控件/02.ListView/00.ListView基础.html",redirect:"/pages/8c2382/"},{name:"v-30bf3c37",path:"/pages/65d2a2/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-30bf3c37").then(t)}},{path:"/pages/65d2a2/index.html",redirect:"/pages/65d2a2/"},{path:"/02.Android/02.UI控件/03.RecycleView/00.RecycleView基础.html",redirect:"/pages/65d2a2/"},{name:"v-c0c40344",path:"/pages/442ac8/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-c0c40344").then(t)}},{path:"/pages/442ac8/index.html",redirect:"/pages/442ac8/"},{path:"/02.Android/02.UI控件/03.自定义控件/00.基础常识.html",redirect:"/pages/442ac8/"},{name:"v-7a275079",path:"/pages/da7733/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-7a275079").then(t)}},{path:"/pages/da7733/index.html",redirect:"/pages/da7733/"},{path:"/02.Android/02.UI控件/04.ViewPager/00.ViewPager基础.html",redirect:"/pages/da7733/"},{name:"v-4a5cfa03",path:"/pages/14a2f5/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-4a5cfa03").then(t)}},{path:"/pages/14a2f5/index.html",redirect:"/pages/14a2f5/"},{path:"/02.Android/02.UI控件/04.弹窗/00.Dialog.html",redirect:"/pages/14a2f5/"},{name:"v-4c534fbf",path:"/pages/4f989a/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-4c534fbf").then(t)}},{path:"/pages/4f989a/index.html",redirect:"/pages/4f989a/"},{path:"/02.Android/02.UI控件/04.弹窗/01.Notification.html",redirect:"/pages/4f989a/"},{name:"v-69f10f6e",path:"/pages/5a9638/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-69f10f6e").then(t)}},{path:"/pages/5a9638/index.html",redirect:"/pages/5a9638/"},{path:"/02.Android/02.UI控件/04.弹窗/02.PopupWindow.html",redirect:"/pages/5a9638/"},{name:"v-3c10a1ee",path:"/pages/1e4f68/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-3c10a1ee").then(t)}},{path:"/pages/1e4f68/index.html",redirect:"/pages/1e4f68/"},{path:"/02.Android/02.UI控件/04.弹窗/03.Toast.html",redirect:"/pages/1e4f68/"},{name:"v-8f64580a",path:"/pages/6e1c4a/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-8f64580a").then(t)}},{path:"/pages/6e1c4a/index.html",redirect:"/pages/6e1c4a/"},{path:"/02.Android/02.UI控件/05.WebView/00.WebView基础.html",redirect:"/pages/6e1c4a/"},{name:"v-49b9a1be",path:"/pages/60a9ae/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-49b9a1be").then(t)}},{path:"/pages/60a9ae/index.html",redirect:"/pages/60a9ae/"},{path:"/02.Android/02.UI控件/06.自定义控件/00.基础常识.html",redirect:"/pages/60a9ae/"},{name:"v-39fe8849",path:"/pages/914d16/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-39fe8849").then(t)}},{path:"/pages/914d16/index.html",redirect:"/pages/914d16/"},{path:"/02.Android/02.UI控件/07.弹窗/00.Dialog.html",redirect:"/pages/914d16/"},{name:"v-05549976",path:"/pages/1ed6d5/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-05549976").then(t)}},{path:"/pages/1ed6d5/index.html",redirect:"/pages/1ed6d5/"},{path:"/02.Android/02.UI控件/07.弹窗/01.Notification.html",redirect:"/pages/1ed6d5/"},{name:"v-2c8ff229",path:"/pages/808803/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-2c8ff229").then(t)}},{path:"/pages/808803/index.html",redirect:"/pages/808803/"},{path:"/02.Android/02.UI控件/07.弹窗/02.PopupWindow.html",redirect:"/pages/808803/"},{name:"v-3627a1ae",path:"/pages/ee3e32/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-3627a1ae").then(t)}},{path:"/pages/ee3e32/index.html",redirect:"/pages/ee3e32/"},{path:"/02.Android/02.UI控件/07.弹窗/03.Toast.html",redirect:"/pages/ee3e32/"},{name:"v-6943f57e",path:"/pages/f616c6/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-6943f57e").then(t)}},{path:"/pages/f616c6/index.html",redirect:"/pages/f616c6/"},{path:"/02.Android/02.UI控件/08.动画/00.View动画.html",redirect:"/pages/f616c6/"},{name:"v-20c332bc",path:"/pages/d4d3f1/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-20c332bc").then(t)}},{path:"/pages/d4d3f1/index.html",redirect:"/pages/d4d3f1/"},{path:"/02.Android/02.UI控件/08.动画/01.属性动画.html",redirect:"/pages/d4d3f1/"},{name:"v-8c83b362",path:"/pages/0cffc9/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-8c83b362").then(t)}},{path:"/pages/0cffc9/index.html",redirect:"/pages/0cffc9/"},{path:"/02.Android/02.UI控件/08.动画/02.转场动画.html",redirect:"/pages/0cffc9/"},{name:"v-f171761e",path:"/pages/61d3af/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-f171761e").then(t)}},{path:"/pages/61d3af/index.html",redirect:"/pages/61d3af/"},{path:"/02.Android/03.数据持久化/00.文件/00.安卓文件基础.html",redirect:"/pages/61d3af/"},{name:"v-30c1718e",path:"/pages/fc8ccf/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-30c1718e").then(t)}},{path:"/pages/fc8ccf/index.html",redirect:"/pages/fc8ccf/"},{path:"/02.Android/03.数据持久化/01.数据库/00.SQLite基础.html",redirect:"/pages/fc8ccf/"},{name:"v-52ed6d9a",path:"/pages/42bd30/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-52ed6d9a").then(t)}},{path:"/pages/42bd30/index.html",redirect:"/pages/42bd30/"},{path:"/02.Android/03.数据持久化/02.SharedPreferences/00.SharedPreferences基础.html",redirect:"/pages/42bd30/"},{name:"v-86deda42",path:"/pages/9f8db9/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-86deda42").then(t)}},{path:"/pages/9f8db9/index.html",redirect:"/pages/9f8db9/"},{path:"/02.Android/04.传感器及连接性/00.传感器/00.传感器基础介绍.html",redirect:"/pages/9f8db9/"},{name:"v-45233dfe",path:"/pages/f75c98/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-45233dfe").then(t)}},{path:"/pages/f75c98/index.html",redirect:"/pages/f75c98/"},{path:"/02.Android/04.传感器及连接性/01.连接性/00.蓝牙.html",redirect:"/pages/f75c98/"},{name:"v-3b3f506b",path:"/pages/f8d0da/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-3b3f506b").then(t)}},{path:"/pages/f8d0da/index.html",redirect:"/pages/f8d0da/"},{path:"/02.Android/04.传感器及连接性/01.连接性/01.NFC.html",redirect:"/pages/f8d0da/"},{name:"v-3845c3dc",path:"/pages/4db516/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-3845c3dc").then(t)}},{path:"/pages/4db516/index.html",redirect:"/pages/4db516/"},{path:"/02.Android/04.传感器及连接性/01.连接性/02.低功耗蓝牙.html",redirect:"/pages/4db516/"},{name:"v-7b951ec0",path:"/pages/e006e9/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-7b951ec0").then(t)}},{path:"/pages/e006e9/index.html",redirect:"/pages/e006e9/"},{path:"/02.Android/05.三方框架/00.OkHttp/00.OkHttp基础.html",redirect:"/pages/e006e9/"},{name:"v-5437b4e6",path:"/pages/0886e5/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5437b4e6").then(t)}},{path:"/pages/0886e5/index.html",redirect:"/pages/0886e5/"},{path:"/02.Android/05.三方框架/01.Retrofit/00.Retrofit基础.html",redirect:"/pages/0886e5/"},{name:"v-20657ba0",path:"/pages/16acab/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-20657ba0").then(t)}},{path:"/pages/16acab/index.html",redirect:"/pages/16acab/"},{path:"/02.Android/05.三方框架/02.Glide/00.Glide基础.html",redirect:"/pages/16acab/"},{name:"v-e799e854",path:"/pages/a69c33/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-e799e854").then(t)}},{path:"/pages/a69c33/index.html",redirect:"/pages/a69c33/"},{path:"/02.Android/05.三方框架/05.koin/00.Koin基础.html",redirect:"/pages/a69c33/"},{name:"v-028118fc",path:"/pages/d2011c/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-028118fc").then(t)}},{path:"/pages/d2011c/index.html",redirect:"/pages/d2011c/"},{path:"/02.Android/06.项目架构/00.MVC/00.MVC简介.html",redirect:"/pages/d2011c/"},{name:"v-5b1d5cfe",path:"/pages/62a8b5/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5b1d5cfe").then(t)}},{path:"/pages/62a8b5/index.html",redirect:"/pages/62a8b5/"},{path:"/02.Android/06.项目架构/01.MVP/00.MVP简介.html",redirect:"/pages/62a8b5/"},{name:"v-c2aabbf8",path:"/pages/682f56/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-c2aabbf8").then(t)}},{path:"/pages/682f56/index.html",redirect:"/pages/682f56/"},{path:"/02.Android/06.项目架构/02.MVVM/00.MVVM简介.html",redirect:"/pages/682f56/"},{name:"v-c835727c",path:"/pages/4a6933/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-c835727c").then(t)}},{path:"/pages/4a6933/index.html",redirect:"/pages/4a6933/"},{path:"/02.Android/06.项目架构/03.MVI/00.MVI简介.html",redirect:"/pages/4a6933/"},{name:"v-92baed56",path:"/pages/4c3f68/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-92baed56").then(t)}},{path:"/pages/4c3f68/index.html",redirect:"/pages/4c3f68/"},{path:"/02.Android/07.性能优化/00.性能优化简介.html",redirect:"/pages/4c3f68/"},{name:"v-5eeceb01",path:"/pages/e4244a/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5eeceb01").then(t)}},{path:"/pages/e4244a/index.html",redirect:"/pages/e4244a/"},{path:"/02.Android/08.编码工具/00.Gradle/00.Gradle简介.html",redirect:"/pages/e4244a/"},{name:"v-5adcfe41",path:"/pages/be5e92/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-5adcfe41").then(t)}},{path:"/pages/be5e92/index.html",redirect:"/pages/be5e92/"},{path:"/02.Android/08.编码工具/01.AndroidStudio/00.AndroidStudio技巧.html",redirect:"/pages/be5e92/"},{name:"v-e55e3eb4",path:"/pages/30e044/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-e55e3eb4").then(t)}},{path:"/pages/30e044/index.html",redirect:"/pages/30e044/"},{path:"/02.Android/09.必会原理/00.消息机制/00.Handler基础.html",redirect:"/pages/30e044/"},{name:"v-a44de862",path:"/pages/c2a627/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-a44de862").then(t)}},{path:"/pages/c2a627/index.html",redirect:"/pages/c2a627/"},{path:"/02.Android/09.必会原理/01.IPC/00.IPC基础.html",redirect:"/pages/c2a627/"},{name:"v-71a9328d",path:"/pages/e0cd61/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-71a9328d").then(t)}},{path:"/pages/e0cd61/index.html",redirect:"/pages/e0cd61/"},{path:"/02.Android/09.必会原理/02.屏幕适配/00.屏幕适配基础.html",redirect:"/pages/e0cd61/"},{name:"v-bae276c8",path:"/pages/f80d6c/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-bae276c8").then(t)}},{path:"/pages/f80d6c/index.html",redirect:"/pages/f80d6c/"},{path:"/02.Android/10.编码规范与技巧/00.编码规范.html",redirect:"/pages/f80d6c/"},{name:"v-d12388be",path:"/pages/caba2c/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-d12388be").then(t)}},{path:"/pages/caba2c/index.html",redirect:"/pages/caba2c/"},{path:"/03.iOS/00.测试.html",redirect:"/pages/caba2c/"},{name:"v-6207de52",path:"/pages/5d9ede/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-6207de52").then(t)}},{path:"/pages/5d9ede/index.html",redirect:"/pages/5d9ede/"},{path:"/04.前端/00.测试.html",redirect:"/pages/5d9ede/"},{name:"v-7413e683",path:"/pages/dd157d/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-7413e683").then(t)}},{path:"/pages/dd157d/index.html",redirect:"/pages/dd157d/"},{path:"/05.软实力/01.效率工具/00.测试.html",redirect:"/pages/dd157d/"},{name:"v-546e9ad7",path:"/pages/c9ee07/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-546e9ad7").then(t)}},{path:"/pages/c9ee07/index.html",redirect:"/pages/c9ee07/"},{path:"/05.软实力/02.调试工具/00.测试.html",redirect:"/pages/c9ee07/"},{name:"v-f32c04aa",path:"/pages/c22b04/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-f32c04aa").then(t)}},{path:"/pages/c22b04/index.html",redirect:"/pages/c22b04/"},{path:"/05.软实力/03.版本控制/00.测试.html",redirect:"/pages/c22b04/"},{name:"v-6c0f4a9d",path:"/pages/0a00bd/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-6c0f4a9d").then(t)}},{path:"/pages/0a00bd/index.html",redirect:"/pages/0a00bd/"},{path:"/05.软实力/04.画图表达/00.测试.html",redirect:"/pages/0a00bd/"},{name:"v-2957f703",path:"/archives/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-2957f703").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-a9a3f93a",path:"/categories/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-a9a3f93a").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-34308afa",path:"/tags/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-34308afa").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-7ecc48c8",path:"/",component:bc,beforeEnter:(n,e,t)=>{ds("Layout","v-7ecc48c8").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bc}],kc={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"cv,fastcv,个人博客"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#7b074b"}],["script",{"data-ad-client":"ca-pub-8621788234752924",async:!0,src:"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924",crossorigin:"anonymous"}]],pages:[{title:"编程基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.编程基础",imgUrl:"/img/web.png",description:"内功很重要"}},title:"编程基础",date:"2020-03-11T21:50:53.000Z",permalink:"/article",sidebar:!1,article:!1,comment:!0,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/01. 编程基础.md",key:"v-0b35ed3d",path:"/article/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/7/2022",lastUpdatedTimestamp:1665159431e3},{title:"Android",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.Android",imgUrl:"/img/web.png",description:"Android平台"}},title:"Android",date:"2020-03-11T21:50:53.000Z",permalink:"/note",sidebar:!1,article:!1,comment:!0,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.Android.html",relativePath:"00.目录页/02.Android.md",key:"v-6acc0b14",path:"/note/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"iOS",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.iOS",imgUrl:"/img/other.png",description:"iOS平台"}},title:"iOS",date:"2020-03-11T21:50:54.000Z",permalink:"/idea",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.iOS.html",relativePath:"00.目录页/03.iOS.md",key:"v-49da62b4",path:"/idea/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.前端",imgUrl:"/img/more.png",description:"前端平台"}},title:"前端",date:"2020-03-11T21:50:55.000Z",permalink:"/other",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/04.前端.md",key:"v-0df4d5eb",path:"/other/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"软实力",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"05.软实力",imgUrl:"/img/python.png",description:"欲善其事，先利其器"}},title:"软实力",date:"2020-03-11T21:50:55.000Z",permalink:"/favorites",sidebar:!1,article:!1,comment:!0,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E8%BD%AF%E5%AE%9E%E5%8A%9B.html",relativePath:"00.目录页/05.软实力.md",key:"v-0f201c8d",path:"/favorites/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:22:00.000Z",permalink:"/pages/43d909/",categories:["编程基础","数据结构与算法"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/01.数据结构与算法/00.测试.md",key:"v-ce7afb70",path:"/pages/43d909/",headersStr:null,content:"# 程序的组成\n\n程序 = 算法 + 数据结构\n\n\n1\n",normalizedContent:"# 程序的组成\n\n程序 = 算法 + 数据结构\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"线性表",frontmatter:{title:"线性表",date:"2022-10-10T14:22:00.000Z",permalink:"/pages/e8e456/",categories:["编程基础","数据结构与算法","数据结构"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/00.%E7%BA%BF%E6%80%A7%E8%A1%A8.html",relativePath:"01.编程基础/01.数据结构与算法/01.数据结构/00.线性表.md",key:"v-5d44ccb7",path:"/pages/e8e456/",headersStr:null,content:"# 线性表\n\n线性表是数据结构中最常见的一种数据结构。",normalizedContent:"# 线性表\n\n线性表是数据结构中最常见的一种数据结构。",charsets:{cjk:!0},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:22:31.000Z",permalink:"/pages/be0b6b/",categories:["编程基础","计算机组成原理"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/02.计算机组成原理/00.测试.md",key:"v-187f426b",path:"/pages/be0b6b/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:23:34.000Z",permalink:"/pages/540b0e/",categories:["编程基础","操作系统"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/03.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/03.操作系统/00.测试.md",key:"v-5d3712d8",path:"/pages/540b0e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:23:50.000Z",permalink:"/pages/e5a034/",categories:["编程基础","网络"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/04.%E7%BD%91%E7%BB%9C/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/04.网络/00.测试.md",key:"v-44ce66a4",path:"/pages/e5a034/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:24:09.000Z",permalink:"/pages/f6820e/",categories:["编程基础","数据库原理"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/05.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/05.数据库原理/00.测试.md",key:"v-2754d04e",path:"/pages/f6820e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:24:28.000Z",permalink:"/pages/586d36/",categories:["编程基础","C语言"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/06.C%E8%AF%AD%E8%A8%80/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/06.C语言/00.测试.md",key:"v-52d5efdf",path:"/pages/586d36/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"JavaPoet的学习使用",frontmatter:{title:"JavaPoet的学习使用",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/1e535d/",categories:["编程基础","Java"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/07.Java/00.JavaPoet%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8.html",relativePath:"01.编程基础/07.Java/00.JavaPoet的学习使用.md",key:"v-a6a1ae9e",path:"/pages/1e535d/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:61},{level:3,title:"实例代码",slug:"实例代码",normalizedTitle:"实例代码",charIndex:83},{level:3,title:"关键字及作用",slug:"关键字及作用",normalizedTitle:"关键字及作用",charIndex:1615},{level:3,title:"占位符",slug:"占位符",normalizedTitle:"占位符",charIndex:1898},{level:3,title:"官方文档",slug:"官方文档",normalizedTitle:"官方文档",charIndex:2084},{level:4,title:"花括号",slug:"花括号",normalizedTitle:"花括号",charIndex:2092},{level:4,title:"多个花括号",slug:"多个花括号",normalizedTitle:"多个花括号",charIndex:3290},{level:4,title:"占位符$L",slug:"占位符-l",normalizedTitle:"占位符$l",charIndex:4734},{level:4,title:"占位符$S",slug:"占位符-s",normalizedTitle:"占位符$s",charIndex:5146},{level:4,title:"占位符$L",slug:"占位符-l-2",normalizedTitle:"占位符$l",charIndex:4734},{level:4,title:"占位符$N",slug:"占位符-n",normalizedTitle:"占位符$n",charIndex:9812},{level:4,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:10709},{level:4,title:"Constructors",slug:"constructors",normalizedTitle:"constructors",charIndex:11095},{level:4,title:"Parameters",slug:"parameters",normalizedTitle:"parameters",charIndex:11700},{level:4,title:"Fields",slug:"fields",normalizedTitle:"fields",charIndex:12107},{level:4,title:"Interfaces",slug:"interfaces",normalizedTitle:"interfaces",charIndex:12835},{level:4,title:"Enums",slug:"enums",normalizedTitle:"enums",charIndex:13428},{level:4,title:"Anonymous Inner Classes",slug:"anonymous-inner-classes",normalizedTitle:"anonymous inner classes",charIndex:14989},{level:4,title:"Annotations",slug:"annotations",normalizedTitle:"annotations",charIndex:16091},{level:4,title:"Javadoc",slug:"javadoc",normalizedTitle:"javadoc",charIndex:17957}],headersStr:"前言 下载 实例代码 关键字及作用 占位符 官方文档 花括号 多个花括号 占位符$L 占位符$S 占位符$L 占位符$N Methods Constructors Parameters Fields Interfaces Enums Anonymous Inner Classes Annotations Javadoc",content:'# 前言\n\n今日，学习ButterKnife的原理时，了解到了，JavaPoet这个工具，挺有意思的，记录一下。\n\n\n# 下载\n\n我选用的是下载jar包下载\n\n\n# 实例代码\n\npublic class TestOne {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        //构造一个方法\n        MethodSpec main = MethodSpec.methodBuilder("main")   //名称\n                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)   //修饰\n                .returns(void.class)   //返回参数\n                .addParameter(String[].class,"args")   //参数\n                .addStatement("System.out.println(\\"Hello , javaPoet\\" + add(10,10))")   //语句\n                .build();\n\n        MethodSpec add = MethodSpec.methodBuilder("add")\n                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)\n                .returns(int.class)\n                .addParameter(int.class,"a")\n                .addParameter(int.class,"b")\n                .addStatement("return a + b")\n                .build();\n\n        //构造一个类\n        TypeSpec hello = TypeSpec.classBuilder("Hello")\n                .addModifiers(Modifier.PUBLIC)\n                .addMethod(main)\n                .addMethod(add)\n                .build();\n\n        //生成一个Java文件\n        JavaFile javaFile = JavaFile.builder("com.poet.demo",hello).build();\n\n        //将Java写到当前项目中\n        javaFile.writeTo(System.out);   //打印到命令行中\n\n        File file = new File("./src/");\n        if (file.exists()) {\n            file.delete();\n        }\n        javaFile.writeTo(file);\n\n        Thread.sleep(3000);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n直接看来，这些代码也是很容易让人看懂的，我们还是来了解一下各自的用法吧\n\n\n# 关键字及作用\n\n类                含义\nMethodSpec       代表一个构造函数或方法声明\nTypeSpec         代表一个类，接口，或者枚举声明\nFieldSpec        代表一个成员变量，一个字段声明\nJavaFile         包含一个顶级类的Java文件\nParameterSpec    用来创建参数\nAnnotationSpec   用来创建注解\nTypeName         类型，如在添加返回值类型是使用 TypeName.VOID\nClassName        用来包装一个类\n\n\n\n\n# 占位符\n\n占位符   含义\n$L    参数\n$S    字符串的模板,将指定的字符串替换到$S的地方\n$N    $N在JavaPoet中代指的是一个名称，例如调用的方法名称，变量名称，这一类存在意思的名称\n$T    $T\n      在JavaPoet代指的是TypeName，该模板主要将Class抽象出来，用传入的TypeName指向的Class来代替\n\n\n# 官方文档\n\n# 花括号\n\n比如，我们想实现这样的一个类的代码\n\nvoid main() {\n  int total = 0;\n  for (int i = 0; i < 10; i++) {\n    total += i;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n按照上面的写法，我们的代码是这样子的\n\nMethodSpec main = MethodSpec.methodBuilder("main")\n    .addCode(""\n        + "int total = 0;\\n"\n        + "for (int i = 0; i < 10; i++) {\\n"\n        + "  total += i;\\n"\n        + "}\\n")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是，这样子看起来很很不友好。\n\n那么我们可以这么改\n\nMethodSpec main = MethodSpec.methodBuilder("main")\n    .addStatement("int total = 0")\n    .beginControlFlow("for (int i = 0; i < 10; i++)")\n    .addStatement("total += i")\n    .endControlFlow()\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n所以，我们实现这样子的代码\n\nint multiply10to20() {\n  int result = 1;\n  for (int i = 10; i < 20; i++) {\n    result = result * i;\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n只需要这么写\n\nprivate MethodSpec computeRange(String name, int from, int to, String op) {\n  return MethodSpec.methodBuilder(name)\n      .returns(int.class)\n      .addStatement("int result = 1")\n      .beginControlFlow("for (int i = " + from + "; i < " + to + "; i++)")\n      .addStatement("result = result " + op + " i")\n      .endControlFlow()\n      .addStatement("return result")\n      .build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n即可。\n\n# 多个花括号\n\n如果我们要实现如下的代码\n\nvoid main() {\n  long now = System.currentTimeMillis();\n  if (System.currentTimeMillis() < now)  {\n    System.out.println("Time travelling, woo hoo!");\n  } else if (System.currentTimeMillis() == now) {\n    System.out.println("Time stood still!");\n  } else {\n    System.out.println("Ok, time still moving forward");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们要这么写\n\nMethodSpec main = MethodSpec.methodBuilder("main")\n    .addStatement("long now = $T.currentTimeMillis()", System.class)\n    .beginControlFlow("if ($T.currentTimeMillis() < now)", System.class)\n    .addStatement("$T.out.println($S)", System.class, "Time travelling, woo hoo!")\n    .nextControlFlow("else if ($T.currentTimeMillis() == now)", System.class)\n    .addStatement("$T.out.println($S)", System.class, "Time stood still!")\n    .nextControlFlow("else")\n    .addStatement("$T.out.println($S)", System.class, "Ok, time still moving forward")\n    .endControlFlow()\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n那么，实现\n\nvoid main() {\n  try {\n    throw new Exception("Failed");\n  } catch (Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n就可以这么写了\n\nMethodSpec main = MethodSpec.methodBuilder("main")\n    .beginControlFlow("try")\n    .addStatement("throw new Exception($S)", "Failed")\n    .nextControlFlow("catch ($T e)", Exception.class)\n    .addStatement("throw new $T(e)", RuntimeException.class)\n    .endControlFlow()\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 占位符$L\n\n如下\n\nprivate MethodSpec computeRange(String name, int from, int to, String op) {\n  return MethodSpec.methodBuilder(name)\n      .returns(int.class)\n      .addStatement("int result = 0")\n      .beginControlFlow("for (int i = $L; i < $L; i++)", from, to)\n      .addStatement("result = result $L i", op)\n      .endControlFlow()\n      .addStatement("return result")\n      .build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 占位符$S\n\n如下\n\npublic static void main(String[] args) throws Exception {\n  TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")\n      .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n      .addMethod(whatsMyName("slimShady"))\n      .addMethod(whatsMyName("eminem"))\n      .addMethod(whatsMyName("marshallMathers"))\n      .build();\n\n  JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)\n      .build();\n\n  javaFile.writeTo(System.out);\n}\n\nprivate static MethodSpec whatsMyName(String name) {\n  return MethodSpec.methodBuilder(name)\n      .returns(String.class)\n      .addStatement("return $S", name)\n      .build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n生成的代码为\n\npublic final class HelloWorld {\n  String slimShady() {\n    return "slimShady";\n  }\n\n  String eminem() {\n    return "eminem";\n  }\n\n  String marshallMathers() {\n    return "marshallMathers";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 占位符$L\n\n如下\n\nMethodSpec today = MethodSpec.methodBuilder("today")\n    .returns(Date.class)\n    .addStatement("return new $T()", Date.class)\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")\n    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n    .addMethod(today)\n    .build();\n\nJavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)\n    .build();\n\njavaFile.writeTo(System.out);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport java.util.Date;\n\npublic final class HelloWorld {\n  Date today() {\n    return new Date();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n此处我们返回的是java环境中有的类，如果返回的不是已经运行的类，我们需要这么写\n\nClassName hoverboard = ClassName.get("com.mattel", "Hoverboard");\n\nMethodSpec today = MethodSpec.methodBuilder("tomorrow")\n    .returns(hoverboard)\n    .addStatement("return new $T()", hoverboard)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport com.mattel.Hoverboard;\n\npublic final class HelloWorld {\n  Hoverboard tomorrow() {\n    return new Hoverboard();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n也可以表示多个\n\nClassName hoverboard = ClassName.get("com.mattel", "Hoverboard");\nClassName list = ClassName.get("java.util", "List");\nClassName arrayList = ClassName.get("java.util", "ArrayList");\nTypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);\n\nMethodSpec beyond = MethodSpec.methodBuilder("beyond")\n    .returns(listOfHoverboards)\n    .addStatement("$T result = new $T<>()", listOfHoverboards, arrayList)\n    .addStatement("result.add(new $T())", hoverboard)\n    .addStatement("result.add(new $T())", hoverboard)\n    .addStatement("result.add(new $T())", hoverboard)\n    .addStatement("return result")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport com.mattel.Hoverboard;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic final class HelloWorld {\n  List<Hoverboard> beyond() {\n    List<Hoverboard> result = new ArrayList<>();\n    result.add(new Hoverboard());\n    result.add(new Hoverboard());\n    result.add(new Hoverboard());\n    return result;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n静态导入\n\nClassName namedBoards = ClassName.get("com.mattel", "Hoverboard", "Boards");\n\nMethodSpec beyond = MethodSpec.methodBuilder("beyond")\n    .returns(listOfHoverboards)\n    .addStatement("$T result = new $T<>()", listOfHoverboards, arrayList)\n    .addStatement("result.add($T.createNimbus(2000))", hoverboard)\n    .addStatement("result.add($T.createNimbus(\\"2001\\"))", hoverboard)\n    .addStatement("result.add($T.createNimbus($T.THUNDERBOLT))", hoverboard, namedBoards)\n    .addStatement("$T.sort(result)", Collections.class)\n    .addStatement("return result.isEmpty() ? $T.emptyList() : result", Collections.class)\n    .build();\n\nTypeSpec hello = TypeSpec.classBuilder("HelloWorld")\n    .addMethod(beyond)\n    .build();\n\nJavaFile.builder("com.example.helloworld", hello)\n    .addStaticImport(hoverboard, "createNimbus")\n    .addStaticImport(namedBoards, "*")\n    .addStaticImport(Collections.class, "*")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport static com.mattel.Hoverboard.Boards.*;\nimport static com.mattel.Hoverboard.createNimbus;\nimport static java.util.Collections.*;\n\nimport com.mattel.Hoverboard;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass HelloWorld {\n  List<Hoverboard> beyond() {\n    List<Hoverboard> result = new ArrayList<>();\n    result.add(createNimbus(2000));\n    result.add(createNimbus("2001"));\n    result.add(createNimbus(THUNDERBOLT));\n    sort(result);\n    return result.isEmpty() ? emptyList() : result;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 占位符$N\n\n我们要生成如下的代码\n\npublic String byteToHex(int b) {\n  char[] result = new char[2];\n  result[0] = hexDigit((b >>> 4) & 0xf);\n  result[1] = hexDigit(b & 0xf);\n  return new String(result);\n}\n\npublic char hexDigit(int i) {\n  return (char) (i < 10 ? i + \'0\' : i - 10 + \'a\');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们可以这么写\n\nMethodSpec hexDigit = MethodSpec.methodBuilder("hexDigit")\n    .addParameter(int.class, "i")\n    .returns(char.class)\n    .addStatement("return (char) (i < 10 ? i + \'0\' : i - 10 + \'a\')")\n    .build();\n\nMethodSpec byteToHex = MethodSpec.methodBuilder("byteToHex")\n    .addParameter(int.class, "b")\n    .returns(String.class)\n    .addStatement("char[] result = new char[2]")\n    .addStatement("result[0] = $N((b >>> 4) & 0xf)", hexDigit)\n    .addStatement("result[1] = $N(b & 0xf)", hexDigit)\n    .addStatement("return new String(result)")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# Methods\n\nMethodSpec flux = MethodSpec.methodBuilder("flux")\n    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addMethod(flux)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n生成\n\npublic abstract class HelloWorld {\n  protected abstract void flux();\n}\n\n\n1\n2\n3\n\n\n# Constructors\n\nMethodSpec flux = MethodSpec.constructorBuilder()\n    .addModifiers(Modifier.PUBLIC)\n    .addParameter(String.class, "greeting")\n    .addStatement("this.$N = $N", "greeting", "greeting")\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")\n    .addModifiers(Modifier.PUBLIC)\n    .addField(String.class, "greeting", Modifier.PRIVATE, Modifier.FINAL)\n    .addMethod(flux)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n生成\n\npublic class HelloWorld {\n  private final String greeting;\n\n  public HelloWorld(String greeting) {\n    this.greeting = greeting;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# Parameters\n\nParameterSpec android = ParameterSpec.builder(String.class, "android")\n    .addModifiers(Modifier.FINAL)\n    .build();\n\nMethodSpec welcomeOverlords = MethodSpec.methodBuilder("welcomeOverlords")\n    .addParameter(android)\n    .addParameter(String.class, "robot", Modifier.FINAL)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n生成\n\nvoid welcomeOverlords(final String android, final String robot) {\n}\n\n\n1\n2\n\n\n# Fields\n\nFieldSpec android = FieldSpec.builder(String.class, "android")\n    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")\n    .addModifiers(Modifier.PUBLIC)\n    .addField(android)\n    .addField(String.class, "robot", Modifier.PRIVATE, Modifier.FINAL)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生成\n\npublic class HelloWorld {\n  private final String android;\n\n  private final String robot;\n}\n\n\n1\n2\n3\n4\n5\n\n\n还有\n\nFieldSpec android = FieldSpec.builder(String.class, "android")\n    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n    .initializer("$S + $L", "Lollipop v.", 5.0d)\n    .build();\n\n\n1\n2\n3\n4\n\n\n生成\n\nprivate final String android = "Lollipop v." + 5.0;\n\n\n1\n\n\n# Interfaces\n\nTypeSpec helloWorld = TypeSpec.interfaceBuilder("HelloWorld")\n    .addModifiers(Modifier.PUBLIC)\n    .addField(FieldSpec.builder(String.class, "ONLY_THING_THAT_IS_CONSTANT")\n        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n        .initializer("$S", "change")\n        .build())\n    .addMethod(MethodSpec.methodBuilder("beep")\n        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n        .build())\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n生成\n\npublic interface HelloWorld {\n  String ONLY_THING_THAT_IS_CONSTANT = "change";\n\n  void beep();\n}\n\n\n1\n2\n3\n4\n5\n\n\n# Enums\n\nTypeSpec helloWorld = TypeSpec.enumBuilder("Roshambo")\n    .addModifiers(Modifier.PUBLIC)\n    .addEnumConstant("ROCK")\n    .addEnumConstant("SCISSORS")\n    .addEnumConstant("PAPER")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n生成\n\npublic enum Roshambo {\n  ROCK,\n\n  SCISSORS,\n\n  PAPER\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如：\n\nTypeSpec helloWorld = TypeSpec.enumBuilder("Roshambo")\n    .addModifiers(Modifier.PUBLIC)\n    .addEnumConstant("ROCK", TypeSpec.anonymousClassBuilder("$S", "fist")\n        .addMethod(MethodSpec.methodBuilder("toString")\n            .addAnnotation(Override.class)\n            .addModifiers(Modifier.PUBLIC)\n            .addStatement("return $S", "avalanche!")\n            .returns(String.class)\n            .build())\n        .build())\n    .addEnumConstant("SCISSORS", TypeSpec.anonymousClassBuilder("$S", "peace")\n        .build())\n    .addEnumConstant("PAPER", TypeSpec.anonymousClassBuilder("$S", "flat")\n        .build())\n    .addField(String.class, "handsign", Modifier.PRIVATE, Modifier.FINAL)\n    .addMethod(MethodSpec.constructorBuilder()\n        .addParameter(String.class, "handsign")\n        .addStatement("this.$N = $N", "handsign", "handsign")\n        .build())\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n生成\n\npublic enum Roshambo {\n  ROCK("fist") {\n    @Override\n    public String toString() {\n      return "avalanche!";\n    }\n  },\n\n  SCISSORS("peace"),\n\n  PAPER("flat");\n\n  private final String handsign;\n\n  Roshambo(String handsign) {\n    this.handsign = handsign;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# Anonymous Inner Classes\n\nTypeSpec comparator = TypeSpec.anonymousClassBuilder("")\n    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))\n    .addMethod(MethodSpec.methodBuilder("compare")\n        .addAnnotation(Override.class)\n        .addModifiers(Modifier.PUBLIC)\n        .addParameter(String.class, "a")\n        .addParameter(String.class, "b")\n        .returns(int.class)\n        .addStatement("return $N.length() - $N.length()", "a", "b")\n        .build())\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")\n    .addMethod(MethodSpec.methodBuilder("sortByLength")\n        .addParameter(ParameterizedTypeName.get(List.class, String.class), "strings")\n        .addStatement("$T.sort($N, $L)", Collections.class, "strings", comparator)\n        .build())\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n生成\n\nvoid sortByLength(List<String> strings) {\n  Collections.sort(strings, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n      return a.length() - b.length();\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# Annotations\n\nMethodSpec toString = MethodSpec.methodBuilder("toString")\n    .addAnnotation(Override.class)\n    .returns(String.class)\n    .addModifiers(Modifier.PUBLIC)\n    .addStatement("return $S", "Hoverboard")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n生成\n\n  @Override\n  public String toString() {\n    return "Hoverboard";\n  }\n\n\n1\n2\n3\n4\n\n\n还有\n\nMethodSpec logRecord = MethodSpec.methodBuilder("recordEvent")\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addAnnotation(AnnotationSpec.builder(Headers.class)\n        .addMember("accept", "$S", "application/json; charset=utf-8")\n        .addMember("userAgent", "$S", "Square Cash")\n        .build())\n    .addParameter(LogRecord.class, "logRecord")\n    .returns(LogReceipt.class)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生成\n\n@Headers(\n    accept = "application/json; charset=utf-8",\n    userAgent = "Square Cash"\n)\nLogReceipt recordEvent(LogRecord logRecord);\n\n\n1\n2\n3\n4\n5\n\n\nMethodSpec logRecord = MethodSpec.methodBuilder("recordEvent")\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addAnnotation(AnnotationSpec.builder(HeaderList.class)\n        .addMember("value", "$L", AnnotationSpec.builder(Header.class)\n            .addMember("name", "$S", "Accept")\n            .addMember("value", "$S", "application/json; charset=utf-8")\n            .build())\n        .addMember("value", "$L", AnnotationSpec.builder(Header.class)\n            .addMember("name", "$S", "User-Agent")\n            .addMember("value", "$S", "Square Cash")\n            .build())\n        .build())\n    .addParameter(LogRecord.class, "logRecord")\n    .returns(LogReceipt.class)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n生成\n\n@HeaderList({\n    @Header(name = "Accept", value = "application/json; charset=utf-8"),\n    @Header(name = "User-Agent", value = "Square Cash")\n})\nLogReceipt recordEvent(LogRecord logRecord);\n\n\n1\n2\n3\n4\n5\n\n\n# Javadoc\n\nMethodSpec dismiss = MethodSpec.methodBuilder("dismiss")\n    .addJavadoc("Hides {@code message} from the caller\'s history. Other\\n"\n        + "participants in the conversation will continue to see the\\n"\n        + "message in their own history unless they also delete it.\\n")\n    .addJavadoc("\\n")\n    .addJavadoc("<p>Use {@link #delete($T)} to delete the entire\\n"\n        + "conversation for all participants.\\n", Conversation.class)\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addParameter(Message.class, "message")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n生成\n\n  /**\n   * Hides {@code message} from the caller\'s history. Other\n   * participants in the conversation will continue to see the\n   * message in their own history unless they also delete it.\n   *\n   * <p>Use {@link #delete(Conversation)} to delete the entire\n   * conversation for all participants.\n   */\n  void dismiss(Message message);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# 前言\n\n今日，学习butterknife的原理时，了解到了，javapoet这个工具，挺有意思的，记录一下。\n\n\n# 下载\n\n我选用的是下载jar包下载\n\n\n# 实例代码\n\npublic class testone {\n    public static void main(string[] args) throws ioexception, interruptedexception {\n        //构造一个方法\n        methodspec main = methodspec.methodbuilder("main")   //名称\n                .addmodifiers(modifier.public,modifier.static)   //修饰\n                .returns(void.class)   //返回参数\n                .addparameter(string[].class,"args")   //参数\n                .addstatement("system.out.println(\\"hello , javapoet\\" + add(10,10))")   //语句\n                .build();\n\n        methodspec add = methodspec.methodbuilder("add")\n                .addmodifiers(modifier.public,modifier.static)\n                .returns(int.class)\n                .addparameter(int.class,"a")\n                .addparameter(int.class,"b")\n                .addstatement("return a + b")\n                .build();\n\n        //构造一个类\n        typespec hello = typespec.classbuilder("hello")\n                .addmodifiers(modifier.public)\n                .addmethod(main)\n                .addmethod(add)\n                .build();\n\n        //生成一个java文件\n        javafile javafile = javafile.builder("com.poet.demo",hello).build();\n\n        //将java写到当前项目中\n        javafile.writeto(system.out);   //打印到命令行中\n\n        file file = new file("./src/");\n        if (file.exists()) {\n            file.delete();\n        }\n        javafile.writeto(file);\n\n        thread.sleep(3000);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n直接看来，这些代码也是很容易让人看懂的，我们还是来了解一下各自的用法吧\n\n\n# 关键字及作用\n\n类                含义\nmethodspec       代表一个构造函数或方法声明\ntypespec         代表一个类，接口，或者枚举声明\nfieldspec        代表一个成员变量，一个字段声明\njavafile         包含一个顶级类的java文件\nparameterspec    用来创建参数\nannotationspec   用来创建注解\ntypename         类型，如在添加返回值类型是使用 typename.void\nclassname        用来包装一个类\n\n\n\n\n# 占位符\n\n占位符   含义\n$l    参数\n$s    字符串的模板,将指定的字符串替换到$s的地方\n$n    $n在javapoet中代指的是一个名称，例如调用的方法名称，变量名称，这一类存在意思的名称\n$t    $t\n      在javapoet代指的是typename，该模板主要将class抽象出来，用传入的typename指向的class来代替\n\n\n# 官方文档\n\n# 花括号\n\n比如，我们想实现这样的一个类的代码\n\nvoid main() {\n  int total = 0;\n  for (int i = 0; i < 10; i++) {\n    total += i;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n按照上面的写法，我们的代码是这样子的\n\nmethodspec main = methodspec.methodbuilder("main")\n    .addcode(""\n        + "int total = 0;\\n"\n        + "for (int i = 0; i < 10; i++) {\\n"\n        + "  total += i;\\n"\n        + "}\\n")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是，这样子看起来很很不友好。\n\n那么我们可以这么改\n\nmethodspec main = methodspec.methodbuilder("main")\n    .addstatement("int total = 0")\n    .begincontrolflow("for (int i = 0; i < 10; i++)")\n    .addstatement("total += i")\n    .endcontrolflow()\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n所以，我们实现这样子的代码\n\nint multiply10to20() {\n  int result = 1;\n  for (int i = 10; i < 20; i++) {\n    result = result * i;\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n只需要这么写\n\nprivate methodspec computerange(string name, int from, int to, string op) {\n  return methodspec.methodbuilder(name)\n      .returns(int.class)\n      .addstatement("int result = 1")\n      .begincontrolflow("for (int i = " + from + "; i < " + to + "; i++)")\n      .addstatement("result = result " + op + " i")\n      .endcontrolflow()\n      .addstatement("return result")\n      .build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n即可。\n\n# 多个花括号\n\n如果我们要实现如下的代码\n\nvoid main() {\n  long now = system.currenttimemillis();\n  if (system.currenttimemillis() < now)  {\n    system.out.println("time travelling, woo hoo!");\n  } else if (system.currenttimemillis() == now) {\n    system.out.println("time stood still!");\n  } else {\n    system.out.println("ok, time still moving forward");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们要这么写\n\nmethodspec main = methodspec.methodbuilder("main")\n    .addstatement("long now = $t.currenttimemillis()", system.class)\n    .begincontrolflow("if ($t.currenttimemillis() < now)", system.class)\n    .addstatement("$t.out.println($s)", system.class, "time travelling, woo hoo!")\n    .nextcontrolflow("else if ($t.currenttimemillis() == now)", system.class)\n    .addstatement("$t.out.println($s)", system.class, "time stood still!")\n    .nextcontrolflow("else")\n    .addstatement("$t.out.println($s)", system.class, "ok, time still moving forward")\n    .endcontrolflow()\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n那么，实现\n\nvoid main() {\n  try {\n    throw new exception("failed");\n  } catch (exception e) {\n    throw new runtimeexception(e);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n就可以这么写了\n\nmethodspec main = methodspec.methodbuilder("main")\n    .begincontrolflow("try")\n    .addstatement("throw new exception($s)", "failed")\n    .nextcontrolflow("catch ($t e)", exception.class)\n    .addstatement("throw new $t(e)", runtimeexception.class)\n    .endcontrolflow()\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 占位符$l\n\n如下\n\nprivate methodspec computerange(string name, int from, int to, string op) {\n  return methodspec.methodbuilder(name)\n      .returns(int.class)\n      .addstatement("int result = 0")\n      .begincontrolflow("for (int i = $l; i < $l; i++)", from, to)\n      .addstatement("result = result $l i", op)\n      .endcontrolflow()\n      .addstatement("return result")\n      .build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 占位符$s\n\n如下\n\npublic static void main(string[] args) throws exception {\n  typespec helloworld = typespec.classbuilder("helloworld")\n      .addmodifiers(modifier.public, modifier.final)\n      .addmethod(whatsmyname("slimshady"))\n      .addmethod(whatsmyname("eminem"))\n      .addmethod(whatsmyname("marshallmathers"))\n      .build();\n\n  javafile javafile = javafile.builder("com.example.helloworld", helloworld)\n      .build();\n\n  javafile.writeto(system.out);\n}\n\nprivate static methodspec whatsmyname(string name) {\n  return methodspec.methodbuilder(name)\n      .returns(string.class)\n      .addstatement("return $s", name)\n      .build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n生成的代码为\n\npublic final class helloworld {\n  string slimshady() {\n    return "slimshady";\n  }\n\n  string eminem() {\n    return "eminem";\n  }\n\n  string marshallmathers() {\n    return "marshallmathers";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 占位符$l\n\n如下\n\nmethodspec today = methodspec.methodbuilder("today")\n    .returns(date.class)\n    .addstatement("return new $t()", date.class)\n    .build();\n\ntypespec helloworld = typespec.classbuilder("helloworld")\n    .addmodifiers(modifier.public, modifier.final)\n    .addmethod(today)\n    .build();\n\njavafile javafile = javafile.builder("com.example.helloworld", helloworld)\n    .build();\n\njavafile.writeto(system.out);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport java.util.date;\n\npublic final class helloworld {\n  date today() {\n    return new date();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n此处我们返回的是java环境中有的类，如果返回的不是已经运行的类，我们需要这么写\n\nclassname hoverboard = classname.get("com.mattel", "hoverboard");\n\nmethodspec today = methodspec.methodbuilder("tomorrow")\n    .returns(hoverboard)\n    .addstatement("return new $t()", hoverboard)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport com.mattel.hoverboard;\n\npublic final class helloworld {\n  hoverboard tomorrow() {\n    return new hoverboard();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n也可以表示多个\n\nclassname hoverboard = classname.get("com.mattel", "hoverboard");\nclassname list = classname.get("java.util", "list");\nclassname arraylist = classname.get("java.util", "arraylist");\ntypename listofhoverboards = parameterizedtypename.get(list, hoverboard);\n\nmethodspec beyond = methodspec.methodbuilder("beyond")\n    .returns(listofhoverboards)\n    .addstatement("$t result = new $t<>()", listofhoverboards, arraylist)\n    .addstatement("result.add(new $t())", hoverboard)\n    .addstatement("result.add(new $t())", hoverboard)\n    .addstatement("result.add(new $t())", hoverboard)\n    .addstatement("return result")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport com.mattel.hoverboard;\nimport java.util.arraylist;\nimport java.util.list;\n\npublic final class helloworld {\n  list<hoverboard> beyond() {\n    list<hoverboard> result = new arraylist<>();\n    result.add(new hoverboard());\n    result.add(new hoverboard());\n    result.add(new hoverboard());\n    return result;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n静态导入\n\nclassname namedboards = classname.get("com.mattel", "hoverboard", "boards");\n\nmethodspec beyond = methodspec.methodbuilder("beyond")\n    .returns(listofhoverboards)\n    .addstatement("$t result = new $t<>()", listofhoverboards, arraylist)\n    .addstatement("result.add($t.createnimbus(2000))", hoverboard)\n    .addstatement("result.add($t.createnimbus(\\"2001\\"))", hoverboard)\n    .addstatement("result.add($t.createnimbus($t.thunderbolt))", hoverboard, namedboards)\n    .addstatement("$t.sort(result)", collections.class)\n    .addstatement("return result.isempty() ? $t.emptylist() : result", collections.class)\n    .build();\n\ntypespec hello = typespec.classbuilder("helloworld")\n    .addmethod(beyond)\n    .build();\n\njavafile.builder("com.example.helloworld", hello)\n    .addstaticimport(hoverboard, "createnimbus")\n    .addstaticimport(namedboards, "*")\n    .addstaticimport(collections.class, "*")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n生成的代码\n\npackage com.example.helloworld;\n\nimport static com.mattel.hoverboard.boards.*;\nimport static com.mattel.hoverboard.createnimbus;\nimport static java.util.collections.*;\n\nimport com.mattel.hoverboard;\nimport java.util.arraylist;\nimport java.util.list;\n\nclass helloworld {\n  list<hoverboard> beyond() {\n    list<hoverboard> result = new arraylist<>();\n    result.add(createnimbus(2000));\n    result.add(createnimbus("2001"));\n    result.add(createnimbus(thunderbolt));\n    sort(result);\n    return result.isempty() ? emptylist() : result;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 占位符$n\n\n我们要生成如下的代码\n\npublic string bytetohex(int b) {\n  char[] result = new char[2];\n  result[0] = hexdigit((b >>> 4) & 0xf);\n  result[1] = hexdigit(b & 0xf);\n  return new string(result);\n}\n\npublic char hexdigit(int i) {\n  return (char) (i < 10 ? i + \'0\' : i - 10 + \'a\');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们可以这么写\n\nmethodspec hexdigit = methodspec.methodbuilder("hexdigit")\n    .addparameter(int.class, "i")\n    .returns(char.class)\n    .addstatement("return (char) (i < 10 ? i + \'0\' : i - 10 + \'a\')")\n    .build();\n\nmethodspec bytetohex = methodspec.methodbuilder("bytetohex")\n    .addparameter(int.class, "b")\n    .returns(string.class)\n    .addstatement("char[] result = new char[2]")\n    .addstatement("result[0] = $n((b >>> 4) & 0xf)", hexdigit)\n    .addstatement("result[1] = $n(b & 0xf)", hexdigit)\n    .addstatement("return new string(result)")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# methods\n\nmethodspec flux = methodspec.methodbuilder("flux")\n    .addmodifiers(modifier.abstract, modifier.protected)\n    .build();\n\ntypespec helloworld = typespec.classbuilder("helloworld")\n    .addmodifiers(modifier.public, modifier.abstract)\n    .addmethod(flux)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n生成\n\npublic abstract class helloworld {\n  protected abstract void flux();\n}\n\n\n1\n2\n3\n\n\n# constructors\n\nmethodspec flux = methodspec.constructorbuilder()\n    .addmodifiers(modifier.public)\n    .addparameter(string.class, "greeting")\n    .addstatement("this.$n = $n", "greeting", "greeting")\n    .build();\n\ntypespec helloworld = typespec.classbuilder("helloworld")\n    .addmodifiers(modifier.public)\n    .addfield(string.class, "greeting", modifier.private, modifier.final)\n    .addmethod(flux)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n生成\n\npublic class helloworld {\n  private final string greeting;\n\n  public helloworld(string greeting) {\n    this.greeting = greeting;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# parameters\n\nparameterspec android = parameterspec.builder(string.class, "android")\n    .addmodifiers(modifier.final)\n    .build();\n\nmethodspec welcomeoverlords = methodspec.methodbuilder("welcomeoverlords")\n    .addparameter(android)\n    .addparameter(string.class, "robot", modifier.final)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n生成\n\nvoid welcomeoverlords(final string android, final string robot) {\n}\n\n\n1\n2\n\n\n# fields\n\nfieldspec android = fieldspec.builder(string.class, "android")\n    .addmodifiers(modifier.private, modifier.final)\n    .build();\n\ntypespec helloworld = typespec.classbuilder("helloworld")\n    .addmodifiers(modifier.public)\n    .addfield(android)\n    .addfield(string.class, "robot", modifier.private, modifier.final)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生成\n\npublic class helloworld {\n  private final string android;\n\n  private final string robot;\n}\n\n\n1\n2\n3\n4\n5\n\n\n还有\n\nfieldspec android = fieldspec.builder(string.class, "android")\n    .addmodifiers(modifier.private, modifier.final)\n    .initializer("$s + $l", "lollipop v.", 5.0d)\n    .build();\n\n\n1\n2\n3\n4\n\n\n生成\n\nprivate final string android = "lollipop v." + 5.0;\n\n\n1\n\n\n# interfaces\n\ntypespec helloworld = typespec.interfacebuilder("helloworld")\n    .addmodifiers(modifier.public)\n    .addfield(fieldspec.builder(string.class, "only_thing_that_is_constant")\n        .addmodifiers(modifier.public, modifier.static, modifier.final)\n        .initializer("$s", "change")\n        .build())\n    .addmethod(methodspec.methodbuilder("beep")\n        .addmodifiers(modifier.public, modifier.abstract)\n        .build())\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n生成\n\npublic interface helloworld {\n  string only_thing_that_is_constant = "change";\n\n  void beep();\n}\n\n\n1\n2\n3\n4\n5\n\n\n# enums\n\ntypespec helloworld = typespec.enumbuilder("roshambo")\n    .addmodifiers(modifier.public)\n    .addenumconstant("rock")\n    .addenumconstant("scissors")\n    .addenumconstant("paper")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n生成\n\npublic enum roshambo {\n  rock,\n\n  scissors,\n\n  paper\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如：\n\ntypespec helloworld = typespec.enumbuilder("roshambo")\n    .addmodifiers(modifier.public)\n    .addenumconstant("rock", typespec.anonymousclassbuilder("$s", "fist")\n        .addmethod(methodspec.methodbuilder("tostring")\n            .addannotation(override.class)\n            .addmodifiers(modifier.public)\n            .addstatement("return $s", "avalanche!")\n            .returns(string.class)\n            .build())\n        .build())\n    .addenumconstant("scissors", typespec.anonymousclassbuilder("$s", "peace")\n        .build())\n    .addenumconstant("paper", typespec.anonymousclassbuilder("$s", "flat")\n        .build())\n    .addfield(string.class, "handsign", modifier.private, modifier.final)\n    .addmethod(methodspec.constructorbuilder()\n        .addparameter(string.class, "handsign")\n        .addstatement("this.$n = $n", "handsign", "handsign")\n        .build())\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n生成\n\npublic enum roshambo {\n  rock("fist") {\n    @override\n    public string tostring() {\n      return "avalanche!";\n    }\n  },\n\n  scissors("peace"),\n\n  paper("flat");\n\n  private final string handsign;\n\n  roshambo(string handsign) {\n    this.handsign = handsign;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# anonymous inner classes\n\ntypespec comparator = typespec.anonymousclassbuilder("")\n    .addsuperinterface(parameterizedtypename.get(comparator.class, string.class))\n    .addmethod(methodspec.methodbuilder("compare")\n        .addannotation(override.class)\n        .addmodifiers(modifier.public)\n        .addparameter(string.class, "a")\n        .addparameter(string.class, "b")\n        .returns(int.class)\n        .addstatement("return $n.length() - $n.length()", "a", "b")\n        .build())\n    .build();\n\ntypespec helloworld = typespec.classbuilder("helloworld")\n    .addmethod(methodspec.methodbuilder("sortbylength")\n        .addparameter(parameterizedtypename.get(list.class, string.class), "strings")\n        .addstatement("$t.sort($n, $l)", collections.class, "strings", comparator)\n        .build())\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n生成\n\nvoid sortbylength(list<string> strings) {\n  collections.sort(strings, new comparator<string>() {\n    @override\n    public int compare(string a, string b) {\n      return a.length() - b.length();\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# annotations\n\nmethodspec tostring = methodspec.methodbuilder("tostring")\n    .addannotation(override.class)\n    .returns(string.class)\n    .addmodifiers(modifier.public)\n    .addstatement("return $s", "hoverboard")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n\n\n生成\n\n  @override\n  public string tostring() {\n    return "hoverboard";\n  }\n\n\n1\n2\n3\n4\n\n\n还有\n\nmethodspec logrecord = methodspec.methodbuilder("recordevent")\n    .addmodifiers(modifier.public, modifier.abstract)\n    .addannotation(annotationspec.builder(headers.class)\n        .addmember("accept", "$s", "application/json; charset=utf-8")\n        .addmember("useragent", "$s", "square cash")\n        .build())\n    .addparameter(logrecord.class, "logrecord")\n    .returns(logreceipt.class)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生成\n\n@headers(\n    accept = "application/json; charset=utf-8",\n    useragent = "square cash"\n)\nlogreceipt recordevent(logrecord logrecord);\n\n\n1\n2\n3\n4\n5\n\n\nmethodspec logrecord = methodspec.methodbuilder("recordevent")\n    .addmodifiers(modifier.public, modifier.abstract)\n    .addannotation(annotationspec.builder(headerlist.class)\n        .addmember("value", "$l", annotationspec.builder(header.class)\n            .addmember("name", "$s", "accept")\n            .addmember("value", "$s", "application/json; charset=utf-8")\n            .build())\n        .addmember("value", "$l", annotationspec.builder(header.class)\n            .addmember("name", "$s", "user-agent")\n            .addmember("value", "$s", "square cash")\n            .build())\n        .build())\n    .addparameter(logrecord.class, "logrecord")\n    .returns(logreceipt.class)\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n生成\n\n@headerlist({\n    @header(name = "accept", value = "application/json; charset=utf-8"),\n    @header(name = "user-agent", value = "square cash")\n})\nlogreceipt recordevent(logrecord logrecord);\n\n\n1\n2\n3\n4\n5\n\n\n# javadoc\n\nmethodspec dismiss = methodspec.methodbuilder("dismiss")\n    .addjavadoc("hides {@code message} from the caller\'s history. other\\n"\n        + "participants in the conversation will continue to see the\\n"\n        + "message in their own history unless they also delete it.\\n")\n    .addjavadoc("\\n")\n    .addjavadoc("<p>use {@link #delete($t)} to delete the entire\\n"\n        + "conversation for all participants.\\n", conversation.class)\n    .addmodifiers(modifier.public, modifier.abstract)\n    .addparameter(message.class, "message")\n    .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n生成\n\n  /**\n   * hides {@code message} from the caller\'s history. other\n   * participants in the conversation will continue to see the\n   * message in their own history unless they also delete it.\n   *\n   * <p>use {@link #delete(conversation)} to delete the entire\n   * conversation for all participants.\n   */\n  void dismiss(message message);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"10/17/2022",lastUpdatedTimestamp:1665997159e3},{title:"Java反射",frontmatter:{title:"Java反射",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/8f05cf/",categories:["编程基础","Java"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/07.Java/01.Java%E5%8F%8D%E5%B0%84.html",relativePath:"01.编程基础/07.Java/01.Java反射.md",key:"v-d0b19c14",path:"/pages/8f05cf/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:3,title:"怎么得到Class的对象",slug:"怎么得到class的对象",normalizedTitle:"怎么得到class的对象",charIndex:83},{level:3,title:"基本类型的字节码",slug:"基本类型的字节码",normalizedTitle:"基本类型的字节码",charIndex:1103},{level:2,title:"反射深入分析",slug:"反射深入分析",normalizedTitle:"反射深入分析",charIndex:1293},{level:3,title:"什么是反射？",slug:"什么是反射",normalizedTitle:"什么是反射？",charIndex:1304},{level:4,title:"类构造函数的反射 Constructor",slug:"类构造函数的反射-constructor",normalizedTitle:"类构造函数的反射 constructor",charIndex:1676},{level:4,title:"类成员变量的反射 Filed",slug:"类成员变量的反射-filed",normalizedTitle:"类成员变量的反射 filed",charIndex:2337},{level:4,title:"类成员方法的反射 Method",slug:"类成员方法的反射-method",normalizedTitle:"类成员方法的反射 method",charIndex:4044},{level:5,title:"数组与反射",slug:"数组与反射",normalizedTitle:"数组与反射",charIndex:4861}],headersStr:"概述 怎么得到Class的对象 基本类型的字节码 反射深入分析 什么是反射？ 类构造函数的反射 Constructor 类成员变量的反射 Filed 类成员方法的反射 Method 数组与反射",content:'# 概述\n\n我们很多时候是不知道一个类的内部是如何实现的，但是我们需要用到它的一些方法，这个时候怎么办咧，我们这个时候就需要用到反射来得到我们需要的东西了。\n\n\n# 怎么得到Class的对象\n\nClass的实例对象就是内存中的一份字节码，或者说内存中的一份字节码对应Class的一个实例对象。现在解释一下什么是字节码？\n\n我们常说JAVA编译后，会变成.class文件，而这里所说的字节码就是一个类编译而成的二进制代码，比如：\n\n要得到Person对象时，是要先得到Person类的一份字节码（如果JVM中没有，需要先加载，如果有，可以直接返回）;\n\n要得到Set对象时，是要先得到Set类的一份字节码;\n\n要得到Math对象时，是要先得到Math类的一份字节码。\n\n注意：每个类的字节码，在内存中只有一份，每一份字节码就是一个Class的实例对象，比如要得到Person的字节码，可以有下面三种写法\n\nClass p=Person.class; \n“Person.class”就代表Person的字节码，“Person.class”的所属类型的Class\n\nClass.forName("类的全路径名");\n\n对象名.getClass();\n\n\n1\n2\n3\n4\n5\n6\n\n\n如：\n\n    String str = "abc";\n\t\t\n\t//first way to get the class\n\tClass cls = String.class;\n\t\t\n\t//second way to get the class\n\tClass cls2 = str.getClass();\n\t\t\n\t//thirdly way to get the class\n\tClass cls3 = Class.forName("java.lang.String");\n\t\t\n\tClass cls4 = char.class;\n\tSystem.out.println("The result:");\n\tSystem.out.println(cls == cls2);\n\tSystem.out.println(cls == cls3);\n\tSystem.out.println(cls.isPrimitive());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n运行结果为：\n\nThe result:\ntrue\ntrue\nfalse\ntrue\n\n\n1\n2\n3\n4\n5\n\n\n从结果可以看出，每个类的字节码，在内存中只有一份，无论你用三种方式的哪一种方式去取，得到的都是同一份字节码\n\n\n# 基本类型的字节码\n\nJava中有八种基本类型，所对应的字节码是基本数据类型的字节码，在程序中，可以种Class的isPrimitive()方法来判断它是不是基本数据类型的字节码。\n\n值得一提的是，int[].class这不是基本数据类型的字节码，因为这是数组类型，当调用isArray的时候返回true。\n\n说了这么多，还是没有看到关于反射的字眼，现在我们就开始谈谈反射\n\n\n# 反射深入分析\n\n\n# 什么是反射？\n\n定义：反射就是把JAVA类中的各种成分映射成映射成相应的JAVA类。\n\n我们知道，一个类中可以有成员变量，成员方法，构造方法等信息，这些信息就用相应的类的实例对象来表示。\n\n在反射中，有一些类用来表示反射以后类中的成分，比如：Filed，Method，Constructor,Package。\n\n比如：System类中，有System.exit(),System.getProperties(),不管你的类中有什么方法，都可以用反射中Method来表示。\n\n我们知道，一个类中可以有成员变量，成员方法，构造方法等信息，这些信息就用相应的类的实例对象来表示。\n\n在反射中，有一些类用来表示反射以后类中的成分，比如：Filed，Method，Constructor,Package。\n\n首先，我们从类的入口出发，开始学习反射\n\n# 类构造函数的反射 Constructor\n\nConstructor代表某一个类的构造方法 那么怎么得到一个类的构造方法？ 可以先拿到这个类的CLass实例对象（这个类的字节码），实例对象中有两个方法。 得到类的一个构造函数的方法\n\npublic Constructor getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException,SecurityException\n\n通过参数类型，得到想要的构造函数，因为接收的是可变参数，所以可以传多个，比如：想得到String的String（StringBuffer buf）的构造方法，可以这么写：StringString.class.getConstructor(StringBuffer.class);\n\n如：\n\n    Constructor<String> construct =\n\tString.class.getConstructor(StringBuffer.class);\n\tConstructor<String> construct1 = String.class.getConstructor(char[].class);\n\tString result = construct1.newInstance(new char[]{\'a\',\'b\',\'v\'});\n\tSystem.out.println(result);\n\n\n1\n2\n3\n4\n5\n\n\n运行结果\n\nabv\n\n\n1\n\n\n# 类成员变量的反射 Filed\n\n如：\n\nclass Point{\n\tprivate int x;\n\tpublic int y;\n\tpublic Point(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\t}\n}\n\npublic static void main(String[] args) throws Exception {\n\t\t\t\t\n\t\tPoint p1=new Point(5, 39);\n\t\tPoint p2=new Point(3, 9);\n\t\t\t\t\t</span>\n\t\t<span style="font-size:14px;">//对公有成员变量\n\t\tField fieldY = p1.getClass().getField("y");\t\n\t\tint y = (int) fieldY.get(p1);//取对应p1对象的y字段的值，必须要有对象。\n\t\tSystem.out.println(y);\n\t\t\t\t\n\t\t//对私有成员变量，可以进行暴力反射\n\t\tField fieldX = p1.getClass().getDeclaredField("x");\n\t\tfieldX.setAccessible(true);//暴力反射\n\t\tint x = (int) fieldX.get(p1);//取对应p1对象的x字段的值\n\t\tSystem.out.println(x);\t\t\t\t\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n又或者这样\n\nclass Person{\n\tprivate String name;\n\tprivate int age ;\n\tprivate String nickName;\n\tpublic Person(String name, int age, String nickName) {\n\t\t super();\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.nickName = nickName;\n\t\t}\n\t\t\t\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t return "Person [name=" + name + ", age=" + age + ", nickName="+ nickName + "]";\n\t\t}\n}\n\npublic static void main(String[] args) throws Exception {\n\t\t\t\t\t\t\n\t\tPerson p=new Person("zhangsan", 25, "Amao");\t\t\n\t\t//得到字节码,通过字节码得到这个类的所有方法\n\t\tField[] fields = p.getClass().getDeclaredFields();\n\t\t\tfor(Field field:fields){\n\t\t\t//因为一个类的字节码在内存中只有一份，所以用==比较更专业，此处用==，不用equals（）\n\t\t\t\tif(field.getType()==String.class){\n\t\t\t\t\tfield.setAccessible(true);//进行暴力反射\n\t\t\t\t\tString oldValue = (String) field.get(p);//获得字段的值\n\t\t\t\t\tString newValue =oldValue.replace("a", "A");\n\t\t\t\t\tfield.set(p, newValue);\n\t\t\t\t\tSystem.out.println(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 类成员方法的反射 Method\n\n比如：想调用String类中的chatAt(int i)这个方法，该怎么么办呢？ public Method getMethod(String name, Class<?>... parameterTypes)hrows NoSuchMethodException,SecurityException\n\n参数说明： name：这个表示方法的名字 parameterTypes：这个参数的作用表示调用哪个方法，因为重载的原因，一个类中同名的方法可能不止一个 对于上面的问题，我们可以这样做。 Method myStrCharAt=String.class.getMethod("charAt",int.class);\n\n如：\n\npublic class MethodReflect {\n \n\tpublic static void main(String[] args) throws Exception{\n\t\tString str="abcdef";\n\t\t\t\t\n\t\tMethod strMethod = str.getClass().getMethod("charAt", int.class);\n\t\t\t\t\n\t\t//得到方法之后，调用对象str的chatAt方法；\n\t\tchar result = (char) strMethod.invoke(str, 1);\n\t\t\t\n\t\tSystem.out.println(result);//结果是b\n\t}\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当一个类XXX，我们已经通过反射得到它的方法xxxMethod，那么看下面一行代码 xxxMethod.invoke(null, 1);\n\n这表示不知道谁的xxxMethod方法，因为传递的是null，说明调用的这个方法是属于类的，就是静态方法，所以就不需要传递参数了。\n\n# 数组与反射\n\n数组在 Java 语言中是一种特殊的类类型，一个数组的引用可以赋给 Object 引用。观察下面的例子看看数组是怎么工作的：\n\nimport java.lang.reflect.*;  \npublic class Array1 { \n   public static void main(String args[]) { \n      try { \n           Class cls = Class.forName("java.lang.String"); \n           Object arr = Array.newInstance(cls, 10); \n           Array.set(arr, 5, "this is a test"); \n           String s = (String) Array.get(arr, 5); \n           System.out.println(s); \n      } \n      catch (Throwable e) { \n           System.err.println(e); \n      } \n   } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n例中创建了 10 个单位长度的 String 数组，为第 5 个位置的字符串赋了值，最后将这个字符串从数组中取得并打印了出来。',normalizedContent:'# 概述\n\n我们很多时候是不知道一个类的内部是如何实现的，但是我们需要用到它的一些方法，这个时候怎么办咧，我们这个时候就需要用到反射来得到我们需要的东西了。\n\n\n# 怎么得到class的对象\n\nclass的实例对象就是内存中的一份字节码，或者说内存中的一份字节码对应class的一个实例对象。现在解释一下什么是字节码？\n\n我们常说java编译后，会变成.class文件，而这里所说的字节码就是一个类编译而成的二进制代码，比如：\n\n要得到person对象时，是要先得到person类的一份字节码（如果jvm中没有，需要先加载，如果有，可以直接返回）;\n\n要得到set对象时，是要先得到set类的一份字节码;\n\n要得到math对象时，是要先得到math类的一份字节码。\n\n注意：每个类的字节码，在内存中只有一份，每一份字节码就是一个class的实例对象，比如要得到person的字节码，可以有下面三种写法\n\nclass p=person.class; \n“person.class”就代表person的字节码，“person.class”的所属类型的class\n\nclass.forname("类的全路径名");\n\n对象名.getclass();\n\n\n1\n2\n3\n4\n5\n6\n\n\n如：\n\n    string str = "abc";\n\t\t\n\t//first way to get the class\n\tclass cls = string.class;\n\t\t\n\t//second way to get the class\n\tclass cls2 = str.getclass();\n\t\t\n\t//thirdly way to get the class\n\tclass cls3 = class.forname("java.lang.string");\n\t\t\n\tclass cls4 = char.class;\n\tsystem.out.println("the result:");\n\tsystem.out.println(cls == cls2);\n\tsystem.out.println(cls == cls3);\n\tsystem.out.println(cls.isprimitive());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n运行结果为：\n\nthe result:\ntrue\ntrue\nfalse\ntrue\n\n\n1\n2\n3\n4\n5\n\n\n从结果可以看出，每个类的字节码，在内存中只有一份，无论你用三种方式的哪一种方式去取，得到的都是同一份字节码\n\n\n# 基本类型的字节码\n\njava中有八种基本类型，所对应的字节码是基本数据类型的字节码，在程序中，可以种class的isprimitive()方法来判断它是不是基本数据类型的字节码。\n\n值得一提的是，int[].class这不是基本数据类型的字节码，因为这是数组类型，当调用isarray的时候返回true。\n\n说了这么多，还是没有看到关于反射的字眼，现在我们就开始谈谈反射\n\n\n# 反射深入分析\n\n\n# 什么是反射？\n\n定义：反射就是把java类中的各种成分映射成映射成相应的java类。\n\n我们知道，一个类中可以有成员变量，成员方法，构造方法等信息，这些信息就用相应的类的实例对象来表示。\n\n在反射中，有一些类用来表示反射以后类中的成分，比如：filed，method，constructor,package。\n\n比如：system类中，有system.exit(),system.getproperties(),不管你的类中有什么方法，都可以用反射中method来表示。\n\n我们知道，一个类中可以有成员变量，成员方法，构造方法等信息，这些信息就用相应的类的实例对象来表示。\n\n在反射中，有一些类用来表示反射以后类中的成分，比如：filed，method，constructor,package。\n\n首先，我们从类的入口出发，开始学习反射\n\n# 类构造函数的反射 constructor\n\nconstructor代表某一个类的构造方法 那么怎么得到一个类的构造方法？ 可以先拿到这个类的class实例对象（这个类的字节码），实例对象中有两个方法。 得到类的一个构造函数的方法\n\npublic constructor getconstructor(class<?>... parametertypes) throws nosuchmethodexception,securityexception\n\n通过参数类型，得到想要的构造函数，因为接收的是可变参数，所以可以传多个，比如：想得到string的string（stringbuffer buf）的构造方法，可以这么写：stringstring.class.getconstructor(stringbuffer.class);\n\n如：\n\n    constructor<string> construct =\n\tstring.class.getconstructor(stringbuffer.class);\n\tconstructor<string> construct1 = string.class.getconstructor(char[].class);\n\tstring result = construct1.newinstance(new char[]{\'a\',\'b\',\'v\'});\n\tsystem.out.println(result);\n\n\n1\n2\n3\n4\n5\n\n\n运行结果\n\nabv\n\n\n1\n\n\n# 类成员变量的反射 filed\n\n如：\n\nclass point{\n\tprivate int x;\n\tpublic int y;\n\tpublic point(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\t}\n}\n\npublic static void main(string[] args) throws exception {\n\t\t\t\t\n\t\tpoint p1=new point(5, 39);\n\t\tpoint p2=new point(3, 9);\n\t\t\t\t\t</span>\n\t\t<span style="font-size:14px;">//对公有成员变量\n\t\tfield fieldy = p1.getclass().getfield("y");\t\n\t\tint y = (int) fieldy.get(p1);//取对应p1对象的y字段的值，必须要有对象。\n\t\tsystem.out.println(y);\n\t\t\t\t\n\t\t//对私有成员变量，可以进行暴力反射\n\t\tfield fieldx = p1.getclass().getdeclaredfield("x");\n\t\tfieldx.setaccessible(true);//暴力反射\n\t\tint x = (int) fieldx.get(p1);//取对应p1对象的x字段的值\n\t\tsystem.out.println(x);\t\t\t\t\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n又或者这样\n\nclass person{\n\tprivate string name;\n\tprivate int age ;\n\tprivate string nickname;\n\tpublic person(string name, int age, string nickname) {\n\t\t super();\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.nickname = nickname;\n\t\t}\n\t\t\t\t\t\n\t\t@override\n\t\tpublic string tostring() {\n\t\t\t return "person [name=" + name + ", age=" + age + ", nickname="+ nickname + "]";\n\t\t}\n}\n\npublic static void main(string[] args) throws exception {\n\t\t\t\t\t\t\n\t\tperson p=new person("zhangsan", 25, "amao");\t\t\n\t\t//得到字节码,通过字节码得到这个类的所有方法\n\t\tfield[] fields = p.getclass().getdeclaredfields();\n\t\t\tfor(field field:fields){\n\t\t\t//因为一个类的字节码在内存中只有一份，所以用==比较更专业，此处用==，不用equals（）\n\t\t\t\tif(field.gettype()==string.class){\n\t\t\t\t\tfield.setaccessible(true);//进行暴力反射\n\t\t\t\t\tstring oldvalue = (string) field.get(p);//获得字段的值\n\t\t\t\t\tstring newvalue =oldvalue.replace("a", "a");\n\t\t\t\t\tfield.set(p, newvalue);\n\t\t\t\t\tsystem.out.println(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 类成员方法的反射 method\n\n比如：想调用string类中的chatat(int i)这个方法，该怎么么办呢？ public method getmethod(string name, class<?>... parametertypes)hrows nosuchmethodexception,securityexception\n\n参数说明： name：这个表示方法的名字 parametertypes：这个参数的作用表示调用哪个方法，因为重载的原因，一个类中同名的方法可能不止一个 对于上面的问题，我们可以这样做。 method mystrcharat=string.class.getmethod("charat",int.class);\n\n如：\n\npublic class methodreflect {\n \n\tpublic static void main(string[] args) throws exception{\n\t\tstring str="abcdef";\n\t\t\t\t\n\t\tmethod strmethod = str.getclass().getmethod("charat", int.class);\n\t\t\t\t\n\t\t//得到方法之后，调用对象str的chatat方法；\n\t\tchar result = (char) strmethod.invoke(str, 1);\n\t\t\t\n\t\tsystem.out.println(result);//结果是b\n\t}\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当一个类xxx，我们已经通过反射得到它的方法xxxmethod，那么看下面一行代码 xxxmethod.invoke(null, 1);\n\n这表示不知道谁的xxxmethod方法，因为传递的是null，说明调用的这个方法是属于类的，就是静态方法，所以就不需要传递参数了。\n\n# 数组与反射\n\n数组在 java 语言中是一种特殊的类类型，一个数组的引用可以赋给 object 引用。观察下面的例子看看数组是怎么工作的：\n\nimport java.lang.reflect.*;  \npublic class array1 { \n   public static void main(string args[]) { \n      try { \n           class cls = class.forname("java.lang.string"); \n           object arr = array.newinstance(cls, 10); \n           array.set(arr, 5, "this is a test"); \n           string s = (string) array.get(arr, 5); \n           system.out.println(s); \n      } \n      catch (throwable e) { \n           system.err.println(e); \n      } \n   } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n例中创建了 10 个单位长度的 string 数组，为第 5 个位置的字符串赋了值，最后将这个字符串从数组中取得并打印了出来。',charsets:{cjk:!0},lastUpdated:"10/17/2022",lastUpdatedTimestamp:1665997159e3},{title:"Java集合",frontmatter:{title:"Java集合",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/767133/",categories:["编程基础","Java"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/07.Java/02.Java%E9%9B%86%E5%90%88.html",relativePath:"01.编程基础/07.Java/02.Java集合.md",key:"v-09c5e121",path:"/pages/767133/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:3,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:102},{level:3,title:"List系列",slug:"list系列",normalizedTitle:"list系列",charIndex:481},{level:4,title:"ArrayList",slug:"arraylist",normalizedTitle:"arraylist",charIndex:237},{level:3,title:"Set系列",slug:"set系列",normalizedTitle:"set系列",charIndex:4779},{level:4,title:"Map系列",slug:"map系列",normalizedTitle:"map系列",charIndex:4788},{level:4,title:"什么是 “链表散列”？",slug:"什么是-链表散列",normalizedTitle:"什么是 “链表散列”？",charIndex:4821},{level:4,title:"拉链法与开放地址法相比的缺点：",slug:"拉链法与开放地址法相比的缺点",normalizedTitle:"拉链法与开放地址法相比的缺点：",charIndex:7183},{level:5,title:"拉链法的优点",slug:"拉链法的优点",normalizedTitle:"拉链法的优点",charIndex:7202},{level:5,title:"拉链法的缺点",slug:"拉链法的缺点",normalizedTitle:"拉链法的缺点",charIndex:7597},{level:4,title:"关于hasnmap的源码",slug:"关于hasnmap的源码",normalizedTitle:"关于hasnmap的源码",charIndex:7828},{level:4,title:"容错机制",slug:"容错机制",normalizedTitle:"容错机制",charIndex:7867},{level:5,title:"Fail-Fast 机制",slug:"fail-fast-机制",normalizedTitle:"fail-fast 机制",charIndex:7933},{level:3,title:"HashMap 和 HashTable 区别",slug:"hashmap-和-hashtable-区别",normalizedTitle:"hashmap 和 hashtable 区别",charIndex:9921},{level:3,title:"LinkedHashMap",slug:"linkedhashmap",normalizedTitle:"linkedhashmap",charIndex:329},{level:3,title:"HasnSet",slug:"hasnset",normalizedTitle:"hasnset",charIndex:11654},{level:3,title:"LinkedHashSet",slug:"linkedhashset",normalizedTitle:"linkedhashset",charIndex:189},{level:3,title:"TreeSet",slug:"treeset",normalizedTitle:"treeset",charIndex:210},{level:3,title:"什么是迭代器",slug:"什么是迭代器",normalizedTitle:"什么是迭代器",charIndex:13131},{level:5,title:"Java中的Iterator功能比较简单，并且只能单向移动：",slug:"java中的iterator功能比较简单-并且只能单向移动",normalizedTitle:"java中的iterator功能比较简单，并且只能单向移动：",charIndex:13221},{level:3,title:"源码解读",slug:"源码解读",normalizedTitle:"源码解读",charIndex:13969},{level:4,title:"关于modCount，API解释如下：",slug:"关于modcount-api解释如下",normalizedTitle:"关于modcount，api解释如下：",charIndex:16622},{level:5,title:"Tips:仅仅设置元素的值并不是结构的修改",slug:"tips-仅仅设置元素的值并不是结构的修改",normalizedTitle:"tips:仅仅设置元素的值并不是结构的修改",charIndex:16948}],headersStr:"前言 目录 List系列 ArrayList Set系列 Map系列 什么是 “链表散列”？ 拉链法与开放地址法相比的缺点： 拉链法的优点 拉链法的缺点 关于hasnmap的源码 容错机制 Fail-Fast 机制 HashMap 和 HashTable 区别 LinkedHashMap HasnSet LinkedHashSet TreeSet 什么是迭代器 Java中的Iterator功能比较简单，并且只能单向移动： 源码解读 关于modCount，API解释如下： Tips:仅仅设置元素的值并不是结构的修改",content:'# 前言\n\n几乎所有的java面试都会问到关于集合的问题，事实上，正确的选择集合去存储数据能有效的提升我们程序的执行效率，我们今天就来捋一捋集合中一些常见的集合类它们的实现原理。（结合部分源码）\n\n\n# 目录\n\ngraph TD\nA(Object)--\x3eB(Iterator)\nB--\x3eC(Collection)\nC--\x3eE(Set)\nE--\x3eI(HashSet)\nI--\x3eK(LinkedHashSet)\nE--\x3eJ(TreeSet)\nC--\x3eF(List)\nF--\x3eL(ArrayList)\nF--\x3eM(LinkedList)\nF--\x3eN(Vector)\nB--\x3eD(Map)\nD--\x3eG(HashMap)\nD--\x3eP(Hashtable)\nG--\x3eO(LinkedHashMap)\nD--\x3eH(TreeMap)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到，集合在java中大体分为三大类：\n\n * List\n * Set\n * Map\n\n那么，接下来的分析，我们就按照以上类别依次分析。\n\n\n# List系列\n\n关于这个系列，相信是大家使用的最多的集合类，下面我们依次来分析一下它们的实现原理。\n\n# ArrayList\n\nArrayList内部其实是由数组实现的，我们可以在源码中看到\n\ntransient Object[] elementData; \n\n\n1\n\n\n并且，如果我们不给它分配初始大小，它默认大小为0。我们如果我们分配了大小，那么初始大小就是我们分配的大小值。从下面的代码可以看出\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    transient Object[] elementData;\n    \n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n初始化完成后，我们一般的操作就是新增元素了，在元素总数不超过数组长度时，都很好理解，直接在添加到数组里面即可。但是，如果长度不够了咋办，比如，我们直接初始化的话，容量大小就等于0了，而且java里面的数组长度一旦写死，就无法修改了，那么官方是怎么做的呢？我们直接根据源码来解析吧。\n\n我们先看它的add方法\n\n    private static final int DEFAULT_CAPACITY = 10;\n\n    private int size;\n\n    public boolean add(E e) {\n        //传入现在需要的容量大小\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //写入新的元素到数组里面\n        elementData[size++] = e;\n        return true;\n    }\n\n    private void ensureCapacityInternal(int minCapacity) {\n        //判断当前的数组是否为初始化的空数组\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            //如果是空数组，就将容量修改为10\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        ensureExplicitCapacity(minCapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我们可以看到，它首先判断是否是初始化的空数组，如果是的就给个默认容量10，然后就到了ensureExplicitCapacity方法，我们接着看\n\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // 这里比较我们需要的最小容量和当前容量的大小，如果容量不过，就扩展数组大小\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n    \n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n    \n    private void grow(int minCapacity) {\n        // 记录旧的数组长度\n        int oldCapacity = elementData.length;\n        //新的容量大小为旧的长度*1.5\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //如果新的容量还是小于我们需要的最小容量，那么，就把新的容量的值修改为我们需要的最小容量\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //如果修改之后的新的容量的大小大于Integer.MAX_VALUE - 8\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            //这个方法就是把容量大小改为Integer.MAX_VALUE\n            newCapacity = hugeCapacity(minCapacity);\n        //调用底层的API扩展当前数组的大小\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    \n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n在这个方法里面，我们了解到，每次增加的容量为原来容量的一半，当然，如果接近Int的最大值的时候，我们就需要做一些处理了。\n\n了解完新增的原理之后，我们来看看它的删除的原理\n\n   //根据元素删除\n   public boolean remove(Object o) {\n        //这里我们需要判断一个这个对象是否为null，需要分开处理，因为null无法调用equals方法\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    //直接循环找到第一个符合的元素的下标，然后删除它\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    //直接循环找到第一个符合的元素，然后删除它\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n    \n    //根据下标删除\n    private void fastRemove(int index) {\n        modCount++;\n        //这里得到删除的位置用以判断是否是删除的最后一个元素\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            //不是最后一个元素时，将这个下标之后的元素全部往前移一位\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        //如果是最后一位，直接删除，并释放内存。\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这里可以看到非常细节的一个操作，就是遍历的时候区分null，同时这里也告诉我们，ArrayList是可以存入null值的。\n\n\n# Set系列\n\n# Map系列\n\n分析这个之前，我们需要了解很多一些基础知识。\n\n# 什么是 “链表散列”？\n\n哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n\n记录的存储位置=f(关键字)\n\n这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。\n\n哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。） 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。\n\n数组的特点是：寻址容易，插入和删除困难；\n\n而链表的特点是：寻址困难，插入和删除容易。\n\n那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：\n\n\n\n左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n谈谈我现在的理解，我理解的Hashmap是一个数组带链表，当有key-value进来时，首先得到key的hashcode值，例如：19，然后根据hashmap的容量计算放置的位置，如容量为9，那么计算的结果就为 19%9 = 1，放置的位置就是数组的下标为1的位置。0这个位置是放置key为null的key-value对象。那么现在就会出现一个问题，如果，我们的key为10，经过计算得到10%9 = 1，现在，问题就出现了，位置也是1，那么怎么存放，直接存放会导致之前的数据丢失，但是又不能不存放，这就是典型的hasn冲突了，那么怎么解决咧？我们看看一下几种方式：\n\n * 1.开放定址法：这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：\n\nHi=（H（key）+di）% m i=1，2，…，n\n\n\n1\n\n\n其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：\n\n * 线性探测再散列\n\ndii=1，2，3，…，m-1\n\n\n1\n\n\n这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。\n\n * 二次探测再散列\n\ndi=12，-12，22，-22，…，k2，-k2 ( k<=m/2 )\n\n这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。\n\n伪随机探测再散列\n\ndi=伪随机数序列。\n\n具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。\n\n例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。\n\n如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。\n\n如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。\n\n如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。\n\n * 2.再哈希法 这种方法是同时构造多个不同的哈希函数：\n\nHi=RH1（key） i=1，2，…，k\n\n当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。\n\n * 3.链地址法 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。\n\n * 4.建立公共溢出区 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。\n\n# 拉链法与开放地址法相比的缺点：\n\n# 拉链法的优点\n\n与开放定址法相比，拉链法有如下几个优点：\n\n①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；\n\n②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；\n\n③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；\n\n④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。\n\n# 拉链法的缺点\n\n拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。\n\n结合上面所说的和hashmap的源码，我们重点关注拉链法，我们冲突的元素会放置在对应位置的链表的最后面，这样子，查询的时候，只需要一遍就可以查到结果了。\n\nHashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。那么问题来了？\n\n# 关于hasnmap的源码\n\n大概看了一下，估摸着有点难理解，后面再补上\n\n# 容错机制\n\n因为hashmap是非线程安全的，所以有时候出现多个线程操作的时候，容易导致数据混乱，所以，里面添加了一个容错机制---Fail-Fast 机制\n\n# Fail-Fast 机制\n\n我们知道 java.util.HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。\n\nail-fast 机制是 java 集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。\n\n例如：当某一个线程 A 通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。\n\n这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对 HashMap 内容（当然不仅仅是 HashMap 才会有，其他例如 ArrayList 也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有 modCount++ 这句），那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。\n\nHashIterator() {\n    expectedModCount = modCount;\n    if (size > 0) { // advance to first entry\n    Entry[] t = table;\n    while (index < t.length && (next = t[index++]) == null)  \n        ;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：\n\n注意到 modCount 声明为 volatile，保证线程之间修改的可见性。\n\nfinal Entry<K,V> nextEntry() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n\n\n1\n2\n3\n\n\n在 HashMap 的 API 中指出：\n\n由所有 HashMap 类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。\n\n注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。\n\n解决方案 在上文中也提到，fail-fast 机制，是一种错误检测机制。它只能被用来检测错误，因为 JDK 并不保证 fail-fast 机制一定会发生。若在多线程环境下使用 fail-fast 机制的集合，建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。\n\nHashMap 的两种遍历方式 第一种\n\n　　Map map = new HashMap();\n　　Iterator iter = map.entrySet().iterator();\n　　while (iter.hasNext()) {\n　　Map.Entry entry = (Map.Entry) iter.next();\n　　Object key = entry.getKey();\n　　Object val = entry.getValue();\n　　}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n效率高,以后一定要使用此种方式！\n\n第二种\n\n　　Map map = new HashMap();\n　　Iterator iter = map.keySet().iterator();\n　　while (iter.hasNext()) {\n　　Object key = iter.next();\n　　Object val = map.get(key);\n　　}\n\n\n1\n2\n3\n4\n5\n6\n\n\n效率低,以后尽量少使用！\n\n\n# HashMap 和 HashTable 区别\n\nHashMap 不是线程安全的 HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。\n\nHashTable 是线程安全 Collection。 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。\n\n区别如下： HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。\n\n\n# LinkedHashMap\n\nLinkedHashMap 概述 HashMap 是无序的，HashMap 在 put 的时候是根据 key 的 hashcode 进行 hash 然后放入对应的地方。所以在按照一定顺序 put 进 HashMap 中，然后遍历出 HashMap 的顺序跟 put 的顺序不同（除非在 put 的时候 key 已经按照 hashcode 排序号了，这种几率非常小）\n\nJAVA 在 JDK1.4 以后提供了 LinkedHashMap 来帮助我们实现了有序的 HashMap！\n\nLinkedHashMap 是 HashMap 的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap。\n\nLinkedHashMap 是 Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。\n\nLinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。\n\n注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。\n\n根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。\n\n对于这个类，我的理解为，在hashmap的基础上，把每次添加的节点封装为\n\n    static class Entry<K,V> extends HashMap.Node<K,V> {\n        Entry<K,V> before, after;\n        Entry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看到，新增了before, after两个位置表示前后的位置，这样子，就实现了双向链表的操作。\n\n其它的跟hashmap一样的\n\n\n# HasnSet\n\n內部就是使用hashmap实现的，但是，hasnmap是有key-value的，但是我们使用set只有一个参数，为啥列？我们可以看这个\n\n    private static final Object PRESENT = new Object();\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n\n1\n2\n3\n4\n5\n\n\n我们可以看到，它把我们传入的参数当成key，value就是一个新的Object对象\n\n\n# LinkedHashSet\n\n这个类就是HashSet的子类，但是，HashSet内部是hashmap实现的，如果要一样的话，应该是LinkedHashMap实现的呀，但是，我们看看这个类的代码\n\npublic class LinkedHashSet<E>\n    extends HashSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable {\n\n    private static final long serialVersionUID = -2851667679971038690L;\n\n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor, true);\n    }\n\n    public LinkedHashSet(int initialCapacity) {\n        super(initialCapacity, .75f, true);\n    }\n\n    public LinkedHashSet() {\n        super(16, .75f, true);\n    }\n\n    public LinkedHashSet(Collection<? extends E> c) {\n        super(Math.max(2*c.size(), 11), .75f, true);\n        addAll(c);\n    }\n\n    @Override\n    public Spliterator<E> spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT | Spliterator.ORDERED);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n恩？？？？没有LinkedHashMap呀，莫慌，我们点击\n\n super(16, .75f, true);  \n\n\n1\n\n\n可以看到\n\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap<>(initialCapacity, loadFactor);\n    }\n\n\n1\n2\n3\n\n\n是吧，还是和LinkedHsahMap的实现原理一样的\n\n\n# TreeSet\n\n\n# 什么是迭代器\n\n迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。\n\n# Java中的Iterator功能比较简单，并且只能单向移动：\n\n * (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n\n * (2) 使用next()获得序列中的下一个元素。\n\n * (3) 使用hasNext()检查序列中是否还有元素。\n\n * (4) 使用remove()将迭代器新返回的元素删除。\n\n举个栗子：\n\npublic class Muster {\n \n    public static void main(String[] args) {\n        ArrayList list = new ArrayList();\n        list.add("a");\n        list.add("b");\n        list.add("c");\n        Iterator it = list.iterator();\n        while(it.hasNext()){\n            String str = (String) it.next();\n            System.out.println(str);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果：\n\na\nb\nc\n\n\n1\n2\n3\n\n\n可以看到，Iterator可以不用管底层数据具体是怎样存储的，都能够通过next()遍历整个List。\n\n但是，具体是怎么实现的呢？背后机制究竟如何呢？\n\n\n# 源码解读\n\n这里我们来看看Java里AbstractList实现Iterator的源代码：\n\npublic abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> { // List接口实现了Collection<E>, Iterable<E> \n  \n    protected AbstractList() {  \n    }  \n    \n    ...  \n  \n    public Iterator<E> iterator() {  \n    return new Itr();  // 这里返回一个迭代器\n    }  \n  \n    private class Itr implements Iterator<E> {  // 内部类Itr实现迭代器\n       \n    int cursor = 0;  \n    int lastRet = -1;  \n    int expectedModCount = modCount;    \n    public boolean hasNext() {  // 实现hasNext方法\n            return cursor != size();  \n    }  \n  \n    public E next() {  // 实现next方法\n            checkForComodification();  \n       try {  \n       E next = get(cursor);  \n       lastRet = cursor++;  \n       return next;  \n       } catch (IndexOutOfBoundsException e) {  \n        checkForComodification();  \n        throw new NoSuchElementException();  \n       }  \n    }  \n  \n    public void remove() {  // 实现remove方法\n        if (lastRet == -1)  \n        throw new IllegalStateException();  \n            checkForComodification();  \n  \n        try {  \n        AbstractList.this.remove(lastRet);  \n        if (lastRet < cursor)  \n            cursor--;  \n        lastRet = -1;  \n        expectedModCount = modCount;  \n        } catch (IndexOutOfBoundsException e) {  \n        throw new ConcurrentModificationException();  \n        }  \n    }  \n  \n    final void checkForComodification() {  \n        if (modCount != expectedModCount)  \n        throw new ConcurrentModificationException();  \n    }  \n    }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n可以看到，实现next()是通过get(cursor)，然后cursor++，通过这样实现遍历。\n\n这部分代码不难看懂，唯一难懂的是remove操作里涉及到的expectedModCount = modCount;\n\n在网上查到说这是集合迭代中的一种“快速失败”机制，这种机制提供迭代过程中集合的安全性。 从源代码里可以看到增删操作都会使modCount++，通过和expectedModCount的对比，迭代器可以快速的知道迭代过程中是否存在list.add()类似的操作，存在的话快速失败!\n\n举个栗子：\n\npublic class Muster {\n \n    public static void main(String[] args) {\n        ArrayList list = new ArrayList();\n        list.add("a");\n        list.add("b");\n        list.add("c");\n        Iterator it = list.iterator();\n        while(it.hasNext()){\n            String str = (String) it.next();\n            System.out.println(str);\n            list.add("s");        //添加一个add方法\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果：\n\na\nException in thread "main" java.util.ConcurrentModificationException\n　　at java.util.ArrayList$Itr.checkForComodification(Unknown Source)\n　　at java.util.ArrayList$Itr.next(Unknown Source)\n　　at com.hasse.Muster.main(Muster.java:11)\n\n\n1\n2\n3\n4\n5\n\n\n这就会抛出一个下面的异常，迭代终止。\n\n# 关于modCount，API解释如下：\n\nThe number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\n\n\n1\n\n\n也就是说，modCount记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行迭代产生错误的结果。\n\n# Tips:仅仅设置元素的值并不是结构的修改\n\n我们知道的是ArrayList是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了List就会抛出ConcurrentModificationException，这就是Fail-Fast机制。',normalizedContent:'# 前言\n\n几乎所有的java面试都会问到关于集合的问题，事实上，正确的选择集合去存储数据能有效的提升我们程序的执行效率，我们今天就来捋一捋集合中一些常见的集合类它们的实现原理。（结合部分源码）\n\n\n# 目录\n\ngraph td\na(object)--\x3eb(iterator)\nb--\x3ec(collection)\nc--\x3ee(set)\ne--\x3ei(hashset)\ni--\x3ek(linkedhashset)\ne--\x3ej(treeset)\nc--\x3ef(list)\nf--\x3el(arraylist)\nf--\x3em(linkedlist)\nf--\x3en(vector)\nb--\x3ed(map)\nd--\x3eg(hashmap)\nd--\x3ep(hashtable)\ng--\x3eo(linkedhashmap)\nd--\x3eh(treemap)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到，集合在java中大体分为三大类：\n\n * list\n * set\n * map\n\n那么，接下来的分析，我们就按照以上类别依次分析。\n\n\n# list系列\n\n关于这个系列，相信是大家使用的最多的集合类，下面我们依次来分析一下它们的实现原理。\n\n# arraylist\n\narraylist内部其实是由数组实现的，我们可以在源码中看到\n\ntransient object[] elementdata; \n\n\n1\n\n\n并且，如果我们不给它分配初始大小，它默认大小为0。我们如果我们分配了大小，那么初始大小就是我们分配的大小值。从下面的代码可以看出\n\n    private static final object[] defaultcapacity_empty_elementdata = {};\n\n    transient object[] elementdata;\n    \n    public arraylist() {\n        this.elementdata = defaultcapacity_empty_elementdata;\n    }\n    \n    public arraylist(int initialcapacity) {\n        if (initialcapacity > 0) {\n            this.elementdata = new object[initialcapacity];\n        } else if (initialcapacity == 0) {\n            this.elementdata = empty_elementdata;\n        } else {\n            throw new illegalargumentexception("illegal capacity: "+initialcapacity);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n初始化完成后，我们一般的操作就是新增元素了，在元素总数不超过数组长度时，都很好理解，直接在添加到数组里面即可。但是，如果长度不够了咋办，比如，我们直接初始化的话，容量大小就等于0了，而且java里面的数组长度一旦写死，就无法修改了，那么官方是怎么做的呢？我们直接根据源码来解析吧。\n\n我们先看它的add方法\n\n    private static final int default_capacity = 10;\n\n    private int size;\n\n    public boolean add(e e) {\n        //传入现在需要的容量大小\n        ensurecapacityinternal(size + 1);  // increments modcount!!\n        //写入新的元素到数组里面\n        elementdata[size++] = e;\n        return true;\n    }\n\n    private void ensurecapacityinternal(int mincapacity) {\n        //判断当前的数组是否为初始化的空数组\n        if (elementdata == defaultcapacity_empty_elementdata) {\n            //如果是空数组，就将容量修改为10\n            mincapacity = math.max(default_capacity, mincapacity);\n        }\n        ensureexplicitcapacity(mincapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我们可以看到，它首先判断是否是初始化的空数组，如果是的就给个默认容量10，然后就到了ensureexplicitcapacity方法，我们接着看\n\n    private void ensureexplicitcapacity(int mincapacity) {\n        modcount++;\n        // 这里比较我们需要的最小容量和当前容量的大小，如果容量不过，就扩展数组大小\n        if (mincapacity - elementdata.length > 0)\n            grow(mincapacity);\n    }\n    \n    private static final int max_array_size = integer.max_value - 8;\n    \n    private void grow(int mincapacity) {\n        // 记录旧的数组长度\n        int oldcapacity = elementdata.length;\n        //新的容量大小为旧的长度*1.5\n        int newcapacity = oldcapacity + (oldcapacity >> 1);\n        //如果新的容量还是小于我们需要的最小容量，那么，就把新的容量的值修改为我们需要的最小容量\n        if (newcapacity - mincapacity < 0)\n            newcapacity = mincapacity;\n        //如果修改之后的新的容量的大小大于integer.max_value - 8\n        if (newcapacity - max_array_size > 0)\n            //这个方法就是把容量大小改为integer.max_value\n            newcapacity = hugecapacity(mincapacity);\n        //调用底层的api扩展当前数组的大小\n        elementdata = arrays.copyof(elementdata, newcapacity);\n    }\n    \n    private static int hugecapacity(int mincapacity) {\n        if (mincapacity < 0) // overflow\n            throw new outofmemoryerror();\n        return (mincapacity > max_array_size) ?\n            integer.max_value :\n            max_array_size;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n在这个方法里面，我们了解到，每次增加的容量为原来容量的一半，当然，如果接近int的最大值的时候，我们就需要做一些处理了。\n\n了解完新增的原理之后，我们来看看它的删除的原理\n\n   //根据元素删除\n   public boolean remove(object o) {\n        //这里我们需要判断一个这个对象是否为null，需要分开处理，因为null无法调用equals方法\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementdata[index] == null) {\n                    //直接循环找到第一个符合的元素的下标，然后删除它\n                    fastremove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementdata[index])) {\n                    //直接循环找到第一个符合的元素，然后删除它\n                    fastremove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n    \n    //根据下标删除\n    private void fastremove(int index) {\n        modcount++;\n        //这里得到删除的位置用以判断是否是删除的最后一个元素\n        int nummoved = size - index - 1;\n        if (nummoved > 0)\n            //不是最后一个元素时，将这个下标之后的元素全部往前移一位\n            system.arraycopy(elementdata, index+1, elementdata, index,\n                             nummoved);\n        //如果是最后一位，直接删除，并释放内存。\n        elementdata[--size] = null; // clear to let gc do its work\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这里可以看到非常细节的一个操作，就是遍历的时候区分null，同时这里也告诉我们，arraylist是可以存入null值的。\n\n\n# set系列\n\n# map系列\n\n分析这个之前，我们需要了解很多一些基础知识。\n\n# 什么是 “链表散列”？\n\n哈希表（hash table，也叫散列表），是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n\n记录的存储位置=f(关键字)\n\n这里的对应关系f称为散列函数，又称为哈希（hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（hash table）。\n\n哈希表hashtable(key，value) 就是把key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。） 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。\n\n数组的特点是：寻址容易，插入和删除困难；\n\n而链表的特点是：寻址困难，插入和删除容易。\n\n那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：\n\n\n\n左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n谈谈我现在的理解，我理解的hashmap是一个数组带链表，当有key-value进来时，首先得到key的hashcode值，例如：19，然后根据hashmap的容量计算放置的位置，如容量为9，那么计算的结果就为 19%9 = 1，放置的位置就是数组的下标为1的位置。0这个位置是放置key为null的key-value对象。那么现在就会出现一个问题，如果，我们的key为10，经过计算得到10%9 = 1，现在，问题就出现了，位置也是1，那么怎么存放，直接存放会导致之前的数据丢失，但是又不能不存放，这就是典型的hasn冲突了，那么怎么解决咧？我们看看一下几种方式：\n\n * 1.开放定址法：这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=h（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：\n\nhi=（h（key）+di）% m i=1，2，…，n\n\n\n1\n\n\n其中h（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：\n\n * 线性探测再散列\n\ndii=1，2，3，…，m-1\n\n\n1\n\n\n这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。\n\n * 二次探测再散列\n\ndi=12，-12，22，-22，…，k2，-k2 ( k<=m/2 )\n\n这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。\n\n伪随机探测再散列\n\ndi=伪随机数序列。\n\n具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。\n\n例如，已知哈希表长度m=11，哈希函数为：h（key）= key % 11，则h（47）=3，h（26）=4，h（60）=5，假设下一个关键字为69，则h（69）=3，与47冲突。\n\n如果用线性探测再散列处理冲突，下一个哈希地址为h1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为h2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为h3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。\n\n如果用二次探测再散列处理冲突，下一个哈希地址为h1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为h2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。\n\n如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为h1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为h2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。\n\n * 2.再哈希法 这种方法是同时构造多个不同的哈希函数：\n\nhi=rh1（key） i=1，2，…，k\n\n当哈希地址hi=rh1（key）发生冲突时，再计算hi=rh2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。\n\n * 3.链地址法 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。\n\n * 4.建立公共溢出区 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。\n\n# 拉链法与开放地址法相比的缺点：\n\n# 拉链法的优点\n\n与开放定址法相比，拉链法有如下几个优点：\n\n①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；\n\n②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；\n\n③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；\n\n④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。\n\n# 拉链法的缺点\n\n拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。\n\n结合上面所说的和hashmap的源码，我们重点关注拉链法，我们冲突的元素会放置在对应位置的链表的最后面，这样子，查询的时候，只需要一遍就可以查到结果了。\n\nhashmap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。那么问题来了？\n\n# 关于hasnmap的源码\n\n大概看了一下，估摸着有点难理解，后面再补上\n\n# 容错机制\n\n因为hashmap是非线程安全的，所以有时候出现多个线程操作的时候，容易导致数据混乱，所以，里面添加了一个容错机制---fail-fast 机制\n\n# fail-fast 机制\n\n我们知道 java.util.hashmap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 concurrentmodificationexception，这就是所谓 fail-fast 策略。\n\nail-fast 机制是 java 集合(collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。\n\n例如：当某一个线程 a 通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 a 访问集合时，就会抛出 concurrentmodificationexception 异常，产生 fail-fast 事件。\n\n这一策略在源码中的实现是通过 modcount 域，modcount 顾名思义就是修改次数，对 hashmap 内容（当然不仅仅是 hashmap 才会有，其他例如 arraylist 也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有 modcount++ 这句），那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedmodcount。\n\nhashiterator() {\n    expectedmodcount = modcount;\n    if (size > 0) { // advance to first entry\n    entry[] t = table;\n    while (index < t.length && (next = t[index++]) == null)  \n        ;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在迭代过程中，判断 modcount 跟 expectedmodcount 是否相等，如果不相等就表示已经有其他线程修改了 map：\n\n注意到 modcount 声明为 volatile，保证线程之间修改的可见性。\n\nfinal entry<k,v> nextentry() {\n    if (modcount != expectedmodcount)\n        throw new concurrentmodificationexception();\n\n\n1\n2\n3\n\n\n在 hashmap 的 api 中指出：\n\n由所有 hashmap 类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 concurrentmodificationexception。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。\n\n注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 concurrentmodificationexception。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。\n\n解决方案 在上文中也提到，fail-fast 机制，是一种错误检测机制。它只能被用来检测错误，因为 jdk 并不保证 fail-fast 机制一定会发生。若在多线程环境下使用 fail-fast 机制的集合，建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。\n\nhashmap 的两种遍历方式 第一种\n\n　　map map = new hashmap();\n　　iterator iter = map.entryset().iterator();\n　　while (iter.hasnext()) {\n　　map.entry entry = (map.entry) iter.next();\n　　object key = entry.getkey();\n　　object val = entry.getvalue();\n　　}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n效率高,以后一定要使用此种方式！\n\n第二种\n\n　　map map = new hashmap();\n　　iterator iter = map.keyset().iterator();\n　　while (iter.hasnext()) {\n　　object key = iter.next();\n　　object val = map.get(key);\n　　}\n\n\n1\n2\n3\n4\n5\n6\n\n\n效率低,以后尽量少使用！\n\n\n# hashmap 和 hashtable 区别\n\nhashmap 不是线程安全的 hashmap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。hashmap 允许 null key 和 null value，而 hashtable 不允许。\n\nhashtable 是线程安全 collection。 hashmap 是 hashtable 的轻量级实现，他们都完成了map 接口，主要区别在于 hashmap 允许 null key 和 null value,由于非线程安全，效率上可能高于 hashtable。\n\n区别如下： hashmap允许将 null 作为一个 entry 的 key 或者 value，而 hashtable 不允许。 hashmap 把 hashtable 的 contains 方法去掉了，改成 containsvalue 和 containskey。因为 contains 方法容易让人引起误解。 hashtable 继承自 dictionary 类，而 hashmap 是 java1.2 引进的 map interface 的一个实现。 hashtable 的方法是 synchronize 的，而 hashmap 不是，在多个线程访问 hashtable 时，不需要自己为它的方法实现同步，而 hashmap 就必须为之提供外同步。 hashtable 和 hashmap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。\n\n\n# linkedhashmap\n\nlinkedhashmap 概述 hashmap 是无序的，hashmap 在 put 的时候是根据 key 的 hashcode 进行 hash 然后放入对应的地方。所以在按照一定顺序 put 进 hashmap 中，然后遍历出 hashmap 的顺序跟 put 的顺序不同（除非在 put 的时候 key 已经按照 hashcode 排序号了，这种几率非常小）\n\njava 在 jdk1.4 以后提供了 linkedhashmap 来帮助我们实现了有序的 hashmap！\n\nlinkedhashmap 是 hashmap 的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 linkedhashmap。\n\nlinkedhashmap 是 map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。\n\nlinkedhashmap 实现与 hashmap 的不同之处在于，linkedhashmap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。\n\n注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。\n\n根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。\n\n对于这个类，我的理解为，在hashmap的基础上，把每次添加的节点封装为\n\n    static class entry<k,v> extends hashmap.node<k,v> {\n        entry<k,v> before, after;\n        entry(int hash, k key, v value, node<k,v> next) {\n            super(hash, key, value, next);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看到，新增了before, after两个位置表示前后的位置，这样子，就实现了双向链表的操作。\n\n其它的跟hashmap一样的\n\n\n# hasnset\n\n內部就是使用hashmap实现的，但是，hasnmap是有key-value的，但是我们使用set只有一个参数，为啥列？我们可以看这个\n\n    private static final object present = new object();\n\n    public boolean add(e e) {\n        return map.put(e, present)==null;\n    }\n\n\n1\n2\n3\n4\n5\n\n\n我们可以看到，它把我们传入的参数当成key，value就是一个新的object对象\n\n\n# linkedhashset\n\n这个类就是hashset的子类，但是，hashset内部是hashmap实现的，如果要一样的话，应该是linkedhashmap实现的呀，但是，我们看看这个类的代码\n\npublic class linkedhashset<e>\n    extends hashset<e>\n    implements set<e>, cloneable, java.io.serializable {\n\n    private static final long serialversionuid = -2851667679971038690l;\n\n    public linkedhashset(int initialcapacity, float loadfactor) {\n        super(initialcapacity, loadfactor, true);\n    }\n\n    public linkedhashset(int initialcapacity) {\n        super(initialcapacity, .75f, true);\n    }\n\n    public linkedhashset() {\n        super(16, .75f, true);\n    }\n\n    public linkedhashset(collection<? extends e> c) {\n        super(math.max(2*c.size(), 11), .75f, true);\n        addall(c);\n    }\n\n    @override\n    public spliterator<e> spliterator() {\n        return spliterators.spliterator(this, spliterator.distinct | spliterator.ordered);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n恩？？？？没有linkedhashmap呀，莫慌，我们点击\n\n super(16, .75f, true);  \n\n\n1\n\n\n可以看到\n\n    hashset(int initialcapacity, float loadfactor, boolean dummy) {\n        map = new linkedhashmap<>(initialcapacity, loadfactor);\n    }\n\n\n1\n2\n3\n\n\n是吧，还是和linkedhsahmap的实现原理一样的\n\n\n# treeset\n\n\n# 什么是迭代器\n\n迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。\n\n# java中的iterator功能比较简单，并且只能单向移动：\n\n * (1) 使用方法iterator()要求容器返回一个iterator。第一次调用iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.iterable接口,被collection继承。\n\n * (2) 使用next()获得序列中的下一个元素。\n\n * (3) 使用hasnext()检查序列中是否还有元素。\n\n * (4) 使用remove()将迭代器新返回的元素删除。\n\n举个栗子：\n\npublic class muster {\n \n    public static void main(string[] args) {\n        arraylist list = new arraylist();\n        list.add("a");\n        list.add("b");\n        list.add("c");\n        iterator it = list.iterator();\n        while(it.hasnext()){\n            string str = (string) it.next();\n            system.out.println(str);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行结果：\n\na\nb\nc\n\n\n1\n2\n3\n\n\n可以看到，iterator可以不用管底层数据具体是怎样存储的，都能够通过next()遍历整个list。\n\n但是，具体是怎么实现的呢？背后机制究竟如何呢？\n\n\n# 源码解读\n\n这里我们来看看java里abstractlist实现iterator的源代码：\n\npublic abstract class abstractlist<e> extends abstractcollection<e> implements list<e> { // list接口实现了collection<e>, iterable<e> \n  \n    protected abstractlist() {  \n    }  \n    \n    ...  \n  \n    public iterator<e> iterator() {  \n    return new itr();  // 这里返回一个迭代器\n    }  \n  \n    private class itr implements iterator<e> {  // 内部类itr实现迭代器\n       \n    int cursor = 0;  \n    int lastret = -1;  \n    int expectedmodcount = modcount;    \n    public boolean hasnext() {  // 实现hasnext方法\n            return cursor != size();  \n    }  \n  \n    public e next() {  // 实现next方法\n            checkforcomodification();  \n       try {  \n       e next = get(cursor);  \n       lastret = cursor++;  \n       return next;  \n       } catch (indexoutofboundsexception e) {  \n        checkforcomodification();  \n        throw new nosuchelementexception();  \n       }  \n    }  \n  \n    public void remove() {  // 实现remove方法\n        if (lastret == -1)  \n        throw new illegalstateexception();  \n            checkforcomodification();  \n  \n        try {  \n        abstractlist.this.remove(lastret);  \n        if (lastret < cursor)  \n            cursor--;  \n        lastret = -1;  \n        expectedmodcount = modcount;  \n        } catch (indexoutofboundsexception e) {  \n        throw new concurrentmodificationexception();  \n        }  \n    }  \n  \n    final void checkforcomodification() {  \n        if (modcount != expectedmodcount)  \n        throw new concurrentmodificationexception();  \n    }  \n    }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n可以看到，实现next()是通过get(cursor)，然后cursor++，通过这样实现遍历。\n\n这部分代码不难看懂，唯一难懂的是remove操作里涉及到的expectedmodcount = modcount;\n\n在网上查到说这是集合迭代中的一种“快速失败”机制，这种机制提供迭代过程中集合的安全性。 从源代码里可以看到增删操作都会使modcount++，通过和expectedmodcount的对比，迭代器可以快速的知道迭代过程中是否存在list.add()类似的操作，存在的话快速失败!\n\n举个栗子：\n\npublic class muster {\n \n    public static void main(string[] args) {\n        arraylist list = new arraylist();\n        list.add("a");\n        list.add("b");\n        list.add("c");\n        iterator it = list.iterator();\n        while(it.hasnext()){\n            string str = (string) it.next();\n            system.out.println(str);\n            list.add("s");        //添加一个add方法\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果：\n\na\nexception in thread "main" java.util.concurrentmodificationexception\n　　at java.util.arraylist$itr.checkforcomodification(unknown source)\n　　at java.util.arraylist$itr.next(unknown source)\n　　at com.hasse.muster.main(muster.java:11)\n\n\n1\n2\n3\n4\n5\n\n\n这就会抛出一个下面的异常，迭代终止。\n\n# 关于modcount，api解释如下：\n\nthe number of times this list has been structurally modified. structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\n\n\n1\n\n\n也就是说，modcount记录修改此列表的次数：包括改变列表的结构，改变列表的大小，打乱列表的顺序等使正在进行迭代产生错误的结果。\n\n# tips:仅仅设置元素的值并不是结构的修改\n\n我们知道的是arraylist是线程不安全的，如果在使用迭代器的过程中有其他的线程修改了list就会抛出concurrentmodificationexception，这就是fail-fast机制。',charsets:{cjk:!0},lastUpdated:"10/17/2022",lastUpdatedTimestamp:1665997159e3},{title:"Java正则表达式",frontmatter:{title:"Java正则表达式",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/88149c/",categories:["编程基础","Java"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/07.Java/03.Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"01.编程基础/07.Java/03.Java正则表达式.md",key:"v-3bbd0907",path:"/pages/88149c/",headers:[{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:3,title:"正则表达式实例",slug:"正则表达式实例",normalizedTitle:"正则表达式实例",charIndex:127},{level:4,title:"java.util.regex 包主要包括以下三个类：",slug:"java-util-regex-包主要包括以下三个类",normalizedTitle:"java.util.regex 包主要包括以下三个类：",charIndex:465},{level:5,title:"以下实例中使用了正则表达式 .runoob. 用于查找字符串中是否包了 runoob 子串：",slug:"以下实例中使用了正则表达式-runoob-用于查找字符串中是否包了-runoob-子串",normalizedTitle:"以下实例中使用了正则表达式 .runoob. 用于查找字符串中是否包了 runoob 子串：",charIndex:830},{level:3,title:"捕获组",slug:"捕获组",normalizedTitle:"捕获组",charIndex:1306},{level:4,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:132},{level:5,title:"运行结果为：",slug:"运行结果为",normalizedTitle:"运行结果为：",charIndex:2303},{level:5,title:"先不急，让我们带着疑问去看看发生了什么？？？？",slug:"先不急-让我们带着疑问去看看发生了什么",normalizedTitle:"先不急，让我们带着疑问去看看发生了什么？？？？",charIndex:2511},{level:3,title:"正则表达式语法",slug:"正则表达式语法",normalizedTitle:"正则表达式语法",charIndex:2539},{level:4,title:"解释",slug:"解释",normalizedTitle:"解释",charIndex:658},{level:5,title:"在这过程中，有过几个疑问：",slug:"在这过程中-有过几个疑问",normalizedTitle:"在这过程中，有过几个疑问：",charIndex:7012},{level:3,title:"Matcher 类的方法",slug:"matcher-类的方法",normalizedTitle:"matcher 类的方法",charIndex:7373},{level:4,title:"索引方法",slug:"索引方法",normalizedTitle:"索引方法",charIndex:7412},{level:4,title:"研究方法",slug:"研究方法",normalizedTitle:"研究方法",charIndex:7752},{level:4,title:"替换方法",slug:"替换方法",normalizedTitle:"替换方法",charIndex:8089},{level:5,title:"start 和 end 方法",slug:"start-和-end-方法",normalizedTitle:"start 和 end 方法",charIndex:8746},{level:5,title:"matches 和 lookingAt 方法",slug:"matches-和-lookingat-方法",normalizedTitle:"matches 和 lookingat 方法",charIndex:9828},{level:5,title:"replaceFirst 和 replaceAll 方法",slug:"replacefirst-和-replaceall-方法",normalizedTitle:"replacefirst 和 replaceall 方法",charIndex:11201},{level:5,title:"appendReplacement 和 appendTail 方法",slug:"appendreplacement-和-appendtail-方法",normalizedTitle:"appendreplacement 和 appendtail 方法",charIndex:11986},{level:3,title:"PatternSyntaxException 类的方法",slug:"patternsyntaxexception-类的方法",normalizedTitle:"patternsyntaxexception 类的方法",charIndex:12778}],headersStr:"概述 正则表达式实例 java.util.regex 包主要包括以下三个类： 以下实例中使用了正则表达式 .runoob. 用于查找字符串中是否包了 runoob 子串： 捕获组 实例 运行结果为： 先不急，让我们带着疑问去看看发生了什么？？？？ 正则表达式语法 解释 在这过程中，有过几个疑问： Matcher 类的方法 索引方法 研究方法 替换方法 start 和 end 方法 matches 和 lookingAt 方法 replaceFirst 和 replaceAll 方法 appendReplacement 和 appendTail 方法 PatternSyntaxException 类的方法",content:'# 概述\n\n在昨天撸代码的过程中，涉及到了正则这个我不会的东西，于是，今天来学习下有关它的一些知识。\n\n正则表达式定义了字符串的模式。\n\n正则表达式可以用来搜索、编辑或处理文本。\n\n正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。\n\n\n# 正则表达式实例\n\n一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 "Hello World" 字符串。\n\n.（点号）也是一个正则表达式，它匹配任何一个字符如："a" 或 "1"。\n\n下表列出了一些正则表达式的实例及描述：\n\n正则表达式              描述\nthis is text       匹配字符串 "this is text"\nthis\\s+is\\s+text   注意字符串中的 \\s+。匹配单词 "this" 后面的 \\s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \\s+\n                   匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text\n\n# java.util.regex 包主要包括以下三个类：\n\n * Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n\n * Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n\n * PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n# 以下实例中使用了正则表达式 .runoob. 用于查找字符串中是否包了 runoob 子串：\n\npackage regex;\n\nimport java.util.regex.Pattern;\n\npublic class LearnMain1 {\n\t\n\tpublic static void main(String[] args) {\n\t\tString content = "I am noob " +\n\t\t        "from runoob.com.";\n\t\tString pattern = ".*runoob.*";\n\t\tboolean isMatcher = Pattern.matches(pattern, content);\n\t\tSystem.out.println("字符串中是否包含了 \'runoob\' 子字符串? " + isMatcher);\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果：\n\n字符串中是否包含了 \'runoob\' 子字符串? true\n\n\n1\n\n\n\n# 捕获组\n\n捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。\n\n例如，正则表达式 (dog) 创建了单一分组，组里包含"d"，"o"，和"g"\n\n捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：\n\n * ((A)(B(C)))\n * (A)\n * (B(C))\n * (C)\n\n可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。\n\n还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。\n\n# 实例\n\n下面的例子说明如何从一个给定的字符串中找到数字串：\n\npackage regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LearnMain2 {\n\n\tpublic static void main(String[] args) {\n\t\t// 按指定模式在字符串查找\n\t      String line = "This order was placed for QT3000! OK?";\n\t      String pattern = "(\\\\D*)(\\\\d+)(.*)";\n\t      \n\t      Pattern r = Pattern.compile(pattern);\n\t      Matcher m = r.matcher(line);\n\t      int count = m.groupCount();\n\t      System.out.println("count = " + (count+1));\n\t      m.find();\n\t      for(int i=0;i<=count;i++) {\n\t    \t  System.out.println("Found value: " + m.group(i));\n\t      }\n\t}\n\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 运行结果为：\n\ncount = 4\nFound value: This order was placed for QT3000! OK?\nFound value: This order was placed for QT\nFound value: 3000\nFound value: ! OK?\n\n\n1\n2\n3\n4\n5\n\n\n？？？？？ wfk 为什么会出现这些东西？ 怎么出现的？？？？ 不理解呀！！？？？？\n\n# 先不急，让我们带着疑问去看看发生了什么？？？？\n\n\n# 正则表达式语法\n\n在其他语言中，\\\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。\n\n在 Java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。\n\n所以，在其他的语言中（如Perl），一个反斜杠 \\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\\\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\\\\\。\n\n字符            说明\n\\             将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\\n"匹配换行符。序列"\\\\"匹配"\\"，"\\("匹配"("。\n^             匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^\n              还会与"\\n"或"\\r"之后的位置匹配。\n$             匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$\n              还会与"\\n"或"\\r"之前的位置匹配。\n*             零次或多次匹配前面的字符或子表达式。例如，zo匹配"z"和"zoo"。 等效于 {0,}。\n+             一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。\n?             零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于\n              {0,1}。\n{n}           n 是非负整数。正好匹配 n次。例如，"o{2}"与"Bob"中的"o"不匹配， 但与"food"中的两个"o"匹配。\n{n,}          n 是非负整数。至少匹配 n次。例如，"o{2,}"不匹配"Bob"中的"o"， 而匹配"foooood"中的所有\n              o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。\n{n,m}         m 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m\n              次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。\'o{0,1}\' 等效于\n              \'o?\'。注意：您不能将空格插入逗号和数字之间。\n?             当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。\n.             匹配除"\\r\\n"之外的任何单个字符。若要匹配包括"\\r\\n"在内的任意字符，请使用诸如"[\\s\\S]"之类的模式。\n(pattern)     匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9\n              属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\\("或者"\\)"。\n(?:pattern)   匹配 pattern 但不捕获该匹配的子表达式， 即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符\n              (|) 组合模式部件的情况很有用。例如，\'industr(?:y|ies) 是比\n              \'industry|industries\' 更经济的表达式。\n(?=pattern)   执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern\n              的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'Windows\n              (?=95|98|NT|2000)\' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows\n              3.1"中的"Windows"\n              。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n(?!pattern)   执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern\n              的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'Windows\n              (?!95|98|NT|2000)\' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows\n              2000"中的"Windows"。\n              预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\nx|y           匹配 x 或 y。例如，\'z|food\' 匹配"z"或"food"。\'(z|f)ood\'\n              匹配"zood"或"food"。\n[xyz]         字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。\n[^xyz]        反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。\n[a-z]         字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。\n[^a-z]        反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。\n\\b            匹配一个字边界，即字与空格间的位置。例如，"er\\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。\n\\B            非字边界匹配。"er\\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。\n\\cx           匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z\n              之间。如果不是这样，则假定 c 就是"c"字符本身。\n\\d            数字字符匹配。等效于 [0-9]。\n\\D            非数字字符匹配。等效于 [^0-9]。\n\\f            换页符匹配。等效于 \\x0c 和 \\cL。\n\\n            换行符匹配。等效于 \\x0a 和 \\cJ。\n\\r            匹配一个回车符。等效于 \\x0d 和 \\cM。\n\\s            匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。\n\\S            匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。\n\\t            制表符匹配。与 \\x09 和 \\cI 等效。\n\\v            垂直制表符匹配。与 \\x0b 和 \\cK 等效。\n\\w            匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。\n\\W            与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。\n\\xn           匹配 n，此处的 n 是一个十六进制转义码。\n              十六进制转义码必须正好是两位数长。例如，"\\x41"匹配"A"。"\\x041"与"\\x04"&"1"等效。允许在正则表达式中使用\n              ASCII 代码。\n\\num          匹配 num，此处的 num 是一个正整数。 到捕获匹配的反向引用。 例如，"(.)\\1"匹配两个连续的相同字符。\n\\n            标识一个八进制转义码或反向引用。如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n\n              是八进制数 (0-7)，那么 n 是八进制转义码。\n\\nm           标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \\nm\n              前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值\n              nm，其中 n 和 m 是八进制数字 (0-7)。\n\\nml          当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。\n\\un           匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。\n\n# 解释\n\n看完这些密密麻麻的语法后，是不是感觉记不住，记不住就对了，我们来对照着找，首先：整条字符串为：\n\nThis order was placed for QT3000! OK?\n\n\n1\n\n\n然后，我们分组规则为：\n\n"(\\\\D*)(\\\\d+)(.*)"\n\n\n1\n\n\n从括号可以看出，整体被分为了4个组，因为0不记在count里面（所以加1）\n\n第一组：整体\n\nThis order was placed for QT3000! OK?\n\n\n1\n\n\n第二组：\\\\D*\n\n\\\\D 查表表示为 非数字字符匹配。等效于 [^0-9]。即，非数字就是这个组，所以，从前往后，到数字就停止\n\nThis order was placed for QT\n\n\n1\n\n\n第三组：\\\\d+\n\n\\\\d+ 查表表示为 数字字符匹配。等效于 [0-9]。所以，从上一个组的后面开始，查找数字，碰到非数字停止\n\n3000\n\n\n1\n\n\n第四组：.*\n\n. 查表表示为 匹配除"\\r\\n"之外的任何单个字符。若要匹配包括"\\r\\n"在内的任意字符，请使用诸如"[\\s\\S]"之类的模式。\n\n* 查表表示为 零次或多次匹配前面的字符或子表达式。例如，zo匹配"z"和"zoo"。 等效于 {0,}。\n\n所以，接下来的所有字符都被打印出来了\n\n! OK?\n\n\n1\n\n\n# 在这过程中，有过几个疑问：\n\n1、\\r\\n是啥？\n\n在windos中可以理解为回车换行\n\n\n1\n\n\n2、匹配数字的话，如果后面还有数字怎么办，如这种：This order was placed for QT3000! OK? NO it is QT4300 ，那么，第三组会输出啥？\n\n经过试验，我得到，它会输出3000，而后面的4300不会输出，这就是为啥我前面说，遇到字母就停止匹配（字符相同）\n\n\n1\n\n\n3、*遇到空格会输出吗？如：This order was placed for QT3000 ! OK? NO it is QT4300，这样子，会输出前面的空格吗？\n\n答案是-------是的，会输出\n\n\n1\n\n\n4、为啥会跟着前面已经匹配的字符串后面去匹配？\n\n我猜的话，有个定位的标志\n\n\n1\n\n\n\n# Matcher 类的方法\n\n前面，我们用到了这个类，这个时候来了解下它\n\n# 索引方法\n\n索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：\n\n序号   方法                            说明\n1    public int start()            返回以前匹配的初始索引。\n2    public int start(int group)   返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引\n3    public int end()              返回最后匹配字符之后的偏移量。\n4    public int end(int group)     返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。\n\n学到这里，我们就知道了，原来是有个索引的存在\n\n# 研究方法\n\n研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：\n\n序号   方法                               说明\n1    public boolean lookingAt()       尝试将从区域开头开始的输入序列与该模式匹配。\n2    public boolean find()            尝试查找与该模式匹配的输入序列的下一个子序列。\n3    public boolean find(int start）   重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。\n4    public boolean matches()         尝试将整个区域与模式匹配。\n\n# 替换方法\n\n替换方法是替换输入字符串里文本的方法：\n\n序号   方法                                                         说明\n1    public Matcher appendReplacement(StringBuffer sb, String   实现非终端添加和替换步骤。\n     replacement)\n2    public StringBuffer appendTail(StringBuffer sb)            实现终端添加和替换步骤。\n3    public String replaceAll(String replacement)               替换模式与给定替换字符串相匹配的输入序列的每个子序列。\n4    public String replaceFirst(String replacement)             替换模式与给定替换字符串匹配的输入序列的第一个子序列。\n5    public static String quoteReplacement(String s)            返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement\n                                                                方法一个字面字符串一样工作。\n\n# start 和 end 方法\n\n下面是一个对单词 "cat" 出现在输入字符串中出现次数进行计数的例子：\n\npackage regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LearnMain2 {\n\n\tprivate static final String REGEX = "\\\\bcat\\\\b";\n    private static final String INPUT =\n                                    "cat cat cat cattie cat";\n \n    public static void main( String args[] ){\n       Pattern p = Pattern.compile(REGEX);\n       Matcher m = p.matcher(INPUT); // 获取 matcher 对象\n       int count = 0;\n \n       while(m.find()) {\n         count++;\n         System.out.println("Match number "+count);\n         System.out.println("start(): "+m.start());\n         System.out.println("end(): "+m.end());\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n运行结果为：\n\nMatch number 1\nstart(): 0\nend(): 3\nMatch number 2\nstart(): 4\nend(): 7\nMatch number 3\nstart(): 8\nend(): 11\nMatch number 4\nstart(): 19\nend(): 22\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到这个例子是使用单词边界，以确保字母 "c" "a" "t" 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。\n\nStart 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。\n\n# matches 和 lookingAt 方法\n\nmatches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。\n\nlookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。\n\n这两个方法经常在输入字符串的开始使用。\n\n我们通过下面这个例子，来解释这个功能：\n\npackage regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LearnMain2 {\n\n\tprivate static final String REGEX = "foo";\n    private static final String INPUT = "fooooooooooooooooo";\n    private static final String INPUT2 = "ooooofoooooooooooo";\n    private static Pattern pattern;\n    private static Matcher matcher;\n    private static Matcher matcher2;\n \n    public static void main( String args[] ){\n       pattern = Pattern.compile(REGEX);\n       matcher = pattern.matcher(INPUT);\n       matcher2 = pattern.matcher(INPUT2);\n \n       System.out.println("Current REGEX is: "+REGEX);\n       System.out.println("Current INPUT is: "+INPUT);\n       System.out.println("Current INPUT2 is: "+INPUT2);\n \n \n       System.out.println("lookingAt(): "+matcher.lookingAt());\n       System.out.println("matches(): "+matcher.matches());\n       System.out.println("lookingAt(): "+matcher2.lookingAt());\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n运行结果为：\n\nCurrent REGEX is: foo\nCurrent INPUT is: fooooooooooooooooo\nCurrent INPUT2 is: ooooofoooooooooooo\nlookingAt(): true\nmatches(): false\nlookingAt(): false\n\n\n1\n2\n3\n4\n5\n6\n\n\n# replaceFirst 和 replaceAll 方法\n\nreplaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。\n\n下面的例子来解释这个功能：\n\npackage regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LearnMain2 {\n\n\tprivate static String REGEX = "dog";\n    private static String INPUT = "The dog says meow. " +\n                                    "All dogs say meow.";\n    private static String REPLACE = "cat";\n \n    public static void main(String[] args) {\n       Pattern p = Pattern.compile(REGEX);\n       // get a matcher object\n       Matcher m = p.matcher(INPUT); \n       INPUT = m.replaceAll(REPLACE);\n       System.out.println(INPUT);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n运行结果为：\n\nThe cat says meow. All cats say meow.\n\n\n1\n\n\n# appendReplacement 和 appendTail 方法\n\nMatcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换：\n\n看下面的例子来解释这个功能：\n\npackage regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LearnMain2 {\n\n\tprivate static String REGEX = "a*b";\n\t   private static String INPUT = "aabfooaabfooabfoobkkk";\n\t   private static String REPLACE = "-";\n\t   public static void main(String[] args) {\n\t      Pattern p = Pattern.compile(REGEX);\n\t      // 获取 matcher 对象\n\t      Matcher m = p.matcher(INPUT);\n\t      StringBuffer sb = new StringBuffer();\n\t      while(m.find()){\n\t         m.appendReplacement(sb,REPLACE);\n\t      }\n\t      m.appendTail(sb);\n\t      System.out.println(sb.toString());\n\t   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n运行结果为：\n\n-foo-foo-foo-kkk\n\n\n1\n\n\n\n# PatternSyntaxException 类的方法\n\nPatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。\n\nPatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。\n\n序号   方法                               说明\n1    public String getDescription()   获取错误的描述。\n2    public int getIndex()            获取错误的索引。\n3    public String getPattern()       获取错误的正则表达式模式。\n4    public String getMessage()       返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。',normalizedContent:'# 概述\n\n在昨天撸代码的过程中，涉及到了正则这个我不会的东西，于是，今天来学习下有关它的一些知识。\n\n正则表达式定义了字符串的模式。\n\n正则表达式可以用来搜索、编辑或处理文本。\n\n正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。\n\n\n# 正则表达式实例\n\n一个字符串其实就是一个简单的正则表达式，例如 hello world 正则表达式匹配 "hello world" 字符串。\n\n.（点号）也是一个正则表达式，它匹配任何一个字符如："a" 或 "1"。\n\n下表列出了一些正则表达式的实例及描述：\n\n正则表达式              描述\nthis is text       匹配字符串 "this is text"\nthis\\s+is\\s+text   注意字符串中的 \\s+。匹配单词 "this" 后面的 \\s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \\s+\n                   匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text\n\n# java.util.regex 包主要包括以下三个类：\n\n * pattern 类： pattern 对象是一个正则表达式的编译表示。pattern 类没有公共构造方法。要创建一个 pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n\n * matcher 类： matcher 对象是对输入字符串进行解释和匹配操作的引擎。与pattern 类一样，matcher 也没有公共构造方法。你需要调用 pattern 对象的 matcher 方法来获得一个 matcher 对象。\n\n * patternsyntaxexception： patternsyntaxexception 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n# 以下实例中使用了正则表达式 .runoob. 用于查找字符串中是否包了 runoob 子串：\n\npackage regex;\n\nimport java.util.regex.pattern;\n\npublic class learnmain1 {\n\t\n\tpublic static void main(string[] args) {\n\t\tstring content = "i am noob " +\n\t\t        "from runoob.com.";\n\t\tstring pattern = ".*runoob.*";\n\t\tboolean ismatcher = pattern.matches(pattern, content);\n\t\tsystem.out.println("字符串中是否包含了 \'runoob\' 子字符串? " + ismatcher);\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果：\n\n字符串中是否包含了 \'runoob\' 子字符串? true\n\n\n1\n\n\n\n# 捕获组\n\n捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。\n\n例如，正则表达式 (dog) 创建了单一分组，组里包含"d"，"o"，和"g"\n\n捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（a）（b（c））），有四个这样的组：\n\n * ((a)(b(c)))\n * (a)\n * (b(c))\n * (c)\n\n可以通过调用 matcher 对象的 groupcount 方法来查看表达式有多少个分组。groupcount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。\n\n还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupcount 的返回值中。\n\n# 实例\n\n下面的例子说明如何从一个给定的字符串中找到数字串：\n\npackage regex;\n\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class learnmain2 {\n\n\tpublic static void main(string[] args) {\n\t\t// 按指定模式在字符串查找\n\t      string line = "this order was placed for qt3000! ok?";\n\t      string pattern = "(\\\\d*)(\\\\d+)(.*)";\n\t      \n\t      pattern r = pattern.compile(pattern);\n\t      matcher m = r.matcher(line);\n\t      int count = m.groupcount();\n\t      system.out.println("count = " + (count+1));\n\t      m.find();\n\t      for(int i=0;i<=count;i++) {\n\t    \t  system.out.println("found value: " + m.group(i));\n\t      }\n\t}\n\t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 运行结果为：\n\ncount = 4\nfound value: this order was placed for qt3000! ok?\nfound value: this order was placed for qt\nfound value: 3000\nfound value: ! ok?\n\n\n1\n2\n3\n4\n5\n\n\n？？？？？ wfk 为什么会出现这些东西？ 怎么出现的？？？？ 不理解呀！！？？？？\n\n# 先不急，让我们带着疑问去看看发生了什么？？？？\n\n\n# 正则表达式语法\n\n在其他语言中，\\\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。\n\n在 java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。\n\n所以，在其他的语言中（如perl），一个反斜杠 \\ 就足以具有转义的作用，而在 java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 java 的正则表达式中，两个 \\\\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\\\\\。\n\n字符            说明\n\\             将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\\n"匹配换行符。序列"\\\\"匹配"\\"，"\\("匹配"("。\n^             匹配输入字符串开始的位置。如果设置了 regexp 对象的 multiline 属性，^\n              还会与"\\n"或"\\r"之后的位置匹配。\n$             匹配输入字符串结尾的位置。如果设置了 regexp 对象的 multiline 属性，$\n              还会与"\\n"或"\\r"之前的位置匹配。\n*             零次或多次匹配前面的字符或子表达式。例如，zo匹配"z"和"zoo"。 等效于 {0,}。\n+             一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。\n?             零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于\n              {0,1}。\n{n}           n 是非负整数。正好匹配 n次。例如，"o{2}"与"bob"中的"o"不匹配， 但与"food"中的两个"o"匹配。\n{n,}          n 是非负整数。至少匹配 n次。例如，"o{2,}"不匹配"bob"中的"o"， 而匹配"foooood"中的所有\n              o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。\n{n,m}         m 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m\n              次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。\'o{0,1}\' 等效于\n              \'o?\'。注意：您不能将空格插入逗号和数字之间。\n?             当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。\n.             匹配除"\\r\\n"之外的任何单个字符。若要匹配包括"\\r\\n"在内的任意字符，请使用诸如"[\\s\\s]"之类的模式。\n(pattern)     匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9\n              属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\\("或者"\\)"。\n(?:pattern)   匹配 pattern 但不捕获该匹配的子表达式， 即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符\n              (|) 组合模式部件的情况很有用。例如，\'industr(?:y|ies) 是比\n              \'industry|industries\' 更经济的表达式。\n(?=pattern)   执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern\n              的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'windows\n              (?=95|98|nt|2000)\' 匹配"windows 2000"中的"windows"，但不匹配"windows\n              3.1"中的"windows"\n              。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n(?!pattern)   执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern\n              的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'windows\n              (?!95|98|nt|2000)\' 匹配"windows 3.1"中的 "windows"，但不匹配"windows\n              2000"中的"windows"。\n              预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\nx|y           匹配 x 或 y。例如，\'z|food\' 匹配"z"或"food"。\'(z|f)ood\'\n              匹配"zood"或"food"。\n[xyz]         字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。\n[^xyz]        反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。\n[a-z]         字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。\n[^a-z]        反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。\n\\b            匹配一个字边界，即字与空格间的位置。例如，"er\\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。\n\\b            非字边界匹配。"er\\b"匹配"verb"中的"er"，但不匹配"never"中的"er"。\n\\cx           匹配 x 指示的控制字符。例如，\\cm 匹配 control-m 或回车符。x 的值必须在 a-z 或 a-z\n              之间。如果不是这样，则假定 c 就是"c"字符本身。\n\\d            数字字符匹配。等效于 [0-9]。\n\\d            非数字字符匹配。等效于 [^0-9]。\n\\f            换页符匹配。等效于 \\x0c 和 \\cl。\n\\n            换行符匹配。等效于 \\x0a 和 \\cj。\n\\r            匹配一个回车符。等效于 \\x0d 和 \\cm。\n\\s            匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。\n\\s            匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。\n\\t            制表符匹配。与 \\x09 和 \\ci 等效。\n\\v            垂直制表符匹配。与 \\x0b 和 \\ck 等效。\n\\w            匹配任何字类字符，包括下划线。与"[a-za-z0-9_]"等效。\n\\w            与任何非单词字符匹配。与"[^a-za-z0-9_]"等效。\n\\xn           匹配 n，此处的 n 是一个十六进制转义码。\n              十六进制转义码必须正好是两位数长。例如，"\\x41"匹配"a"。"\\x041"与"\\x04"&"1"等效。允许在正则表达式中使用\n              ascii 代码。\n\\num          匹配 num，此处的 num 是一个正整数。 到捕获匹配的反向引用。 例如，"(.)\\1"匹配两个连续的相同字符。\n\\n            标识一个八进制转义码或反向引用。如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n\n              是八进制数 (0-7)，那么 n 是八进制转义码。\n\\nm           标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \\nm\n              前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值\n              nm，其中 n 和 m 是八进制数字 (0-7)。\n\\nml          当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。\n\\un           匹配 n，其中 n 是以四位十六进制数表示的 unicode 字符。例如，\\u00a9 匹配版权符号 (©)。\n\n# 解释\n\n看完这些密密麻麻的语法后，是不是感觉记不住，记不住就对了，我们来对照着找，首先：整条字符串为：\n\nthis order was placed for qt3000! ok?\n\n\n1\n\n\n然后，我们分组规则为：\n\n"(\\\\d*)(\\\\d+)(.*)"\n\n\n1\n\n\n从括号可以看出，整体被分为了4个组，因为0不记在count里面（所以加1）\n\n第一组：整体\n\nthis order was placed for qt3000! ok?\n\n\n1\n\n\n第二组：\\\\d*\n\n\\\\d 查表表示为 非数字字符匹配。等效于 [^0-9]。即，非数字就是这个组，所以，从前往后，到数字就停止\n\nthis order was placed for qt\n\n\n1\n\n\n第三组：\\\\d+\n\n\\\\d+ 查表表示为 数字字符匹配。等效于 [0-9]。所以，从上一个组的后面开始，查找数字，碰到非数字停止\n\n3000\n\n\n1\n\n\n第四组：.*\n\n. 查表表示为 匹配除"\\r\\n"之外的任何单个字符。若要匹配包括"\\r\\n"在内的任意字符，请使用诸如"[\\s\\s]"之类的模式。\n\n* 查表表示为 零次或多次匹配前面的字符或子表达式。例如，zo匹配"z"和"zoo"。 等效于 {0,}。\n\n所以，接下来的所有字符都被打印出来了\n\n! ok?\n\n\n1\n\n\n# 在这过程中，有过几个疑问：\n\n1、\\r\\n是啥？\n\n在windos中可以理解为回车换行\n\n\n1\n\n\n2、匹配数字的话，如果后面还有数字怎么办，如这种：this order was placed for qt3000! ok? no it is qt4300 ，那么，第三组会输出啥？\n\n经过试验，我得到，它会输出3000，而后面的4300不会输出，这就是为啥我前面说，遇到字母就停止匹配（字符相同）\n\n\n1\n\n\n3、*遇到空格会输出吗？如：this order was placed for qt3000 ! ok? no it is qt4300，这样子，会输出前面的空格吗？\n\n答案是-------是的，会输出\n\n\n1\n\n\n4、为啥会跟着前面已经匹配的字符串后面去匹配？\n\n我猜的话，有个定位的标志\n\n\n1\n\n\n\n# matcher 类的方法\n\n前面，我们用到了这个类，这个时候来了解下它\n\n# 索引方法\n\n索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：\n\n序号   方法                            说明\n1    public int start()            返回以前匹配的初始索引。\n2    public int start(int group)   返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引\n3    public int end()              返回最后匹配字符之后的偏移量。\n4    public int end(int group)     返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。\n\n学到这里，我们就知道了，原来是有个索引的存在\n\n# 研究方法\n\n研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：\n\n序号   方法                               说明\n1    public boolean lookingat()       尝试将从区域开头开始的输入序列与该模式匹配。\n2    public boolean find()            尝试查找与该模式匹配的输入序列的下一个子序列。\n3    public boolean find(int start）   重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。\n4    public boolean matches()         尝试将整个区域与模式匹配。\n\n# 替换方法\n\n替换方法是替换输入字符串里文本的方法：\n\n序号   方法                                                         说明\n1    public matcher appendreplacement(stringbuffer sb, string   实现非终端添加和替换步骤。\n     replacement)\n2    public stringbuffer appendtail(stringbuffer sb)            实现终端添加和替换步骤。\n3    public string replaceall(string replacement)               替换模式与给定替换字符串相匹配的输入序列的每个子序列。\n4    public string replacefirst(string replacement)             替换模式与给定替换字符串匹配的输入序列的第一个子序列。\n5    public static string quotereplacement(string s)            返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给matcher类的appendreplacement\n                                                                方法一个字面字符串一样工作。\n\n# start 和 end 方法\n\n下面是一个对单词 "cat" 出现在输入字符串中出现次数进行计数的例子：\n\npackage regex;\n\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class learnmain2 {\n\n\tprivate static final string regex = "\\\\bcat\\\\b";\n    private static final string input =\n                                    "cat cat cat cattie cat";\n \n    public static void main( string args[] ){\n       pattern p = pattern.compile(regex);\n       matcher m = p.matcher(input); // 获取 matcher 对象\n       int count = 0;\n \n       while(m.find()) {\n         count++;\n         system.out.println("match number "+count);\n         system.out.println("start(): "+m.start());\n         system.out.println("end(): "+m.end());\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n运行结果为：\n\nmatch number 1\nstart(): 0\nend(): 3\nmatch number 2\nstart(): 4\nend(): 7\nmatch number 3\nstart(): 8\nend(): 11\nmatch number 4\nstart(): 19\nend(): 22\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到这个例子是使用单词边界，以确保字母 "c" "a" "t" 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。\n\nstart 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。\n\n# matches 和 lookingat 方法\n\nmatches 和 lookingat 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingat 不要求。\n\nlookingat 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。\n\n这两个方法经常在输入字符串的开始使用。\n\n我们通过下面这个例子，来解释这个功能：\n\npackage regex;\n\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class learnmain2 {\n\n\tprivate static final string regex = "foo";\n    private static final string input = "fooooooooooooooooo";\n    private static final string input2 = "ooooofoooooooooooo";\n    private static pattern pattern;\n    private static matcher matcher;\n    private static matcher matcher2;\n \n    public static void main( string args[] ){\n       pattern = pattern.compile(regex);\n       matcher = pattern.matcher(input);\n       matcher2 = pattern.matcher(input2);\n \n       system.out.println("current regex is: "+regex);\n       system.out.println("current input is: "+input);\n       system.out.println("current input2 is: "+input2);\n \n \n       system.out.println("lookingat(): "+matcher.lookingat());\n       system.out.println("matches(): "+matcher.matches());\n       system.out.println("lookingat(): "+matcher2.lookingat());\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n运行结果为：\n\ncurrent regex is: foo\ncurrent input is: fooooooooooooooooo\ncurrent input2 is: ooooofoooooooooooo\nlookingat(): true\nmatches(): false\nlookingat(): false\n\n\n1\n2\n3\n4\n5\n6\n\n\n# replacefirst 和 replaceall 方法\n\nreplacefirst 和 replaceall 方法用来替换匹配正则表达式的文本。不同的是，replacefirst 替换首次匹配，replaceall 替换所有匹配。\n\n下面的例子来解释这个功能：\n\npackage regex;\n\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class learnmain2 {\n\n\tprivate static string regex = "dog";\n    private static string input = "the dog says meow. " +\n                                    "all dogs say meow.";\n    private static string replace = "cat";\n \n    public static void main(string[] args) {\n       pattern p = pattern.compile(regex);\n       // get a matcher object\n       matcher m = p.matcher(input); \n       input = m.replaceall(replace);\n       system.out.println(input);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n运行结果为：\n\nthe cat says meow. all cats say meow.\n\n\n1\n\n\n# appendreplacement 和 appendtail 方法\n\nmatcher 类也提供了appendreplacement 和 appendtail 方法用于文本替换：\n\n看下面的例子来解释这个功能：\n\npackage regex;\n\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class learnmain2 {\n\n\tprivate static string regex = "a*b";\n\t   private static string input = "aabfooaabfooabfoobkkk";\n\t   private static string replace = "-";\n\t   public static void main(string[] args) {\n\t      pattern p = pattern.compile(regex);\n\t      // 获取 matcher 对象\n\t      matcher m = p.matcher(input);\n\t      stringbuffer sb = new stringbuffer();\n\t      while(m.find()){\n\t         m.appendreplacement(sb,replace);\n\t      }\n\t      m.appendtail(sb);\n\t      system.out.println(sb.tostring());\n\t   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n运行结果为：\n\n-foo-foo-foo-kkk\n\n\n1\n\n\n\n# patternsyntaxexception 类的方法\n\npatternsyntaxexception 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。\n\npatternsyntaxexception 类提供了下面的方法来帮助我们查看发生了什么错误。\n\n序号   方法                               说明\n1    public string getdescription()   获取错误的描述。\n2    public int getindex()            获取错误的索引。\n3    public string getpattern()       获取错误的正则表达式模式。\n4    public string getmessage()       返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。',charsets:{cjk:!0},lastUpdated:"10/17/2022",lastUpdatedTimestamp:1665997159e3},{title:"Properties的学习",frontmatter:{title:"Properties的学习",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/2882fd/",categories:["编程基础","Java"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/07.Java/04.Properties%E7%9A%84%E5%AD%A6%E4%B9%A0.html",relativePath:"01.编程基础/07.Java/04.Properties的学习.md",key:"v-1d5b13d5",path:"/pages/2882fd/",headers:[{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:140},{level:4,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:241},{level:4,title:"获取properities的六种方法",slug:"获取properities的六种方法",normalizedTitle:"获取properities的六种方法",charIndex:1276},{level:5,title:"使用java.util.Properties类的load()方法",slug:"使用java-util-properties类的load-方法",normalizedTitle:"使用java.util.properties类的load()方法",charIndex:1298},{level:5,title:"使用java.util.ResourceBundle类的getBundle()方法",slug:"使用java-util-resourcebundle类的getbundle-方法",normalizedTitle:"使用java.util.resourcebundle类的getbundle()方法",charIndex:1463},{level:5,title:"使用java.util.PropertyResourceBundle类的构造函数",slug:"使用java-util-propertyresourcebundle类的构造函数",normalizedTitle:"使用java.util.propertyresourcebundle类的构造函数",charIndex:1592},{level:5,title:"使用class变量的getResourceAsStream()方法",slug:"使用class变量的getresourceasstream-方法",normalizedTitle:"使用class变量的getresourceasstream()方法",charIndex:1770},{level:5,title:"使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法",slug:"使用class-getclassloader-所得到的java-lang-classloader的getresourceasstream-方法",normalizedTitle:"使用class.getclassloader()所得到的java.lang.classloader的getresourceasstream()方法",charIndex:1929},{level:5,title:"使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法",slug:"使用java-lang-classloader类的getsystemresourceasstream-静态方法",normalizedTitle:"使用java.lang.classloader类的getsystemresourceasstream()静态方法",charIndex:2145},{level:3,title:"举个栗子",slug:"举个栗子",normalizedTitle:"举个栗子",charIndex:2328},{level:5,title:"还可以这样",slug:"还可以这样",normalizedTitle:"还可以这样",charIndex:3677}],headersStr:"概述 简介 方法 获取properities的六种方法 使用java.util.Properties类的load()方法 使用java.util.ResourceBundle类的getBundle()方法 使用java.util.PropertyResourceBundle类的构造函数 使用class变量的getResourceAsStream()方法 使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法 使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法 举个栗子 还可以这样",content:'# 概述\n\nJava中有个比较重要的类Properties（Java.util.Properties），主要用于读取Java的配置文件，各种语言都有自己所支持的配置文件，配置文件中很多变量是经常改变的，这样做也是为了方便用户，让用户能够脱离程序本身去修改相关的变量设置。\n\n\n# 简介\n\n在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用"#"来注释。Properties类继承自Hashtable\n\n# 方法\n\n方法名称                                                     描述\nString getProperty(String key)                           用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。\nvoid load(InputStream streamIn) throws IOException       从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties\n                                                         文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。\nObject setProperty(String key, String value)             调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。\nvoid store(OutputStream streamOut, String description)   以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties\n                                                         表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。\nvoid clear ()                                            清除所有装载的 键 - 值对。该方法在基类中提供。\nString getProperty(String key, String defaultProperty)   用指定的键在属性列表中搜索属性。\nvoid list(PrintStream streamOut)                         将属性列表输出到指定的输出流。\nEnumeration propertyNames()                              按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。\n\n# 获取properities的六种方法\n\n# 使用java.util.Properties类的load()方法\n\n示例：\n\nInputStream in = new BufferedInputStream(new FileInputStream(name));\nProperties p = new Properties();\np.load(in);\n\n\n1\n2\n3\n\n\n# 使用java.util.ResourceBundle类的getBundle()方法\n\n示例：\n\nResourceBundle rb = ResourceBundle.getBundle(name, Locale.getDefault());\n\n\n1\n\n\n# 使用java.util.PropertyResourceBundle类的构造函数\n\n示例：\n\nInputStream in = new BufferedInputStream(new FileInputStream(name));\nResourceBundle rb = new PropertyResourceBundle(in);\n\n\n1\n2\n\n\n# 使用class变量的getResourceAsStream()方法\n\n示例：\n\nInputStream in = JProperties.class.getResourceAsStream(name);\nProperties p = new Properties();\np.load(in);\n\n\n1\n2\n3\n\n\n# 使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法\n\n示例：\n\nInputStream in = JProperties.class.getClassLoader().getResourceAsStream(name);\nProperties p = new Properties();\np.load(in);\n\n\n1\n2\n3\n\n\n# 使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法\n\n示例：\n\nInputStream in = ClassLoader.getSystemResourceAsStream(name);\nProperties p = new Properties();\np.load(in);\n\n\n1\n2\n3\n\n\n\n# 举个栗子\n\npublic static void main(String[] args) {\n\t\t\n\t    File file = new File("conf.properties");\n\t    if(!file.exists()) {\n\t    \ttry {\n\t\t\t\tSystem.out.println(file.createNewFile());\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t    }\n\t\t\n\t\tProperties properties = new Properties();\n\t\ttry {\n\t\t\tFileInputStream in = new FileInputStream(file);\n\t\t\tFileOutputStream out = new FileOutputStream(file);\n\t\t\tproperties.load(in);\n\t\t\tin.close();\n\t\t\tproperties.setProperty("key1", "value1");\n\t\t\tproperties.store(out, "This is First Commoned!");\n\t\t\tout.close();\n\t\t\t\n\t\t\tSystem.out.println(properties.getProperty("key1"));\n\t\t\t\n\t\t\tIterator<String> it=prop.stringPropertyNames().iterator();\n             while(it.hasNext()){\n                 String key=it.next();\n                 System.out.println(key+":"+prop.getProperty(key));\n             }\n\t\t\t\n\t\t\tproperties.clear();\n\t\t\t\n\t\t\tSystem.out.println(properties.getProperty("key1"));\n\t\t\t\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\t\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n执行结果：\n\ntrue\nvalue1\nkey1:value1\nnull\n\n\n1\n2\n3\n4\n\n\n# 还可以这样\n\npublic static void main(String args[]) {\n      Properties capitals = new Properties();\n      Set states;\n      String str;\n      \n      capitals.put("Illinois", "Springfield");\n      capitals.put("Missouri", "Jefferson City");\n      capitals.put("Washington", "Olympia");\n      capitals.put("California", "Sacramento");\n      capitals.put("Indiana", "Indianapolis");\n \n      // Show all states and capitals in hashtable.\n      states = capitals.keySet(); // get set-view of keys\n      Iterator itr = states.iterator();\n      while(itr.hasNext()) {\n         str = (String) itr.next();\n         System.out.println("The capital of " +\n            str + " is " + capitals.getProperty(str) + ".");\n      }\n      System.out.println();\n \n      // look for state not in list -- specify default\n      str = capitals.getProperty("Florida", "Not Found");\n      System.out.println("The capital of Florida is "\n          + str + ".");\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n输出结果为：\n\nThe capital of Missouri is Jefferson City.\nThe capital of Illinois is Springfield.\nThe capital of Indiana is Indianapolis.\nThe capital of California is Sacramento.\nThe capital of Washington is Olympia.\n\nThe capital of Florida is Not Found.\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# 概述\n\njava中有个比较重要的类properties（java.util.properties），主要用于读取java的配置文件，各种语言都有自己所支持的配置文件，配置文件中很多变量是经常改变的，这样做也是为了方便用户，让用户能够脱离程序本身去修改相关的变量设置。\n\n\n# 简介\n\n在java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用"#"来注释。properties类继承自hashtable\n\n# 方法\n\n方法名称                                                     描述\nstring getproperty(string key)                           用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。\nvoid load(inputstream streamin) throws ioexception       从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties\n                                                         文件）进行装载来获取该文件中的所有键 - 值对。以供 getproperty ( string key) 来搜索。\nobject setproperty(string key, string value)             调用 hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。\nvoid store(outputstream streamout, string description)   以适合使用 load 方法加载到 properties 表中的格式，将此 properties\n                                                         表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。\nvoid clear ()                                            清除所有装载的 键 - 值对。该方法在基类中提供。\nstring getproperty(string key, string defaultproperty)   用指定的键在属性列表中搜索属性。\nvoid list(printstream streamout)                         将属性列表输出到指定的输出流。\nenumeration propertynames()                              按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。\n\n# 获取properities的六种方法\n\n# 使用java.util.properties类的load()方法\n\n示例：\n\ninputstream in = new bufferedinputstream(new fileinputstream(name));\nproperties p = new properties();\np.load(in);\n\n\n1\n2\n3\n\n\n# 使用java.util.resourcebundle类的getbundle()方法\n\n示例：\n\nresourcebundle rb = resourcebundle.getbundle(name, locale.getdefault());\n\n\n1\n\n\n# 使用java.util.propertyresourcebundle类的构造函数\n\n示例：\n\ninputstream in = new bufferedinputstream(new fileinputstream(name));\nresourcebundle rb = new propertyresourcebundle(in);\n\n\n1\n2\n\n\n# 使用class变量的getresourceasstream()方法\n\n示例：\n\ninputstream in = jproperties.class.getresourceasstream(name);\nproperties p = new properties();\np.load(in);\n\n\n1\n2\n3\n\n\n# 使用class.getclassloader()所得到的java.lang.classloader的getresourceasstream()方法\n\n示例：\n\ninputstream in = jproperties.class.getclassloader().getresourceasstream(name);\nproperties p = new properties();\np.load(in);\n\n\n1\n2\n3\n\n\n# 使用java.lang.classloader类的getsystemresourceasstream()静态方法\n\n示例：\n\ninputstream in = classloader.getsystemresourceasstream(name);\nproperties p = new properties();\np.load(in);\n\n\n1\n2\n3\n\n\n\n# 举个栗子\n\npublic static void main(string[] args) {\n\t\t\n\t    file file = new file("conf.properties");\n\t    if(!file.exists()) {\n\t    \ttry {\n\t\t\t\tsystem.out.println(file.createnewfile());\n\t\t\t} catch (ioexception e) {\n\t\t\t\t// todo auto-generated catch block\n\t\t\t\te.printstacktrace();\n\t\t\t}\n\t    }\n\t\t\n\t\tproperties properties = new properties();\n\t\ttry {\n\t\t\tfileinputstream in = new fileinputstream(file);\n\t\t\tfileoutputstream out = new fileoutputstream(file);\n\t\t\tproperties.load(in);\n\t\t\tin.close();\n\t\t\tproperties.setproperty("key1", "value1");\n\t\t\tproperties.store(out, "this is first commoned!");\n\t\t\tout.close();\n\t\t\t\n\t\t\tsystem.out.println(properties.getproperty("key1"));\n\t\t\t\n\t\t\titerator<string> it=prop.stringpropertynames().iterator();\n             while(it.hasnext()){\n                 string key=it.next();\n                 system.out.println(key+":"+prop.getproperty(key));\n             }\n\t\t\t\n\t\t\tproperties.clear();\n\t\t\t\n\t\t\tsystem.out.println(properties.getproperty("key1"));\n\t\t\t\n\t\t} catch (filenotfoundexception e) {\n\t\t\t// todo auto-generated catch block\n\t\t\te.printstacktrace();\n\t\t} catch (ioexception e) {\n\t\t\t// todo auto-generated catch block\n\t\t\te.printstacktrace();\n\t\t}\n\t\t\n\t\t\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n执行结果：\n\ntrue\nvalue1\nkey1:value1\nnull\n\n\n1\n2\n3\n4\n\n\n# 还可以这样\n\npublic static void main(string args[]) {\n      properties capitals = new properties();\n      set states;\n      string str;\n      \n      capitals.put("illinois", "springfield");\n      capitals.put("missouri", "jefferson city");\n      capitals.put("washington", "olympia");\n      capitals.put("california", "sacramento");\n      capitals.put("indiana", "indianapolis");\n \n      // show all states and capitals in hashtable.\n      states = capitals.keyset(); // get set-view of keys\n      iterator itr = states.iterator();\n      while(itr.hasnext()) {\n         str = (string) itr.next();\n         system.out.println("the capital of " +\n            str + " is " + capitals.getproperty(str) + ".");\n      }\n      system.out.println();\n \n      // look for state not in list -- specify default\n      str = capitals.getproperty("florida", "not found");\n      system.out.println("the capital of florida is "\n          + str + ".");\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n输出结果为：\n\nthe capital of missouri is jefferson city.\nthe capital of illinois is springfield.\nthe capital of indiana is indianapolis.\nthe capital of california is sacramento.\nthe capital of washington is olympia.\n\nthe capital of florida is not found.\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"10/17/2022",lastUpdatedTimestamp:1665997159e3},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:25:02.000Z",permalink:"/pages/870746/",categories:["编程基础","Kotlin"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/08.Kotlin/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/08.Kotlin/00.测试.md",key:"v-7568ef57",path:"/pages/870746/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:25:21.000Z",permalink:"/pages/96e35a/",categories:["编程基础","Dart"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/09.Dart/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/09.Dart/00.测试.md",key:"v-76f45877",path:"/pages/96e35a/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:25:40.000Z",permalink:"/pages/952ffa/",categories:["编程基础","C++"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/10.C++/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/10.C++/00.测试.md",key:"v-72defc83",path:"/pages/952ffa/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:25:56.000Z",permalink:"/pages/478433/",categories:["编程基础","Js"],tags:[null],readingShow:"top"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/11.Js/00.%E6%B5%8B%E8%AF%95.html",relativePath:"01.编程基础/11.Js/00.测试.md",key:"v-9b28a652",path:"/pages/478433/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Application基础",frontmatter:{title:"Application基础",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/0d8b25/",categories:["Android","四大组件","Application"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/00.Application/00.Application%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/00.四大组件/00.Application/00.Application基础.md",key:"v-8c4a9152",path:"/pages/0d8b25/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/29/2022",lastUpdatedTimestamp:166704324e4},{title:"Activity基础",frontmatter:{title:"Activity基础",date:"2022-10-10T14:28:27.000Z",permalink:"/pages/67f43d/",categories:["Android","四大组件","Activity"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/01.Activity/00.Activity%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/00.四大组件/01.Activity/00.Activity基础.md",key:"v-5cbd4661",path:"/pages/67f43d/",headers:[{level:2,title:"正常生命周期流程",slug:"正常生命周期流程",normalizedTitle:"正常生命周期流程",charIndex:1308},{level:3,title:"A进入B",slug:"a进入b",normalizedTitle:"a进入b",charIndex:1354},{level:3,title:"B退到后台",slug:"b退到后台",normalizedTitle:"b退到后台",charIndex:1365},{level:3,title:"B返回前台",slug:"b返回前台",normalizedTitle:"b返回前台",charIndex:1377},{level:3,title:"B返回A",slug:"b返回a",normalizedTitle:"b返回a",charIndex:1389},{level:3,title:"A出现不完全覆盖弹窗时",slug:"a出现不完全覆盖弹窗时",normalizedTitle:"a出现不完全覆盖弹窗时",charIndex:1400},{level:2,title:"特殊情况",slug:"特殊情况",normalizedTitle:"特殊情况",charIndex:1518},{level:3,title:"Activity重新启动",slug:"activity重新启动",normalizedTitle:"activity重新启动",charIndex:1541},{level:3,title:"启动模式导致Activity实例复用",slug:"启动模式导致activity实例复用",normalizedTitle:"启动模式导致activity实例复用",charIndex:1590},{level:2,title:"其他回调",slug:"其他回调",normalizedTitle:"其他回调",charIndex:1890},{level:3,title:"onEnterAnimationComplete()",slug:"onenteranimationcomplete",normalizedTitle:"onenteranimationcomplete()",charIndex:1137},{level:3,title:"onLowMemory()",slug:"onlowmemory",normalizedTitle:"onlowmemory()",charIndex:1167},{level:3,title:"onTrimMemory(level: Int)",slug:"ontrimmemory-level-int",normalizedTitle:"ontrimmemory(level: int)",charIndex:1184},{level:3,title:"onConfigurationChanged(newConfig: Configuration)",slug:"onconfigurationchanged-newconfig-configuration",normalizedTitle:"onconfigurationchanged(newconfig: configuration)",charIndex:1212},{level:3,title:"onWindowFocusChanged(hasFocus: Boolean)",slug:"onwindowfocuschanged-hasfocus-boolean",normalizedTitle:"onwindowfocuschanged(hasfocus: boolean)",charIndex:1264},{level:2,title:"启动模式",slug:"启动模式",normalizedTitle:"启动模式",charIndex:527},{level:3,title:"standard",slug:"standard",normalizedTitle:"standard",charIndex:4969},{level:3,title:"singleTop",slug:"singletop",normalizedTitle:"singletop",charIndex:5517},{level:3,title:"singleTask",slug:"singletask",normalizedTitle:"singletask",charIndex:5530},{level:3,title:"singleInstance",slug:"singleinstance",normalizedTitle:"singleinstance",charIndex:5544},{level:3,title:"singleInstancePerTask",slug:"singleinstancepertask",normalizedTitle:"singleinstancepertask",charIndex:5562},{level:2,title:"启动其他应用",slug:"启动其他应用",normalizedTitle:"启动其他应用",charIndex:20989},{level:3,title:"android:allowTaskReparenting",slug:"android-allowtaskreparenting",normalizedTitle:"android:allowtaskreparenting",charIndex:22932},{level:2,title:"Activity的启动方式",slug:"activity的启动方式",normalizedTitle:"activity的启动方式",charIndex:24202},{level:3,title:"显式启动",slug:"显式启动",normalizedTitle:"显式启动",charIndex:24245},{level:3,title:"隐式启动",slug:"隐式启动",normalizedTitle:"隐式启动",charIndex:24253},{level:3,title:"启动其他应用",slug:"启动其他应用-2",normalizedTitle:"启动其他应用",charIndex:20989},{level:4,title:"包名，特定Activity名拉起",slug:"包名-特定activity名拉起",normalizedTitle:"包名，特定activity名拉起",charIndex:25155},{level:4,title:"包名拉起（这里就是进去启动页）",slug:"包名拉起-这里就是进去启动页",normalizedTitle:"包名拉起（这里就是进去启动页）",charIndex:25521},{level:4,title:"url拉起",slug:"url拉起",normalizedTitle:"url拉起",charIndex:25743},{level:3,title:"子进程启动Activity",slug:"子进程启动activity",normalizedTitle:"子进程启动activity",charIndex:26299},{level:2,title:"A -> B",slug:"a-b",normalizedTitle:"a -&gt; b",charIndex:null},{level:2,title:"B 返回值给 A",slug:"b-返回值给-a",normalizedTitle:"b 返回值给 a",charIndex:27770},{level:2,title:"Activity Results API写法",slug:"activity-results-api写法",normalizedTitle:"activity results api写法",charIndex:29499},{level:2,title:"APP启动流程",slug:"app启动流程",normalizedTitle:"app启动流程",charIndex:603},{level:2,title:"Activity启动流程",slug:"activity启动流程",normalizedTitle:"activity启动流程",charIndex:614},{level:2,title:"生命周期回调的源码逻辑梳理",slug:"生命周期回调的源码逻辑梳理",normalizedTitle:"生命周期回调的源码逻辑梳理",charIndex:630},{level:2,title:"如何退出app后不再最近使用中保留",slug:"如何退出app后不再最近使用中保留",normalizedTitle:"如何退出app后不再最近使用中保留",charIndex:30937},{level:2,title:"屏蔽所有configChange项",slug:"屏蔽所有configchange项",normalizedTitle:"屏蔽所有configchange项",charIndex:31206},{level:2,title:"硬件加速",slug:"硬件加速",normalizedTitle:"硬件加速",charIndex:32722},{level:2,title:"禁用多窗口",slug:"禁用多窗口",normalizedTitle:"禁用多窗口",charIndex:33192},{level:2,title:"设置屏幕方向",slug:"设置屏幕方向",normalizedTitle:"设置屏幕方向",charIndex:33245},{level:2,title:"Activity不保存数据，避免Fragment重新加载出现问题",slug:"activity不保存数据-避免fragment重新加载出现问题",normalizedTitle:"activity不保存数据，避免fragment重新加载出现问题",charIndex:34714},{level:2,title:"设置通用主题",slug:"设置通用主题",normalizedTitle:"设置通用主题",charIndex:35210},{level:2,title:"Activity的键盘弹出/收起的处理",slug:"activity的键盘弹出-收起的处理",normalizedTitle:"activity的键盘弹出/收起的处理",charIndex:35449},{level:2,title:"将一个 Activity 设置成窗口的样式",slug:"将一个-activity-设置成窗口的样式",normalizedTitle:"将一个 activity 设置成窗口的样式",charIndex:36851}],headersStr:"正常生命周期流程 A进入B B退到后台 B返回前台 B返回A A出现不完全覆盖弹窗时 特殊情况 Activity重新启动 启动模式导致Activity实例复用 其他回调 onEnterAnimationComplete() onLowMemory() onTrimMemory(level: Int) onConfigurationChanged(newConfig: Configuration) onWindowFocusChanged(hasFocus: Boolean) 启动模式 standard singleTop singleTask singleInstance singleInstancePerTask 启动其他应用 android:allowTaskReparenting Activity的启动方式 显式启动 隐式启动 启动其他应用 包名，特定Activity名拉起 包名拉起（这里就是进去启动页） url拉起 子进程启动Activity A -> B B 返回值给 A Activity Results API写法 APP启动流程 Activity启动流程 生命周期回调的源码逻辑梳理 如何退出app后不再最近使用中保留 屏蔽所有configChange项 硬件加速 禁用多窗口 设置屏幕方向 Activity不保存数据，避免Fragment重新加载出现问题 设置通用主题 Activity的键盘弹出/收起的处理 将一个 Activity 设置成窗口的样式",content:'# 写在前面\n\n我确实无法定位Activity的功能职责，因为我讲不清楚它到底是什么？\n\n从代码层次看，它是个基类，我们实现一个新的界面的时候就是从继承它开始，然后结合的它生命周期的接口进行功能开发。\n\n从它的职责上看，它就是一个用户交互界面，负责处理用户的点击、滑动、输入等事件并给出相应的UI效果响应。\n\n从设计的角度来看，它是窗口(Window)的给出来的代理使者，将复杂的UI相关的数据处理集成在底层， 然后提供上层一个简单的接口setContentView(R.layout.activity_main)来实现界面的搭建。\n\n所以，它的基本使用很简单，我们开发者只需要简单一行代码就可以写个界面在手机上跑出效果来了。跑出来的这个界面就是Activity。\n\n那么，在应用开发层面，这个庞大的类我们需要掌握多少呢？就我而言，我认为以下几个点必须要掌握：\n\n * 生命周期：在不同的场景下，会有怎样的回调；回调的顺序是怎么样的；结合View的绘制过程，什么时候能对View做操作?\n * 任务栈：如果看过一些Activity的文章，就会对任务栈有点印象，但不多！但是这个确认是一个需要掌握的知识点，无它，这涉及到面试里面的必问题：Activity的启动模式有哪几种？简单说下。\n * Activity之间的数据传输：这个很常见了\n * 待补充...\n\n如果想再深入点，可以学习下以下知识点：\n\n * APP启动流程\n * Activity启动流程\n * 生命周期回调的源码逻辑梳理\n\n\n# 生命周期\n\n生命周期的文章有很多，我这里没有产生新的东西，如果你已经掌握了，可以直接看下个章节。\n\n\n\n首先，从官网盗张图来镇场子。\n\n从图中，可以看出，主要的生命周期有以下几个：\n\n * onCreate\n * onStart\n * onRestart\n * onResume\n * onPause\n * onStop\n * onDestory\n\n从生命周期的角度来看，只有这几个是没有问题的，但是光凭这几个，我们还是无法满足日常开发的一些要求。所以我们在这个基础上面加了以下几个方法回调：\n\n * attachBaseContext(newBase: Context?)\n * onAttachedToWindow()\n * onDetachedFromWindow()\n * onApplyThemeResource(theme: Resources.Theme?, resid: Int, first: Boolean)\n * onNewIntent(intent: Intent?)\n\n还有一部分不常用的但是我觉有有必要记住的，下面会对这部分的回调单独讲解。\n\n * onEnterAnimationComplete()\n * onLowMemory()\n * onTrimMemory(level: Int)\n * onConfigurationChanged(newConfig: Configuration)\n * onWindowFocusChanged(hasFocus: Boolean)\n\n\n# 正常生命周期流程\n\n我们假设现在有AActivity，BActivity两个界面。\n\n\n# A进入B\n\n\n\n\n# B退到后台\n\n\n\n\n# B返回前台\n\n\n\n\n# B返回A\n\n\n\n\n# A出现不完全覆盖弹窗时\n\n这里需要注意的是：\n\n普通弹窗不会回调到 onPause ！！！\n\n普通弹窗不会回调到 onPause ！！！\n\n普通弹窗不会回调到 onPause ！！！\n\n这里我是用的弹出权限申请弹窗测试的。\n\n\n\n\n# 特殊情况\n\n特殊情况我把它分为两种：\n\n * Activity重新启动：也就是其他文章常说Activity在配置发生变化后重新创建的情况\n * 启动模式导致Activity实例复用：\n\n\n# Activity重新启动\n\n引起这个现象的原因有很多，我们这里举个最常见的场景来验证它：旋转屏幕。\n\n\n\n\n# 启动模式导致Activity实例复用\n\n启动模式的影响在两个方面：\n\n * Activity是否重用\n * 任务栈的处理\n\n这里我们就不考虑任务栈的问题了，只考虑一种情况：Activity重用情况下的生命周期。\n\n那么自己跳转自己的生命周期如下：\n\n\n\n这里，我们就补充到了一个新的回调：\n\n * onNewIntent(intent: Intent?)\n\n当复用Activity实例时，就会调用到onNewIntent回调方法。\n\n\n# 其他回调\n\n\n# onEnterAnimationComplete()\n\n从名字可以看出：进入动画完成回调\n\n其实，这里的进入动画是window的进入动画，简单来说就是，我们的Activity切换到前台后会调用它。（就是Activity的Window从后台切换到前台时）\n\n\n# onLowMemory()\n\n从名字可以看出：低内存回调\n\n在这个时候，我们就需要对我们的app做一下内存清除的处理，不然的话，就有可能被kill掉。\n\n\n# onTrimMemory(level: Int)\n\n从名字可以看出：内存修剪回调\n\n作用是提醒开发者系统内存不足了。\n\n其中，level的参数有以下几种：\n\n * TRIM_MEMORY_UI_HIDDEN：App 的所有 UI 界面被隐藏，最常见的就是 App 被 home 键或者 back 键，置换到后台了。\n * TRIM_MEMORY_RUNNING_MODERATE：表示 App 正常运行，并且不会被杀掉，但是目前手机内存已经有点低了，系统可能会根据 LRU List 来开始杀进程。\n * TRIM_MEMORY_RUNNING_LOW：表示 App正常运行，并且不会被杀掉。但是目前手机内存已经非常低了。\n * TRIM_MEMORY_RUNNING_CRITICAL：表示 App 正在正常运行，但是系统已经开始根据 LRU List 的缓存规则杀掉了一部分缓存的进程。这个时候应该尽可能的释放掉不需要的内存资源，否者系统可能会继续杀掉其他缓存中的进程。\n * TRIM_MEMORY_BACKGROUND：表示 App 退出到后台，并且已经处于 LRU List 比较靠后的位置，暂时前面还有一些其他的 App 进程，暂时不用担心被杀掉\n * TRIM_MENORY_MODERATE：表示 App 退出到后台，并且已经处于 LRU List 中间的位置，如果手机内存仍然不够的话，还是有被杀掉的风险的。\n * TRIM_MEMORY_COMPLETE：表示 App 退出到后台，并且已经处于 LRU List 比较考靠前的位置，并且手机内存已经极低，随时都有可能被系统杀掉。\n\n系统中LowMemoryKiller 策略：App 退出到后台之后不占用 cpu 资源但是任然会占用内存空间。当系统内存不足的时候，会按照优先级清理进程。\n\nApp 将内存使用降低可以提高优先级，实现不被系统回收的功能。\n\n\n# onConfigurationChanged(newConfig: Configuration)\n\n从名字可以看出：配置改变回调\n\n不过在回调方法之前，我们首先需要在清单文件中配置哪些变化需要回调。\n\n列出 Activity 将自行处理的配置变更。在运行时发生配置变更时，默认情况下会关闭 activity 并将其重启，但使用该属性声明配置将阻止 activity 重启。相反，activity 会保持运行状态，并且系统会调用其 onConfigurationChanged() 方法。\n\n任何或所有下列字符串均是该属性的有效值。若有多个值，则使用“|”进行分隔，例如“locale|navigation|orientation”。\n\n值                      说明\n“density”              显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 API 级别 24 中引入。\n“fontScale”            字体缩放系数发生变更 - 用户已选择新的全局字号。\n“keyboard”             键盘类型发生变更 - 例如，用户插入外置键盘。\n“keyboardHidden”       键盘无障碍功能发生变更 - 例如，用户显示硬键盘。\n“layoutDirection”      布局方向发生变更 - 例如，自从左至右 (LTR) 更改为从右至左 (RTL)。在 API 级别 17 中引入。\n“locale”               语言区域发生变更 - 用户已为文本选择新的显示语言。\n“mcc”                  IMSI 移动设备国家/地区代码 (MCC) 发生变更 - 检测到 SIM 并更新 MCC。\n“mnc”                  IMSI 移动设备网络代码 (MNC) 发生变更 - 检测到 SIM 并更新 MNC。\n“navigation”           导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。）\n“orientation”          屏幕方向发生变更 - 用户旋转设备。注意：如果应用面向 Android 3.2（API 级别\n                       13）或更高版本的系统，则还应声明 "screenLayout" 和 "screenSize"\n                       配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。\n“screenLayout”         屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。\n“screenSize”           当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在\n                       API 级别 13 中引入。\n“smallestScreenSize”   物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应\n                       smallestWidth 配置的变化。在 API 级别 13 中引入。\n“touchscreen”          触摸屏发生变更。（这种情况通常不会发生。）\n“uiMode”               界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅\n                       UiModeManager。在 API 级别 8 中引入。\n\n所有这些配置变更都可能影响应用所看到的资源值。因此，调用 onConfigurationChanged() 时，通常有必要再次检索所有资源（包括视图布局、可绘制对象等），以正确处理变更。\n\n\n# onWindowFocusChanged(hasFocus: Boolean)\n\n这个回调就更容易理解了，在当前Activity的焦点变化之后就会回调。\n\n\n# 任务栈\n\n首先，什么是任务栈。\n\n任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。\n\n\n\n那我们怎么知道，当前app的任务栈的内容呢？ 官方提供了这样的命令给到我们\n\nadb shell dumpsys activity package <your.package.name>\n\n\n1\n\n\n在输出结果里面，我们可以找到以下信息（简化版）\n\n  * Task{4d18976 #798 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}\n    * Hist  #3: ActivityRecord{aa59564 u0 cc.fastcv.codelab/.DActivity} t798}\n    * Hist  #2: ActivityRecord{bca6d96 u0 cc.fastcv.codelab/.CActivity} t798}\n    * Hist  #1: ActivityRecord{c4e05b u0 cc.fastcv.codelab/.BActivity} t798}\n    * Hist  #0: ActivityRecord{35fcb7f u0 cc.fastcv.codelab/.MainActivity} t798}\n\n\n1\n2\n3\n4\n5\n\n\n那这个模块为啥要单独拎出来说呢？这个就涉及到了面试的另外一个重点，Activity的启动模式了。\n\n\n# 启动模式\n\n安卓官方文档里面，关于Activity配置的启动模式有五种：\n\n * standard\n * singleTop\n * singleTask\n * singleInstance\n * singleInstancePerTask\n\n\n# standard\n\n使用此启动模式的Activity可以实例化多次，每次启动都会在任务栈顶新增一个实例，比如现有有 MainActivity、BActivity、CActivity、DActivity四个Activity。\n\n启动顺序为： Main -> B -> C -> D\n\n都是standard启动模式时的任务栈是\n\n  * Task{4d18976 #798 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}\n    * Hist  #3: ActivityRecord{aa59564 u0 cc.fastcv.codelab/.DActivity} t798}\n    * Hist  #2: ActivityRecord{bca6d96 u0 cc.fastcv.codelab/.CActivity} t798}\n    * Hist  #1: ActivityRecord{c4e05b u0 cc.fastcv.codelab/.BActivity} t798}\n    * Hist  #0: ActivityRecord{35fcb7f u0 cc.fastcv.codelab/.MainActivity} t798}\n\n\n1\n2\n3\n4\n5\n\n\n\n# singleTop\n\n这种启动模式跟standard其实差不多，唯一不同的是，如果当前栈顶的示例就是当前Activity的示例，就不会重新创建，直接复用栈顶的示例。，比如现有有 MainActivity、BActivity、CActivity、DActivity四个Activity。\n\nstandard模式下\n\n启动顺序为： Main -> B -> C ->C->B -> C->C\n\n  * Task{976512b #847 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=6}\n        Hist  #5: ActivityRecord{cbc3787 u0 cc.fastcv.codelab/.CActivity} t847}\n        Hist  #5: ActivityRecord{cbc3762 u0 cc.fastcv.codelab/.CActivity} t847}\n        Hist  #4: ActivityRecord{31ec276 u0 cc.fastcv.codelab/.BActivity} t847}\n        Hist  #3: ActivityRecord{c9e4943 u0 cc.fastcv.codelab/.CActivity} t847}\n        Hist  #2: ActivityRecord{a9d611d u0 cc.fastcv.codelab/.CActivity} t847}\n        Hist  #1: ActivityRecord{70bdae8 u0 cc.fastcv.codelab/.BActivity} t847}\n        Hist  #0: ActivityRecord{da3db5b u0 cc.fastcv.codelab/.MainActivity} t847}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将C改为singleTop模式之后\n\n * Task{76f3d47 #848 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=5}\n    * Hist  #4: ActivityRecord{2b85a58 u0 cc.fastcv.codelab/.CActivity} t848}\n    * Hist  #3: ActivityRecord{80e2c86 u0 cc.fastcv.codelab/.BActivity} t848}\n    * Hist  #2: ActivityRecord{5af6a25 u0 cc.fastcv.codelab/.CActivity} t848}\n    * Hist  #1: ActivityRecord{d961f7a u0 cc.fastcv.codelab/.BActivity} t848}\n    * Hist  #0: ActivityRecord{c9c37bf u0 cc.fastcv.codelab/.MainActivity} t848}\n\n\n1\n2\n3\n4\n5\n6\n\n\n对比之后可以看到，C并没有连续的重复出现，而是隔着出现。这个就是singleTop启动模式的作用。\n\n\n# singleTask\n\n在理解了singleTop之后，这个就很好理解了，从名字就可以看出来，任务唯一，意思就是在当前的任务栈里面是唯一的，如果之前存在，就直接退栈退到这个实例为止。\n\n启动顺序为： Main -> B -> C ->D，其中，把B的启动模式改为singleTask\n\n  * Task{c4bf0ad #849 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}\n    * Hist  #3: ActivityRecord{490860e u0 cc.fastcv.codelab/.DActivity} t849}\n    * Hist  #2: ActivityRecord{a9fd862 u0 cc.fastcv.codelab/.CActivity} t849}\n    * Hist  #1: ActivityRecord{2452d77 u0 cc.fastcv.codelab/.BActivity} t849}\n    * Hist  #0: ActivityRecord{f969540 u0 cc.fastcv.codelab/.MainActivity} t849}\n\n\n1\n2\n3\n4\n5\n\n\n再从D跳转到B\n\n  * Task{c4bf0ad #849 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{2452d77 u0 cc.fastcv.codelab/.BActivity} t849}\n    * Hist  #0: ActivityRecord{f969540 u0 cc.fastcv.codelab/.MainActivity} t849}\n\n\n1\n2\n3\n\n\n从结果可以看出，重新进入B时，会把B上面的所有任务全部推出栈，直到B为止。\n\n我们这个时候按返回键会发现，只需要按两次就可以返回到桌面了。\n\n\n# singleInstance\n\n这个就比较少见了，它的作用就是启动一个单独的任务栈，然后把这个任务放进去，并且不允许其他任务放入。\n\n启动顺序为： Main -> B -> C ->D，其中，把B的启动模式改为singleInstance\n\n  * Task{698b7d #850 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=3}\n    * Hist  #2: ActivityRecord{dcaa77d u0 cc.fastcv.codelab/.DActivity} t850}\n    * Hist  #1: ActivityRecord{b819914 u0 cc.fastcv.codelab/.CActivity} t850}\n    * Hist  #0: ActivityRecord{c8610be u0 cc.fastcv.codelab/.MainActivity} t850}\n\n  * Task{4a5f831 #851 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{6308cd8 u0 cc.fastcv.codelab/.BActivity} t851}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到，B处于一个单独的任务栈中。\n\n那这里我就有个问题了，我们按返回键的时候，从C返回之后是到哪个？ 从B返回之后是到哪个？\n\n我们分别来测试下。\n\n * 从C返回 ：\n\n  * Task{e33376d #852 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=3}\n    * Hist  #2: ActivityRecord{7d2d056 u0 cc.fastcv.codelab/.DActivity} t852}\n    * Hist  #1: ActivityRecord{bb0fc21 u0 cc.fastcv.codelab/.CActivity} t852}\n    * Hist  #0: ActivityRecord{f9ce443 u0 cc.fastcv.codelab/.MainActivity} t852}\n\n  * Task{20a505b #853 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{e0fe36a u0 cc.fastcv.codelab/.BActivity} t853}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n  * Task{e33376d #852 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{f9ce443 u0 cc.fastcv.codelab/.MainActivity} t852}\n\n  * Task{20a505b #853 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{e0fe36a u0 cc.fastcv.codelab/.BActivity} t853}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，直接到了MainActivity了，并没有直接到BActivity。\n\n那我们再返回呢？\n\n  * Task{20a505b #853 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{e0fe36a u0 cc.fastcv.codelab/.BActivity} t853}\n\n\n1\n2\n\n\n可以看到，返回到了BActivity了？ 这个很奇怪呀！！\n\nMain返回之后不是到桌面了吗？为啥到B了？\n\n这里就又涉及到了一个任务栈的管理，下面再试试，进入B之后返回的操作。\n\n  * Task{42c226e #855 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{afa35e9 u0 cc.fastcv.codelab/.BActivity} t855}\n\n  * Task{bdfc544 #854 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{4eeaeb9 u0 cc.fastcv.codelab/.MainActivity} t854}\n\n\n1\n2\n3\n4\n5\n\n\n  * Task{e33376d #852 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{f9ce443 u0 cc.fastcv.codelab/.MainActivity} t852}\n\n\n1\n2\n\n\n可以看到，如果有多个任务栈时，会随任务栈显示到前台的顺序来排序任务栈，那意思是不是说，如果B、C的启动模式都是singleInstance。\n\n然从Main -> B -> C -> D之后，任务栈的顺序就是\n\nTask{Main、D}\nTask{C}\nTask{B}\n\n\n1\n2\n3\n\n\n我们来验证看看。\n\n  * Task{43b0fb4 #856 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{1ae8745 u0 cc.fastcv.codelab/.DActivity} t856}\n    * Hist  #0: ActivityRecord{66788eb u0 cc.fastcv.codelab/.MainActivity} t856}\n\n  * Task{5ad4d85 #858 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    mLastPausedActivity: ActivityRecord{b1d52fc u0 cc.fastcv.codelab/.CActivity} t858}\n    isSleeping=false\n    * Hist  #0: ActivityRecord{b1d52fc u0 cc.fastcv.codelab/.CActivity} t858}\n\n  * Task{3dd45bf #857 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{ad17fde u0 cc.fastcv.codelab/.BActivity} t857}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到，和我们的猜想一致。\n\n那如果在D的基础上再启动D呢？\n\n  * Task{e4c1fc5 #890 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{d07063c u0 cc.fastcv.codelab/.DActivity} t890}\n\n  * Task{3b2b6bb #889 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}\n    * Hist  #2: ActivityRecord{16960ae u0 cc.fastcv.codelab/.CActivity} t889}\n    * Hist  #1: ActivityRecord{66caec3 u0 cc.fastcv.codelab/.BActivity} t889}\n    * Hist  #0: ActivityRecord{cef070 u0 cc.fastcv.codelab/.MainActivity} t889}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nemmmmmmmmmmmmmmmm... D是唯一的\n\n在D的基础上加上E，再启动D呢？\n\n先进入E\n\n  * Task{28f3347 #891 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=4}\n    * Hist  #3: ActivityRecord{6004d77 u0 cc.fastcv.codelab/.EActivity} t891}\n    * Hist  #2: ActivityRecord{696b648 u0 cc.fastcv.codelab/.CActivity} t891}\n    * Hist  #1: ActivityRecord{12b0869 u0 cc.fastcv.codelab/.BActivity} t891}\n    * Hist  #0: ActivityRecord{877ff2d u0 cc.fastcv.codelab/.MainActivity} t891}\n\n  * Task{6b5f8cb #892 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{258279a u0 cc.fastcv.codelab/.DActivity} t892}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n再进入D\n\n  * Task{6b5f8cb #892 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{258279a u0 cc.fastcv.codelab/.DActivity} t892}\n\n  * Task{28f3347 #891 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=4}\n    * Hist  #3: ActivityRecord{6004d77 u0 cc.fastcv.codelab/.EActivity} t891}\n    * Hist  #2: ActivityRecord{696b648 u0 cc.fastcv.codelab/.CActivity} t891}\n    * Hist  #1: ActivityRecord{12b0869 u0 cc.fastcv.codelab/.BActivity} t891}\n    * Hist  #0: ActivityRecord{877ff2d u0 cc.fastcv.codelab/.MainActivity} t891}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nemmmmmmmmmmmmmmmm... D还是唯一的\n\n那如果我在E启动D的时候，加上 FLAG_ACTIVITY_NEW_TASK 标识呢？\n\n  * Task{91dd7e3 #894 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{7763412 u0 cc.fastcv.codelab/.DActivity} t894}\n\n  * Task{db5d41d #893 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=4}\n    mLastPausedActivity: ActivityRecord{dfbeaa5 u0 cc.fastcv.codelab/.EActivity} t893}\n    isSleeping=false\n    * Hist  #3: ActivityRecord{dfbeaa5 u0 cc.fastcv.codelab/.EActivity} t893}\n    * Hist  #2: ActivityRecord{fc90780 u0 cc.fastcv.codelab/.CActivity} t893}\n    * Hist  #1: ActivityRecord{a8db5b4 u0 cc.fastcv.codelab/.BActivity} t893}\n    * Hist  #0: ActivityRecord{4005d65 u0 cc.fastcv.codelab/.MainActivity} t893}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到，毫无影响，这就刚好验证了这个启动模式的名称（singleInstance：唯一的实例）\n\n这里有个点需要注意：当一个被设置为singleInstance的Activity去启动其他的Activity的时候，其默认是自带FLAG_ACTIVITY_NEW_TASK标签的。\n\n\n# singleInstancePerTask\n\n官方的介绍是这样说的：此 activity 只能作为任务的根 activity、作为创建该任务的第一个 activity 运行，因此在任务中该 activity 只有一个实例；但是 activity 可以在不同的任务中多次实例化。\n\n前面的单独的任务和唯一实例和singleTask差不多，那这个可以在不同的任务中多次实例化这句话就是个特殊的点了。我们来验证下：\n\nMain -> B -> C -> D -> D，D的启动模式为singleInstancePerTask。\n\n  * Task{b2463f2 #881 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{f743afd u0 cc.fastcv.codelab/.DActivity} t881}\n\n  * Task{36ac7c1 #880 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}\n    * Hist  #2: ActivityRecord{f020e63 u0 cc.fastcv.codelab/.CActivity} t880}\n    * Hist  #1: ActivityRecord{bf4893d u0 cc.fastcv.codelab/.BActivity} t880}\n    * Hist  #0: ActivityRecord{491e293 u0 cc.fastcv.codelab/.MainActivity} t880}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到，如果当前任务栈已经是D了，重启进入的时候并没有多创建一个任务栈，这样就验证了 在任务中该 activity 只有一个实例 的说法。\n\n那在不同的任务中多次实例化这个说法怎么验证呢？\n\nMain -> B -> C -> D -> C->D，D的启动模式为singleInstancePerTask。进入C之后，再进入D会不会重新创建一个任务栈？会不会就是这个意思呢？\n\n  * Task{c6b8698 #883 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{b49487b u0 cc.fastcv.codelab/.DActivity} t883}\n\n  * Task{1a7b6a6 #882 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3\n    * Hist  #2: ActivityRecord{b07609b u0 cc.fastcv.codelab/.CActivity} t882}\n    * Hist  #1: ActivityRecord{d41c5f2 u0 cc.fastcv.codelab/.BActivity} t882}\n    * Hist  #0: ActivityRecord{5dbfbce u0 cc.fastcv.codelab/.MainActivity} t882}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n??? 什么鬼 ？ ，这任务栈怎么看不明白了。\n\n不急，我们再看看 Main -> B -> C -> D -> C ，D的启动模式为singleInstancePerTask。这种情况。\n\n  * Task{8222ab2 #885 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{c0e54e6 u0 cc.fastcv.codelab/.CActivity} t885}\n    * Hist  #0: ActivityRecord{5c5e4bd u0 cc.fastcv.codelab/.DActivity} t885}\n\n  * Task{a694685 #884 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}\n    * Hist  #2: ActivityRecord{67e3087 u0 cc.fastcv.codelab/.CActivity} t884}\n    * Hist  #1: ActivityRecord{9d8d39a u0 cc.fastcv.codelab/.BActivity} t884}\n    * Hist  #0: ActivityRecord{d8491f7 u0 cc.fastcv.codelab/.MainActivity} t884}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n哦，原来后面启动的Activity都会被添加到新的任务栈里面，然后又保证了singleTask的特性。所以出现了上面的那种情况，重新进入D后，由于D在栈底，所以把上面的Activity全部丢弃掉了。\n\n那，这还是没有验证到 不同的任务中多次实例化 的说法，我们改怎么去验证呢？\n\n既然不再它所在的任务栈启动它就会新建一个任务栈，那是不是我在它的基础上，进入另外一个任务栈（不包括它），再启动它就能验证了呢？我们来试下，不过在试之前，我们要学习下，怎么样去新建一个任务栈（自己指定的）。\n\n这里就需要一个标签\n\nandroid:taskAffinity\n\n\n1\n\n\ntaskAffinity是指Activity的任务栈亲和度，即任务归属，代表该Activity属于哪个任务栈。 使用场景： 1.一般根据taskAffinity重新为Activity选择宿主任务栈（与allowTaskReparenting属性配合使用） 2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据taskAffinity查找或创建一个新的具有对应taskAffinity的任务栈。\n\n**注意点：**taskAffinity一般singleTask搭配使用，当启动的Activity使用standard、singleTop属性时，如果只设置一个特殊的taskAffinity，但是启动它的时候不设置FLAG_ACTIVITY_NEW_TASK，是不会创建新任务栈。指定singleInstance模式和singleInstancePerTask加上taskAffinity则为新的任务栈命名。另外这个名字必须以:开头或者一个完整的包名com.fastcv.xxx\n\n那我们新增一个EActivity，启动它是加上FLAG_ACTIVITY_NEW_TASK，另外单独给它制定一个任务栈名称。\n\nMain -> B -> C -> D -> E->D，D的启动模式为singleInstancePerTask。这里我们分两步看看结果：\n\n先只走到E\n\n  * Task{c1fa8be #888 type=standard A=10480:cc.fastcv.codelab:test U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{1e922e6 u0 cc.fastcv.codelab/.EActivity} t888}\n\n  * Task{dc3cc0a #887 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{63e5475 u0 cc.fastcv.codelab/.DActivity} t887}\n\n  * Task{c273b35 #886 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}\n    * Hist  #2: ActivityRecord{5fd36d9 u0 cc.fastcv.codelab/.CActivity} t886}\n    * Hist  #1: ActivityRecord{63618fd u0 cc.fastcv.codelab/.BActivity} t886}\n    * Hist  #0: ActivityRecord{82a217b u0 cc.fastcv.codelab/.MainActivity} t886}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n再进入D\n\n  * Task{dc3cc0a #887 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{63e5475 u0 cc.fastcv.codelab/.DActivity} t887}\n\n  * Task{c1fa8be #888 type=standard A=10480:cc.fastcv.codelab:test U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{1e922e6 u0 cc.fastcv.codelab/.EActivity} t888}\n\n  * Task{c273b35 #886 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=3}\n    * Hist  #2: ActivityRecord{5fd36d9 u0 cc.fastcv.codelab/.CActivity} t886}\n    * Hist  #1: ActivityRecord{63618fd u0 cc.fastcv.codelab/.BActivity} t886}\n    * Hist  #0: ActivityRecord{82a217b u0 cc.fastcv.codelab/.MainActivity} t886}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从结果看，还是只存在一个D。暂时无法验证了。\n\n\n# 启动其他应用\n\n如果我们现在打开的是另外一个应用呢？任务堆栈会是怎样的。\n\n目标Activity为不同启动模式时：\n\n * standard\n\n  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{ac0d71a u0 com.umeox.myapplication/.BActivity} t944}\n    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}\n\n\n1\n2\n3\n\n * singleTop\n\n  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{2cf95e0 u0 com.umeox.myapplication/.BActivity} t944}\n    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}\n\n\n1\n2\n3\n\n * singleTask\n\n  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{90f63d4 u0 com.umeox.myapplication/.BActivity} t944}\n    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}\n\n\n1\n2\n3\n\n * singleInstance\n\n  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{9b91b31 u0 com.umeox.myapplication/.BActivity} t944}\n    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}\n\n\n1\n2\n3\n\n * singleInstancePerTask\n\n  * Task{cea3115 #952 type=standard A=10380:com.umeox.myapplication U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{2a6f35d u0 com.umeox.myapplication/.BActivity} t952}\n\n  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=1}\n    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，在跨应用跳转时，除了singleInstancePerTask还是会新建一个任务外，其他的都会在原来的任务栈里添加。\n\n\n# android:allowTaskReparenting\n\n这里为啥要提一下这个属性呢？我们先来看看它的介绍。\n\nallowTaskReparenting属性的作用是Activity的迁移。当allowTaskReparenting属性和TaskAffinity配合使用时，Activity可以从一个任务栈迁移到另一个任务栈。\n\n迁移的规则是：从一个与该Activity TaskAffinity属性不同的任务栈中迁移到与它TaskAffinity相同的任务栈中。\n\n具体点来说，现在有两个应用A和B，A启动了B的一个Activity C，然后按Home键回到桌面，然后再单击B的桌面图标，这个时候不是启动了B的主Activity，而是重新显示了已经被应用A启动的Activity C。我们也可以理解为，C从A的任务栈转移到了B的任务栈中。\n\n可以这么理解，由于A启动了C，这个时候C只能运行在A的任务栈中，但是C属于B应用，正常情况下，它的TaskAffinity值肯定不可能和A的任务栈相同，所以当B启动后，B会创建自己的任务栈，这个时候系统发现C原本想要的任务栈已经创建了，所以就把C从A的任务栈中转移过来了。\n\n我们在上面的基础上实验下，我们给目标Activity加上此属性\n\n跳转到目标，但未做打开目标应用的操作时：\n\n  * Task{5b3a04c #944 type=standard A=10480:cc.fastcv.codelab U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=2}\n    * Hist  #1: ActivityRecord{44212a3 u0 com.umeox.myapplication/.BActivity} t944}\n    * Hist  #0: ActivityRecord{93095a1 u0 cc.fastcv.codelab/.MainActivity} t944}\n\n\n1\n2\n3\n\n\n打开目标应用的操作时：\n\n  * Task{8ff9047 #955 type=standard A=10380:com.umeox.myapplication U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}\n    * Hist  #0: ActivityRecord{2250d29 u0 com.umeox.myapplication/.MainActivity} t955}\n\n\n1\n2\n\n\n可以看到，确实把目标Activity转移过去了。\n\n\n# Activity之间的数据传输\n\nActivity之间的数据传输是个非常重要的场景知识，因为一些简单的需求或者数据，我们没必要新建个单例去维持临时数据。这个时候就需要Activity之间的数据流通了。\n\n\n# Activity的启动方式\n\n我们启动一个Activity时，有两种方式启动\n\n * 显式启动\n * 隐式启动\n\n\n# 显式启动\n\n首先我们看看显式启动的几种写法。\n\n * 常用的\n\n        startActivity(Intent(this,DActivity::class.java))\n\n\n1\n\n * 通过Intent的ComponentName\n\n        startActivity(Intent().apply {\n            component = ComponentName(this@CActivity,DActivity::class.java)\n        })\n        \n        startActivity(Intent().apply {\n            component = ComponentName("cc.fastcv.codelab","cc.fastcv.codelab.DActivity")\n        })\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 初始化Intent时指定包名\n\n        startActivity(Intent("android.intent.action.MAIN").apply {\n            setClassName("cc.fastcv.codelab","cc.fastcv.codelab.DActivity")\n        })\n\n\n1\n2\n3\n\n\n\n# 隐式启动\n\n通过Intent-filter的Action,Category或data来实现 这个是通过Intent的 intent-filter来实现的，关于Intent-filter，它适用于四大组件，所以不在Activity的范围内讲。\n\n举个例子\n\n        startActivity(Intent().apply {\n            action = "xxx.xxxx.xxx"\n            addCategory("xxx")\n        })\n\n\n1\n2\n3\n4\n\n\nintent-filter我们单独梳理一章。\n\n\n# 启动其他应用\n\n# 包名，特定Activity名拉起\n\n        startActivityForResult(Intent().apply {\n            action = Intent.ACTION_MAIN\n            component =\n                ComponentName("com.umeox.myapplication", "com.umeox.myapplication.BActivity")\n            putExtra("Name", "xiaohei")\n        }, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\nB应用需要在manifest文件对应Activity添加\n\n       android:exported="true"\n\n\n1\n\n\n# 包名拉起（这里就是进去启动页）\n\n        packageManager.getLaunchIntentForPackage("com.umeox.myapplication")?.let {\n            startActivity(it.apply {\n                putExtra("Name", "xiaohei")\n            })\n        }\n\n\n1\n2\n3\n4\n5\n\n\n# url拉起\n\n        startActivity(Intent().apply {\n            data = Uri.parse("csd://pull.csd.demo/cyn?type=110")\n            putExtra("Name", "xiaohei")\n        })\n\n\n1\n2\n3\n4\n\n\nB应用需要在manifest文件对应Activity添加\n\n<intent-filter>\n    <data\n        android:host="pull.csd.demo"\n        android:path="/cyn"\n        android:scheme="csd" />\n    <action android:name="android.intent.action.VIEW" />\n    <category android:name="android.intent.category.DEFAULT" />\n    <category android:name="android.intent.category.BROWSABLE" />\n</intent-filter>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 子进程启动Activity\n\n清单配置\n\n        <activity android:name=".BActivity"\n            android:process=":test"\n            android:taskAffinity=":test"\n            android:exported="true"/>\n\n\n1\n2\n3\n4\n\n\n启动\n\n            startActivity(Intent(this,BActivity::class.java).apply {\n                component =\n                    ComponentName("cc.fastcv.codelab", "cc.fastcv.codelab.BActivity")\n                flags = Intent.FLAG_ACTIVITY_NEW_TASK\n            })\n\n\n1\n2\n3\n4\n5\n\n\n此时，子进程奔溃了不会导致主进程奔溃。\n\n\n# A -> B\n\n从A传入数据到B还是比较简单的，还记得Activity的启动方式吗？我们不管怎么操作，都是依赖的 Intent 来启动的Activity。这是因为在安卓平台中， Intent 代表的是意图的意思，我们后面启动其他组件时也需要这个，接收的时候也是解读Intent里面的内容。\n\n所以，我们要传入参数时，携带数据的载体就是 Intent。它提供了一系列的putExtra方法。我们只需要传入对应的参数即可。如：\n\n    override fun onClick(v: View?) {\n        Log.d(TAG, "传入值")\n        startActivity(Intent(this,DActivity::class.java).apply {\n            putExtra("Name","xiaohei")\n        })\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n与之对应的是一系列的getXxxxExtra的读取方法。如：在DActivity中的onCreate方法中，我们就可以读取\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Log.d(TAG, "onCreate: ")\n\n        val stringExtra = intent.getStringExtra("Name")?:""\n        Log.d(TAG, "onCreate: $stringExtra")\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n2022-10-14 15:57:23.893 9851-9851/cc.fastcv.codelab D/CActivity: 传入值\n2022-10-14 15:57:23.940 9851-9851/cc.fastcv.codelab D/DActivity: onCreate: xiaohei\n\n\n1\n2\n\n\n这里需要注意的是：没有读取到的时候，会返回一个空值，需要处理！！\n\n\n# B 返回值给 A\n\n如果要返回值的话，就需要用到几个新的API。\n\n首先，启动Activity的方法从startActivity改为了startActivityForResult，如：\n\n        Log.d(TAG, "传入值")\n        startActivityForResult(Intent(this,DActivity::class.java).apply {\n            putExtra("Name","xiaohei")\n        },1000)\n\n\n1\n2\n3\n4\n\n\n这里的1000是个请求码，用来在接收返回值时做区分时使用的。因为我们可以会有多个返回值过来，在不知道响应码的情况下，我们可以用请求码来做区分。\n\n上面的代码是传值，那刚提到的接收值怎么操作呢？这个就是一个新的回调：\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        if (requestCode == 1000) {\n            data?.let {\n                Log.d(TAG, "获取返回值: ${it.getStringExtra("result")}")\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们在Activity中重写这个方法。\n\n最后就是DActivity发送返回值的方式了。我们需要这样子传入返回值\n\n        setResult(1000,Intent().putExtra("result","这是返回值"))\n        finish()\n\n\n1\n2\n\n\n在关闭Activity的时候，先setResult再finish就可以传入返回值并关闭当前Activity了。\n\n2022-10-14 16:17:44.071 11948-11948/cc.fastcv.codelab D/CActivity: 传入值\n2022-10-14 16:17:44.114 11948-11948/cc.fastcv.codelab D/DActivity: onCreate: xiaohei\n2022-10-14 16:17:50.456 11948-11948/cc.fastcv.codelab D/CActivity: 获取返回值: 这是返回值\n\n\n1\n2\n3\n\n\n这里有些特殊情况：\n\n应用内跳转，目标Activity的启动模式不同时。\n\n * standard：可以正常返回\n * singleTop：可以正常返回\n * singleTask：如果目标Activity未启动，可以正常返回；如果已经启动了且在同一个任务栈，无法正常返回\n * singleInstance：可以正常返回\n * singleInstancePerTask：无法正常返回\n\n不同应用内跳转，目标Activity的启动模式不同时。\n\n * standard：可以正常返回\n * singleTop：可以正常返回\n * singleTask：可以正常返回\n * singleInstance：可以正常返回\n * singleInstancePerTask：无法正常返回\n\n总结来说就是：在同一个任务栈中（且调用Activity存在的情况）才能正常返回，否则就无法正常返回。\n\n这里需要注意：传值可以跨任务，但是返回值无法跨任务传递，比如我们启动的Activity的启动模式会单独启动一个任务栈，这个时候就会直接回调onActivityResult，并没有返回值。然后传递数据时，需要注意大小限制：通过 intent 发送数据时，应小心地将数据大小限制为几 KB。发送过多数据会导致系统抛出 TransactionTooLargeException 异常。\n\n\n# Activity Results API写法\n\n在Android应用程序开发中，启动一个Activity不一定是单项操作，从启动的Activity获取数据是常见的场景，最传统的方式是通过Intent携带数据，然后使用startActivityForResult方法来启动下一个Activity，然后通过onActivityResult来接收返回的结果，代码如下：\n\n调用startActivityForResult方法启动\n\n startActivityForResult(intent,1)\n\n\n1\n\n\n实现onActivityResult方法\n\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        if(resultCode == 1 && resultCode == Activity.RESULT_OK){\n            // 处理第二个页面带回的数据\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上方式，onActivityResult就能获取从上一个界面返回的数据，这种方式非常有用，不仅能同一个应用中，也可以从其他应用中获取数据，比如我们常见的，调用系统相机、相册获取照片，获取系统通讯录等。\n\n这种好是好，但是每次都要处理 requestCode 、resultCode，做区分，代码堆积一堆逻辑判断，查看起来头疼，于是，官方推出了 Activity Results API。\n\n这个内容很多，涉及的模块也很广，所以会有一篇文章单独详细的写。这里只挑出 传值相关的 API 来讲。\n\n优化之后的代码就是这样的\n\n    private val myActivityLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()){ result ->\n        result.data?.let {\n            Log.d(TAG, "获取返回值: ${it.getStringExtra("result")}")\n        }\n    }\n\n    override fun onClick(v: View?) {\n        Log.d(TAG, "传入值")\n        myActivityLauncher.launch(Intent().apply {\n            data = Uri.parse("csd://pull.csd.demo/cyn?type=110")\n            putExtra("Name", "xiaohei")\n        })\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n不再需要onActivityResult方法来做值回调处理了。\n\n\n# 深入学习Activity\n\n\n# APP启动流程\n\n待补充...\n\n\n# Activity启动流程\n\n待补充...\n\n\n# 生命周期回调的源码逻辑梳理\n\n待补充...\n\n\n# 场景小技巧\n\n\n# 如何退出app后不再最近使用中保留\n\n在Activity标签的属性中，有这样一个属性\n\nandroid:autoRemoveFromRecents\n\n\n1\n\n\n由具有该属性的 Activity 启动的任务是否一直保留在最近任务中，直至任务中的最后一个 Activity 完成为止。若为 true，则自动从概览屏幕中移除任务。它会替换调用方使用的 FLAG_ACTIVITY_RETAIN_IN_RECENTS。它必须是布尔值“true”或“false”。\n\n所以，我们只需要在根Activity上加上这个属性设置为true即可。\n\n\n# 屏蔽所有configChange项\n\n稍微做过点开发的都应该知道，在清单文件中的目标Activity上设置\n\nandroid:configChanges\n\n\n1\n\n\n标签的值，就可以避免这个Activity在某种场景下不用重新创建。那这些值有哪些呢？\n\n值                      说明\n“density”              显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 API 级别 24 中引入。\n“fontScale”            字体缩放系数发生变更 - 用户已选择新的全局字号。\n“keyboard”             键盘类型发生变更 - 例如，用户插入外置键盘。\n“keyboardHidden”       键盘无障碍功能发生变更 - 例如，用户显示硬键盘。\n“layoutDirection”      布局方向发生变更 - 例如，自从左至右 (LTR) 更改为从右至左 (RTL)。在 API 级别 17 中引入。\n“locale”               语言区域发生变更 - 用户已为文本选择新的显示语言。\n“mcc”                  IMSI 移动设备国家/地区代码 (MCC) 发生变更 - 检测到 SIM 并更新 MCC。\n“mnc”                  IMSI 移动设备网络代码 (MNC) 发生变更 - 检测到 SIM 并更新 MNC。\n“navigation”           导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。）\n“orientation”          屏幕方向发生变更 - 用户旋转设备。注意：如果应用面向 Android 3.2（API 级别\n                       13）或更高版本的系统，则还应声明 "screenLayout" 和 "screenSize"\n                       配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。\n“screenLayout”         屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。\n“screenSize”           当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在\n                       API 级别 13 中引入。\n“smallestScreenSize”   物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应\n                       smallestWidth 配置的变化。在 API 级别 13 中引入。\n“touchscreen”          触摸屏发生变更。（这种情况通常不会发生。）\n“uiMode”               界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅\n                       UiModeManager。在 API 级别 8 中引入。\n\n如果，你屏蔽它不是为了防止Activity重新创建，而是想自己单独处理的话，请在Activity中重写 onConfigurationChanged 方法，然后做区分处理即可。\n\n\n# 硬件加速\n\n相信大家在解决某些UI问题的时候，经常会看到说 关闭/开启硬件加速 的说法，有个一劳永逸的方法，我们直接在Activity层面 关闭/开启硬件加速\n\nandroid:hardwareAccelerated\n\n\n1\n\n\n是否应为此 Activity 启用硬件加速渲染 -“true”表示应启用，“false”表示不应启用。默认值为“false”。\n\n自 Android 3.0 开始，应用可使用经硬件加速的 OpenGL 渲染器，从而提高许多常见 2D 图形运算的性能。启用硬件加速的渲染程序后，Canvas、Paint、Xfermode、ColorFilter、Shader 和 Camera 中的大多数操作都会加速。这样可使动画和滚动更流畅并且可提高整体响应能力，即使对于没有明确使用框架的 OpenGL 库的应用也是如此。启用硬件加速需要更多资源，因此应用会占用更多内存。\n\n请注意，并非所有 OpenGL 2D 操作都会加速。如果您启用硬件加速的渲染程序，请对应用进行测试，以确保它可以毫无错误地使用该渲染程序。\n\n\n# 禁用多窗口\n\n我们可以直接使用\n\nresizeableActivity\n\n\n1\n\n\n去设置即可。\n\n\n# 设置屏幕方向\n\nandroid:screenOrientation\n\n\n1\n\n\nActivity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，则系统会忽略该属性。\n\n其值可以是下列任一字符串：\n\n“UNSPECIFIED”        默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文中所做的选择可能会有所差异。\n“behind”             与 activity 堆栈中紧接其后的 activity 的方向相同。\n“landscape”          屏幕方向为横向（显示的宽度大于高度）。\n“portrait”           屏幕方向为纵向（显示的高度大于宽度）。\n“reverseLandscape”   屏幕方向是与正常横向方向相反的横向。 在 API 级别 9 中引入。\n“reversePortrait”    屏幕方向是与正常纵向方向相反的纵向。 在 API 级别 9 中引入。\n“sensorLandscape”    屏幕方向为横向，但可根据设备传感器调整为正常或反向的横向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 在 API\n                     级别 9 中引入。\n“sensorPortrait”     屏幕方向为纵向，但可根据设备传感器调整为正常或反向的纵向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 在 API\n                     级别 9 中引入。\n“userLandscape”      屏幕方向为横向，但可根据设备传感器和用户首选项调整为正常或反向的横向。在 API 级别 18 中引入。\n“userPortrait”       屏幕方向为纵向，但可根据设备传感器和用户首选项调整为正常或反向的纵向。 在 API 级别 18 中引入。\n“sensor”             屏幕方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。但在默认情况下，一些设备不会旋转为所有四种可能的方向。如要支持所有这四种方向，请使用\n                     "fullSensor"。即使用户锁定基于传感器的旋转，系统仍可使用传感器。\n“fullSensor”         屏幕方向由使用 4 种方向中任一方向的设备方向传感器决定。 这与 "sensor"\n                     类似，不同之处在于无论设备在正常情况下使用哪种方向，该值均支持所有 4\n                     种可能的屏幕方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但其支持这些方向）。在 API 级别 9 中引入。\n“nosensor”           确定屏幕方向时不考虑物理方向传感器。系统会忽略传感器，因此显示内容不会随用户手持设备的方向而旋转。\n“user”               用户当前的首选方向。\n“fullUser”           如果用户锁定基于传感器的旋转，则其行为与 user 相同，否则，其行为与 fullSensor 相同，并且支持所有 4\n                     种可能的屏幕方向。 在 API 级别 18 中引入。\n“locked”             将方向锁定在其当前的任意旋转方向。在 API 级别 18 中引入。\n\n\n# Activity不保存数据，避免Fragment重新加载出现问题\n\nandroid:screenOrientation\n\n\n1\n\n\n能否在不保存 Activity 状态的情况下将其终止并成功重新启动 -“true”表示可在不考虑其之前状态的情况下重新启动，“false”表示需要之前状态。默认值为“false”。\n\n正常情况下，为保存资源而暂时关闭 Activity 前，系统会调用其 onSaveInstanceState() 方法。该方法会将 Activity 的当前状态存储在一个 Bundle 对象中，然后在 Activity 重启时将其传递给 onCreate()。如果将该属性设置为“true”，则系统可能不会调用 onSaveInstanceState()，并且会向 onCreate() 传递 null（而非 Bundle）- 这与 activity 首次启动时的情况完全相同。\n\n“true”设置可确保 Activity 能够在未保留状态时重启。例如，显示主屏幕的 Activity 可以使用该设置，确保系统不会在该 Activity 因某种原因而崩溃时将其移除。\n\n\n# 设置通用主题\n\nandroid:theme\n\n\n1\n\n\n对定义 Activity 总体主题的样式资源的引用。此属性会自动将 Activity 的场景设置为使用该主题（请参阅 setTheme()），并且还可引发 Activity 启动前的“启动”动画（以更加符合 Activity 的实际外观）。\n\n如果未设置该属性，则 Activity 会继承通过 <application> 元素的 theme 属性为应用整体设置的主题。如果同样未设置该属性，则使用默认系统主题。\n\n\n# Activity的键盘弹出/收起的处理\n\nandroid:windowSoftInputMode\n\n\n1\n\n\nActivity 的主窗口与包含屏幕软键盘的窗口之间的交互方式。该属性的设置会影响两点内容：\n\n * 当 Activity 成为用户注意的焦点时软键盘的状态 - 隐藏还是可见。\n * 对 Activity 主窗口所做的调整 - 是否将其尺寸调小，为软键盘腾出空间；或当软键盘遮盖部分窗口时，是否平移其内容以使当前焦点可见。\n\n该设置必须是下表所列的其中一项值，或一个“state...”值加上一个“adjust...”值的组合。在任一组中设置多个值（例如，多个“state...”值）均会产生未定义的结果。各个值之间用竖线 (|) 分隔。例如：\n\n<activity android:windowSoftInputMode="stateVisible|adjustResize" ... >\n\n\n1\n\n\n此处设置的值（“stateUnspecified”和“adjustUnspecified”除外）会替换主题中设置的值。\n\n值                      说明\n“stateUnspecified”     不指定软键盘的状态（隐藏还是可见）。系统会选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。\n“stateUnchanged”       当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。\n“stateHidden”          当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity\n                       而返回时）隐藏软键盘。\n“stateAlwaysHidden”    当 activity 的主窗口有输入焦点时始终隐藏软键盘。\n“stateVisible”         当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity\n                       而返回时）显示软键盘。\n“stateAlwaysVisible”   当窗口获得输入焦点时，会显示软键盘。\n“adjustUnspecified”    不指定 Activity\n                       的主窗口是否通过调整尺寸为软键盘腾出空间，或者是否通过平移窗口内容以在屏幕上显示当前焦点。根据窗口的内容是否存在任何可滚动其内容的布局视图，系统会自动选择其中一种模式。如果存在这种视图，系统会调整窗口尺寸，前提是可通过滚动操作在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。\n“adjustResize”         始终调整 Activity 主窗口的尺寸，以为屏幕上的软键盘腾出空间。\n“adjustPan”            不通过调整 Activity\n                       主窗口的尺寸为软键盘腾出空间。相反，窗口的内容会自动平移，使键盘永远无法遮盖当前焦点，以便用户始终能看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之进行交互。\n\n\n# 将一个 Activity 设置成窗口的样式\n\n只需要给我们的 Activity 配置如下属性即可。 android:theme="@android:style/Theme.Dialog"',normalizedContent:'# 写在前面\n\n我确实无法定位activity的功能职责，因为我讲不清楚它到底是什么？\n\n从代码层次看，它是个基类，我们实现一个新的界面的时候就是从继承它开始，然后结合的它生命周期的接口进行功能开发。\n\n从它的职责上看，它就是一个用户交互界面，负责处理用户的点击、滑动、输入等事件并给出相应的ui效果响应。\n\n从设计的角度来看，它是窗口(window)的给出来的代理使者，将复杂的ui相关的数据处理集成在底层， 然后提供上层一个简单的接口setcontentview(r.layout.activity_main)来实现界面的搭建。\n\n所以，它的基本使用很简单，我们开发者只需要简单一行代码就可以写个界面在手机上跑出效果来了。跑出来的这个界面就是activity。\n\n那么，在应用开发层面，这个庞大的类我们需要掌握多少呢？就我而言，我认为以下几个点必须要掌握：\n\n * 生命周期：在不同的场景下，会有怎样的回调；回调的顺序是怎么样的；结合view的绘制过程，什么时候能对view做操作?\n * 任务栈：如果看过一些activity的文章，就会对任务栈有点印象，但不多！但是这个确认是一个需要掌握的知识点，无它，这涉及到面试里面的必问题：activity的启动模式有哪几种？简单说下。\n * activity之间的数据传输：这个很常见了\n * 待补充...\n\n如果想再深入点，可以学习下以下知识点：\n\n * app启动流程\n * activity启动流程\n * 生命周期回调的源码逻辑梳理\n\n\n# 生命周期\n\n生命周期的文章有很多，我这里没有产生新的东西，如果你已经掌握了，可以直接看下个章节。\n\n\n\n首先，从官网盗张图来镇场子。\n\n从图中，可以看出，主要的生命周期有以下几个：\n\n * oncreate\n * onstart\n * onrestart\n * onresume\n * onpause\n * onstop\n * ondestory\n\n从生命周期的角度来看，只有这几个是没有问题的，但是光凭这几个，我们还是无法满足日常开发的一些要求。所以我们在这个基础上面加了以下几个方法回调：\n\n * attachbasecontext(newbase: context?)\n * onattachedtowindow()\n * ondetachedfromwindow()\n * onapplythemeresource(theme: resources.theme?, resid: int, first: boolean)\n * onnewintent(intent: intent?)\n\n还有一部分不常用的但是我觉有有必要记住的，下面会对这部分的回调单独讲解。\n\n * onenteranimationcomplete()\n * onlowmemory()\n * ontrimmemory(level: int)\n * onconfigurationchanged(newconfig: configuration)\n * onwindowfocuschanged(hasfocus: boolean)\n\n\n# 正常生命周期流程\n\n我们假设现在有aactivity，bactivity两个界面。\n\n\n# a进入b\n\n\n\n\n# b退到后台\n\n\n\n\n# b返回前台\n\n\n\n\n# b返回a\n\n\n\n\n# a出现不完全覆盖弹窗时\n\n这里需要注意的是：\n\n普通弹窗不会回调到 onpause ！！！\n\n普通弹窗不会回调到 onpause ！！！\n\n普通弹窗不会回调到 onpause ！！！\n\n这里我是用的弹出权限申请弹窗测试的。\n\n\n\n\n# 特殊情况\n\n特殊情况我把它分为两种：\n\n * activity重新启动：也就是其他文章常说activity在配置发生变化后重新创建的情况\n * 启动模式导致activity实例复用：\n\n\n# activity重新启动\n\n引起这个现象的原因有很多，我们这里举个最常见的场景来验证它：旋转屏幕。\n\n\n\n\n# 启动模式导致activity实例复用\n\n启动模式的影响在两个方面：\n\n * activity是否重用\n * 任务栈的处理\n\n这里我们就不考虑任务栈的问题了，只考虑一种情况：activity重用情况下的生命周期。\n\n那么自己跳转自己的生命周期如下：\n\n\n\n这里，我们就补充到了一个新的回调：\n\n * onnewintent(intent: intent?)\n\n当复用activity实例时，就会调用到onnewintent回调方法。\n\n\n# 其他回调\n\n\n# onenteranimationcomplete()\n\n从名字可以看出：进入动画完成回调\n\n其实，这里的进入动画是window的进入动画，简单来说就是，我们的activity切换到前台后会调用它。（就是activity的window从后台切换到前台时）\n\n\n# onlowmemory()\n\n从名字可以看出：低内存回调\n\n在这个时候，我们就需要对我们的app做一下内存清除的处理，不然的话，就有可能被kill掉。\n\n\n# ontrimmemory(level: int)\n\n从名字可以看出：内存修剪回调\n\n作用是提醒开发者系统内存不足了。\n\n其中，level的参数有以下几种：\n\n * trim_memory_ui_hidden：app 的所有 ui 界面被隐藏，最常见的就是 app 被 home 键或者 back 键，置换到后台了。\n * trim_memory_running_moderate：表示 app 正常运行，并且不会被杀掉，但是目前手机内存已经有点低了，系统可能会根据 lru list 来开始杀进程。\n * trim_memory_running_low：表示 app正常运行，并且不会被杀掉。但是目前手机内存已经非常低了。\n * trim_memory_running_critical：表示 app 正在正常运行，但是系统已经开始根据 lru list 的缓存规则杀掉了一部分缓存的进程。这个时候应该尽可能的释放掉不需要的内存资源，否者系统可能会继续杀掉其他缓存中的进程。\n * trim_memory_background：表示 app 退出到后台，并且已经处于 lru list 比较靠后的位置，暂时前面还有一些其他的 app 进程，暂时不用担心被杀掉\n * trim_menory_moderate：表示 app 退出到后台，并且已经处于 lru list 中间的位置，如果手机内存仍然不够的话，还是有被杀掉的风险的。\n * trim_memory_complete：表示 app 退出到后台，并且已经处于 lru list 比较考靠前的位置，并且手机内存已经极低，随时都有可能被系统杀掉。\n\n系统中lowmemorykiller 策略：app 退出到后台之后不占用 cpu 资源但是任然会占用内存空间。当系统内存不足的时候，会按照优先级清理进程。\n\napp 将内存使用降低可以提高优先级，实现不被系统回收的功能。\n\n\n# onconfigurationchanged(newconfig: configuration)\n\n从名字可以看出：配置改变回调\n\n不过在回调方法之前，我们首先需要在清单文件中配置哪些变化需要回调。\n\n列出 activity 将自行处理的配置变更。在运行时发生配置变更时，默认情况下会关闭 activity 并将其重启，但使用该属性声明配置将阻止 activity 重启。相反，activity 会保持运行状态，并且系统会调用其 onconfigurationchanged() 方法。\n\n任何或所有下列字符串均是该属性的有效值。若有多个值，则使用“|”进行分隔，例如“locale|navigation|orientation”。\n\n值                      说明\n“density”              显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 api 级别 24 中引入。\n“fontscale”            字体缩放系数发生变更 - 用户已选择新的全局字号。\n“keyboard”             键盘类型发生变更 - 例如，用户插入外置键盘。\n“keyboardhidden”       键盘无障碍功能发生变更 - 例如，用户显示硬键盘。\n“layoutdirection”      布局方向发生变更 - 例如，自从左至右 (ltr) 更改为从右至左 (rtl)。在 api 级别 17 中引入。\n“locale”               语言区域发生变更 - 用户已为文本选择新的显示语言。\n“mcc”                  imsi 移动设备国家/地区代码 (mcc) 发生变更 - 检测到 sim 并更新 mcc。\n“mnc”                  imsi 移动设备网络代码 (mnc) 发生变更 - 检测到 sim 并更新 mnc。\n“navigation”           导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。）\n“orientation”          屏幕方向发生变更 - 用户旋转设备。注意：如果应用面向 android 3.2（api 级别\n                       13）或更高版本的系统，则还应声明 "screenlayout" 和 "screensize"\n                       配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。\n“screenlayout”         屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。\n“screensize”           当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在\n                       api 级别 13 中引入。\n“smallestscreensize”   物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应\n                       smallestwidth 配置的变化。在 api 级别 13 中引入。\n“touchscreen”          触摸屏发生变更。（这种情况通常不会发生。）\n“uimode”               界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅\n                       uimodemanager。在 api 级别 8 中引入。\n\n所有这些配置变更都可能影响应用所看到的资源值。因此，调用 onconfigurationchanged() 时，通常有必要再次检索所有资源（包括视图布局、可绘制对象等），以正确处理变更。\n\n\n# onwindowfocuschanged(hasfocus: boolean)\n\n这个回调就更容易理解了，在当前activity的焦点变化之后就会回调。\n\n\n# 任务栈\n\n首先，什么是任务栈。\n\n任务是用户在执行某项工作时与之互动的一系列 activity 的集合。这些 activity 按照每个 activity 打开的顺序排列在一个返回堆栈中。\n\n\n\n那我们怎么知道，当前app的任务栈的内容呢？ 官方提供了这样的命令给到我们\n\nadb shell dumpsys activity package <your.package.name>\n\n\n1\n\n\n在输出结果里面，我们可以找到以下信息（简化版）\n\n  * task{4d18976 #798 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=4}\n    * hist  #3: activityrecord{aa59564 u0 cc.fastcv.codelab/.dactivity} t798}\n    * hist  #2: activityrecord{bca6d96 u0 cc.fastcv.codelab/.cactivity} t798}\n    * hist  #1: activityrecord{c4e05b u0 cc.fastcv.codelab/.bactivity} t798}\n    * hist  #0: activityrecord{35fcb7f u0 cc.fastcv.codelab/.mainactivity} t798}\n\n\n1\n2\n3\n4\n5\n\n\n那这个模块为啥要单独拎出来说呢？这个就涉及到了面试的另外一个重点，activity的启动模式了。\n\n\n# 启动模式\n\n安卓官方文档里面，关于activity配置的启动模式有五种：\n\n * standard\n * singletop\n * singletask\n * singleinstance\n * singleinstancepertask\n\n\n# standard\n\n使用此启动模式的activity可以实例化多次，每次启动都会在任务栈顶新增一个实例，比如现有有 mainactivity、bactivity、cactivity、dactivity四个activity。\n\n启动顺序为： main -> b -> c -> d\n\n都是standard启动模式时的任务栈是\n\n  * task{4d18976 #798 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=4}\n    * hist  #3: activityrecord{aa59564 u0 cc.fastcv.codelab/.dactivity} t798}\n    * hist  #2: activityrecord{bca6d96 u0 cc.fastcv.codelab/.cactivity} t798}\n    * hist  #1: activityrecord{c4e05b u0 cc.fastcv.codelab/.bactivity} t798}\n    * hist  #0: activityrecord{35fcb7f u0 cc.fastcv.codelab/.mainactivity} t798}\n\n\n1\n2\n3\n4\n5\n\n\n\n# singletop\n\n这种启动模式跟standard其实差不多，唯一不同的是，如果当前栈顶的示例就是当前activity的示例，就不会重新创建，直接复用栈顶的示例。，比如现有有 mainactivity、bactivity、cactivity、dactivity四个activity。\n\nstandard模式下\n\n启动顺序为： main -> b -> c ->c->b -> c->c\n\n  * task{976512b #847 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=6}\n        hist  #5: activityrecord{cbc3787 u0 cc.fastcv.codelab/.cactivity} t847}\n        hist  #5: activityrecord{cbc3762 u0 cc.fastcv.codelab/.cactivity} t847}\n        hist  #4: activityrecord{31ec276 u0 cc.fastcv.codelab/.bactivity} t847}\n        hist  #3: activityrecord{c9e4943 u0 cc.fastcv.codelab/.cactivity} t847}\n        hist  #2: activityrecord{a9d611d u0 cc.fastcv.codelab/.cactivity} t847}\n        hist  #1: activityrecord{70bdae8 u0 cc.fastcv.codelab/.bactivity} t847}\n        hist  #0: activityrecord{da3db5b u0 cc.fastcv.codelab/.mainactivity} t847}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将c改为singletop模式之后\n\n * task{76f3d47 #848 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=5}\n    * hist  #4: activityrecord{2b85a58 u0 cc.fastcv.codelab/.cactivity} t848}\n    * hist  #3: activityrecord{80e2c86 u0 cc.fastcv.codelab/.bactivity} t848}\n    * hist  #2: activityrecord{5af6a25 u0 cc.fastcv.codelab/.cactivity} t848}\n    * hist  #1: activityrecord{d961f7a u0 cc.fastcv.codelab/.bactivity} t848}\n    * hist  #0: activityrecord{c9c37bf u0 cc.fastcv.codelab/.mainactivity} t848}\n\n\n1\n2\n3\n4\n5\n6\n\n\n对比之后可以看到，c并没有连续的重复出现，而是隔着出现。这个就是singletop启动模式的作用。\n\n\n# singletask\n\n在理解了singletop之后，这个就很好理解了，从名字就可以看出来，任务唯一，意思就是在当前的任务栈里面是唯一的，如果之前存在，就直接退栈退到这个实例为止。\n\n启动顺序为： main -> b -> c ->d，其中，把b的启动模式改为singletask\n\n  * task{c4bf0ad #849 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=4}\n    * hist  #3: activityrecord{490860e u0 cc.fastcv.codelab/.dactivity} t849}\n    * hist  #2: activityrecord{a9fd862 u0 cc.fastcv.codelab/.cactivity} t849}\n    * hist  #1: activityrecord{2452d77 u0 cc.fastcv.codelab/.bactivity} t849}\n    * hist  #0: activityrecord{f969540 u0 cc.fastcv.codelab/.mainactivity} t849}\n\n\n1\n2\n3\n4\n5\n\n\n再从d跳转到b\n\n  * task{c4bf0ad #849 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{2452d77 u0 cc.fastcv.codelab/.bactivity} t849}\n    * hist  #0: activityrecord{f969540 u0 cc.fastcv.codelab/.mainactivity} t849}\n\n\n1\n2\n3\n\n\n从结果可以看出，重新进入b时，会把b上面的所有任务全部推出栈，直到b为止。\n\n我们这个时候按返回键会发现，只需要按两次就可以返回到桌面了。\n\n\n# singleinstance\n\n这个就比较少见了，它的作用就是启动一个单独的任务栈，然后把这个任务放进去，并且不允许其他任务放入。\n\n启动顺序为： main -> b -> c ->d，其中，把b的启动模式改为singleinstance\n\n  * task{698b7d #850 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=3}\n    * hist  #2: activityrecord{dcaa77d u0 cc.fastcv.codelab/.dactivity} t850}\n    * hist  #1: activityrecord{b819914 u0 cc.fastcv.codelab/.cactivity} t850}\n    * hist  #0: activityrecord{c8610be u0 cc.fastcv.codelab/.mainactivity} t850}\n\n  * task{4a5f831 #851 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{6308cd8 u0 cc.fastcv.codelab/.bactivity} t851}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到，b处于一个单独的任务栈中。\n\n那这里我就有个问题了，我们按返回键的时候，从c返回之后是到哪个？ 从b返回之后是到哪个？\n\n我们分别来测试下。\n\n * 从c返回 ：\n\n  * task{e33376d #852 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=3}\n    * hist  #2: activityrecord{7d2d056 u0 cc.fastcv.codelab/.dactivity} t852}\n    * hist  #1: activityrecord{bb0fc21 u0 cc.fastcv.codelab/.cactivity} t852}\n    * hist  #0: activityrecord{f9ce443 u0 cc.fastcv.codelab/.mainactivity} t852}\n\n  * task{20a505b #853 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{e0fe36a u0 cc.fastcv.codelab/.bactivity} t853}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n  * task{e33376d #852 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{f9ce443 u0 cc.fastcv.codelab/.mainactivity} t852}\n\n  * task{20a505b #853 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{e0fe36a u0 cc.fastcv.codelab/.bactivity} t853}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，直接到了mainactivity了，并没有直接到bactivity。\n\n那我们再返回呢？\n\n  * task{20a505b #853 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{e0fe36a u0 cc.fastcv.codelab/.bactivity} t853}\n\n\n1\n2\n\n\n可以看到，返回到了bactivity了？ 这个很奇怪呀！！\n\nmain返回之后不是到桌面了吗？为啥到b了？\n\n这里就又涉及到了一个任务栈的管理，下面再试试，进入b之后返回的操作。\n\n  * task{42c226e #855 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{afa35e9 u0 cc.fastcv.codelab/.bactivity} t855}\n\n  * task{bdfc544 #854 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{4eeaeb9 u0 cc.fastcv.codelab/.mainactivity} t854}\n\n\n1\n2\n3\n4\n5\n\n\n  * task{e33376d #852 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{f9ce443 u0 cc.fastcv.codelab/.mainactivity} t852}\n\n\n1\n2\n\n\n可以看到，如果有多个任务栈时，会随任务栈显示到前台的顺序来排序任务栈，那意思是不是说，如果b、c的启动模式都是singleinstance。\n\n然从main -> b -> c -> d之后，任务栈的顺序就是\n\ntask{main、d}\ntask{c}\ntask{b}\n\n\n1\n2\n3\n\n\n我们来验证看看。\n\n  * task{43b0fb4 #856 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{1ae8745 u0 cc.fastcv.codelab/.dactivity} t856}\n    * hist  #0: activityrecord{66788eb u0 cc.fastcv.codelab/.mainactivity} t856}\n\n  * task{5ad4d85 #858 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    mlastpausedactivity: activityrecord{b1d52fc u0 cc.fastcv.codelab/.cactivity} t858}\n    issleeping=false\n    * hist  #0: activityrecord{b1d52fc u0 cc.fastcv.codelab/.cactivity} t858}\n\n  * task{3dd45bf #857 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{ad17fde u0 cc.fastcv.codelab/.bactivity} t857}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到，和我们的猜想一致。\n\n那如果在d的基础上再启动d呢？\n\n  * task{e4c1fc5 #890 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{d07063c u0 cc.fastcv.codelab/.dactivity} t890}\n\n  * task{3b2b6bb #889 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=3}\n    * hist  #2: activityrecord{16960ae u0 cc.fastcv.codelab/.cactivity} t889}\n    * hist  #1: activityrecord{66caec3 u0 cc.fastcv.codelab/.bactivity} t889}\n    * hist  #0: activityrecord{cef070 u0 cc.fastcv.codelab/.mainactivity} t889}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nemmmmmmmmmmmmmmmm... d是唯一的\n\n在d的基础上加上e，再启动d呢？\n\n先进入e\n\n  * task{28f3347 #891 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=4}\n    * hist  #3: activityrecord{6004d77 u0 cc.fastcv.codelab/.eactivity} t891}\n    * hist  #2: activityrecord{696b648 u0 cc.fastcv.codelab/.cactivity} t891}\n    * hist  #1: activityrecord{12b0869 u0 cc.fastcv.codelab/.bactivity} t891}\n    * hist  #0: activityrecord{877ff2d u0 cc.fastcv.codelab/.mainactivity} t891}\n\n  * task{6b5f8cb #892 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{258279a u0 cc.fastcv.codelab/.dactivity} t892}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n再进入d\n\n  * task{6b5f8cb #892 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{258279a u0 cc.fastcv.codelab/.dactivity} t892}\n\n  * task{28f3347 #891 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=4}\n    * hist  #3: activityrecord{6004d77 u0 cc.fastcv.codelab/.eactivity} t891}\n    * hist  #2: activityrecord{696b648 u0 cc.fastcv.codelab/.cactivity} t891}\n    * hist  #1: activityrecord{12b0869 u0 cc.fastcv.codelab/.bactivity} t891}\n    * hist  #0: activityrecord{877ff2d u0 cc.fastcv.codelab/.mainactivity} t891}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nemmmmmmmmmmmmmmmm... d还是唯一的\n\n那如果我在e启动d的时候，加上 flag_activity_new_task 标识呢？\n\n  * task{91dd7e3 #894 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{7763412 u0 cc.fastcv.codelab/.dactivity} t894}\n\n  * task{db5d41d #893 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=4}\n    mlastpausedactivity: activityrecord{dfbeaa5 u0 cc.fastcv.codelab/.eactivity} t893}\n    issleeping=false\n    * hist  #3: activityrecord{dfbeaa5 u0 cc.fastcv.codelab/.eactivity} t893}\n    * hist  #2: activityrecord{fc90780 u0 cc.fastcv.codelab/.cactivity} t893}\n    * hist  #1: activityrecord{a8db5b4 u0 cc.fastcv.codelab/.bactivity} t893}\n    * hist  #0: activityrecord{4005d65 u0 cc.fastcv.codelab/.mainactivity} t893}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到，毫无影响，这就刚好验证了这个启动模式的名称（singleinstance：唯一的实例）\n\n这里有个点需要注意：当一个被设置为singleinstance的activity去启动其他的activity的时候，其默认是自带flag_activity_new_task标签的。\n\n\n# singleinstancepertask\n\n官方的介绍是这样说的：此 activity 只能作为任务的根 activity、作为创建该任务的第一个 activity 运行，因此在任务中该 activity 只有一个实例；但是 activity 可以在不同的任务中多次实例化。\n\n前面的单独的任务和唯一实例和singletask差不多，那这个可以在不同的任务中多次实例化这句话就是个特殊的点了。我们来验证下：\n\nmain -> b -> c -> d -> d，d的启动模式为singleinstancepertask。\n\n  * task{b2463f2 #881 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{f743afd u0 cc.fastcv.codelab/.dactivity} t881}\n\n  * task{36ac7c1 #880 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=3}\n    * hist  #2: activityrecord{f020e63 u0 cc.fastcv.codelab/.cactivity} t880}\n    * hist  #1: activityrecord{bf4893d u0 cc.fastcv.codelab/.bactivity} t880}\n    * hist  #0: activityrecord{491e293 u0 cc.fastcv.codelab/.mainactivity} t880}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到，如果当前任务栈已经是d了，重启进入的时候并没有多创建一个任务栈，这样就验证了 在任务中该 activity 只有一个实例 的说法。\n\n那在不同的任务中多次实例化这个说法怎么验证呢？\n\nmain -> b -> c -> d -> c->d，d的启动模式为singleinstancepertask。进入c之后，再进入d会不会重新创建一个任务栈？会不会就是这个意思呢？\n\n  * task{c6b8698 #883 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{b49487b u0 cc.fastcv.codelab/.dactivity} t883}\n\n  * task{1a7b6a6 #882 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=3\n    * hist  #2: activityrecord{b07609b u0 cc.fastcv.codelab/.cactivity} t882}\n    * hist  #1: activityrecord{d41c5f2 u0 cc.fastcv.codelab/.bactivity} t882}\n    * hist  #0: activityrecord{5dbfbce u0 cc.fastcv.codelab/.mainactivity} t882}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n??? 什么鬼 ？ ，这任务栈怎么看不明白了。\n\n不急，我们再看看 main -> b -> c -> d -> c ，d的启动模式为singleinstancepertask。这种情况。\n\n  * task{8222ab2 #885 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{c0e54e6 u0 cc.fastcv.codelab/.cactivity} t885}\n    * hist  #0: activityrecord{5c5e4bd u0 cc.fastcv.codelab/.dactivity} t885}\n\n  * task{a694685 #884 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=3}\n    * hist  #2: activityrecord{67e3087 u0 cc.fastcv.codelab/.cactivity} t884}\n    * hist  #1: activityrecord{9d8d39a u0 cc.fastcv.codelab/.bactivity} t884}\n    * hist  #0: activityrecord{d8491f7 u0 cc.fastcv.codelab/.mainactivity} t884}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n哦，原来后面启动的activity都会被添加到新的任务栈里面，然后又保证了singletask的特性。所以出现了上面的那种情况，重新进入d后，由于d在栈底，所以把上面的activity全部丢弃掉了。\n\n那，这还是没有验证到 不同的任务中多次实例化 的说法，我们改怎么去验证呢？\n\n既然不再它所在的任务栈启动它就会新建一个任务栈，那是不是我在它的基础上，进入另外一个任务栈（不包括它），再启动它就能验证了呢？我们来试下，不过在试之前，我们要学习下，怎么样去新建一个任务栈（自己指定的）。\n\n这里就需要一个标签\n\nandroid:taskaffinity\n\n\n1\n\n\ntaskaffinity是指activity的任务栈亲和度，即任务归属，代表该activity属于哪个任务栈。 使用场景： 1.一般根据taskaffinity重新为activity选择宿主任务栈（与allowtaskreparenting属性配合使用） 2.启动一个activity过程中intent使用了flag_activity_new_task标记，根据taskaffinity查找或创建一个新的具有对应taskaffinity的任务栈。\n\n**注意点：**taskaffinity一般singletask搭配使用，当启动的activity使用standard、singletop属性时，如果只设置一个特殊的taskaffinity，但是启动它的时候不设置flag_activity_new_task，是不会创建新任务栈。指定singleinstance模式和singleinstancepertask加上taskaffinity则为新的任务栈命名。另外这个名字必须以:开头或者一个完整的包名com.fastcv.xxx\n\n那我们新增一个eactivity，启动它是加上flag_activity_new_task，另外单独给它制定一个任务栈名称。\n\nmain -> b -> c -> d -> e->d，d的启动模式为singleinstancepertask。这里我们分两步看看结果：\n\n先只走到e\n\n  * task{c1fa8be #888 type=standard a=10480:cc.fastcv.codelab:test u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{1e922e6 u0 cc.fastcv.codelab/.eactivity} t888}\n\n  * task{dc3cc0a #887 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{63e5475 u0 cc.fastcv.codelab/.dactivity} t887}\n\n  * task{c273b35 #886 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=3}\n    * hist  #2: activityrecord{5fd36d9 u0 cc.fastcv.codelab/.cactivity} t886}\n    * hist  #1: activityrecord{63618fd u0 cc.fastcv.codelab/.bactivity} t886}\n    * hist  #0: activityrecord{82a217b u0 cc.fastcv.codelab/.mainactivity} t886}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n再进入d\n\n  * task{dc3cc0a #887 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{63e5475 u0 cc.fastcv.codelab/.dactivity} t887}\n\n  * task{c1fa8be #888 type=standard a=10480:cc.fastcv.codelab:test u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{1e922e6 u0 cc.fastcv.codelab/.eactivity} t888}\n\n  * task{c273b35 #886 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=3}\n    * hist  #2: activityrecord{5fd36d9 u0 cc.fastcv.codelab/.cactivity} t886}\n    * hist  #1: activityrecord{63618fd u0 cc.fastcv.codelab/.bactivity} t886}\n    * hist  #0: activityrecord{82a217b u0 cc.fastcv.codelab/.mainactivity} t886}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从结果看，还是只存在一个d。暂时无法验证了。\n\n\n# 启动其他应用\n\n如果我们现在打开的是另外一个应用呢？任务堆栈会是怎样的。\n\n目标activity为不同启动模式时：\n\n * standard\n\n  * task{5b3a04c #944 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{ac0d71a u0 com.umeox.myapplication/.bactivity} t944}\n    * hist  #0: activityrecord{93095a1 u0 cc.fastcv.codelab/.mainactivity} t944}\n\n\n1\n2\n3\n\n * singletop\n\n  * task{5b3a04c #944 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{2cf95e0 u0 com.umeox.myapplication/.bactivity} t944}\n    * hist  #0: activityrecord{93095a1 u0 cc.fastcv.codelab/.mainactivity} t944}\n\n\n1\n2\n3\n\n * singletask\n\n  * task{5b3a04c #944 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{90f63d4 u0 com.umeox.myapplication/.bactivity} t944}\n    * hist  #0: activityrecord{93095a1 u0 cc.fastcv.codelab/.mainactivity} t944}\n\n\n1\n2\n3\n\n * singleinstance\n\n  * task{5b3a04c #944 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{9b91b31 u0 com.umeox.myapplication/.bactivity} t944}\n    * hist  #0: activityrecord{93095a1 u0 cc.fastcv.codelab/.mainactivity} t944}\n\n\n1\n2\n3\n\n * singleinstancepertask\n\n  * task{cea3115 #952 type=standard a=10380:com.umeox.myapplication u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{2a6f35d u0 com.umeox.myapplication/.bactivity} t952}\n\n  * task{5b3a04c #944 type=standard a=10480:cc.fastcv.codelab u=0 visible=false visiblerequested=false mode=fullscreen translucent=true sz=1}\n    * hist  #0: activityrecord{93095a1 u0 cc.fastcv.codelab/.mainactivity} t944}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，在跨应用跳转时，除了singleinstancepertask还是会新建一个任务外，其他的都会在原来的任务栈里添加。\n\n\n# android:allowtaskreparenting\n\n这里为啥要提一下这个属性呢？我们先来看看它的介绍。\n\nallowtaskreparenting属性的作用是activity的迁移。当allowtaskreparenting属性和taskaffinity配合使用时，activity可以从一个任务栈迁移到另一个任务栈。\n\n迁移的规则是：从一个与该activity taskaffinity属性不同的任务栈中迁移到与它taskaffinity相同的任务栈中。\n\n具体点来说，现在有两个应用a和b，a启动了b的一个activity c，然后按home键回到桌面，然后再单击b的桌面图标，这个时候不是启动了b的主activity，而是重新显示了已经被应用a启动的activity c。我们也可以理解为，c从a的任务栈转移到了b的任务栈中。\n\n可以这么理解，由于a启动了c，这个时候c只能运行在a的任务栈中，但是c属于b应用，正常情况下，它的taskaffinity值肯定不可能和a的任务栈相同，所以当b启动后，b会创建自己的任务栈，这个时候系统发现c原本想要的任务栈已经创建了，所以就把c从a的任务栈中转移过来了。\n\n我们在上面的基础上实验下，我们给目标activity加上此属性\n\n跳转到目标，但未做打开目标应用的操作时：\n\n  * task{5b3a04c #944 type=standard a=10480:cc.fastcv.codelab u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=2}\n    * hist  #1: activityrecord{44212a3 u0 com.umeox.myapplication/.bactivity} t944}\n    * hist  #0: activityrecord{93095a1 u0 cc.fastcv.codelab/.mainactivity} t944}\n\n\n1\n2\n3\n\n\n打开目标应用的操作时：\n\n  * task{8ff9047 #955 type=standard a=10380:com.umeox.myapplication u=0 visible=true visiblerequested=true mode=fullscreen translucent=false sz=1}\n    * hist  #0: activityrecord{2250d29 u0 com.umeox.myapplication/.mainactivity} t955}\n\n\n1\n2\n\n\n可以看到，确实把目标activity转移过去了。\n\n\n# activity之间的数据传输\n\nactivity之间的数据传输是个非常重要的场景知识，因为一些简单的需求或者数据，我们没必要新建个单例去维持临时数据。这个时候就需要activity之间的数据流通了。\n\n\n# activity的启动方式\n\n我们启动一个activity时，有两种方式启动\n\n * 显式启动\n * 隐式启动\n\n\n# 显式启动\n\n首先我们看看显式启动的几种写法。\n\n * 常用的\n\n        startactivity(intent(this,dactivity::class.java))\n\n\n1\n\n * 通过intent的componentname\n\n        startactivity(intent().apply {\n            component = componentname(this@cactivity,dactivity::class.java)\n        })\n        \n        startactivity(intent().apply {\n            component = componentname("cc.fastcv.codelab","cc.fastcv.codelab.dactivity")\n        })\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 初始化intent时指定包名\n\n        startactivity(intent("android.intent.action.main").apply {\n            setclassname("cc.fastcv.codelab","cc.fastcv.codelab.dactivity")\n        })\n\n\n1\n2\n3\n\n\n\n# 隐式启动\n\n通过intent-filter的action,category或data来实现 这个是通过intent的 intent-filter来实现的，关于intent-filter，它适用于四大组件，所以不在activity的范围内讲。\n\n举个例子\n\n        startactivity(intent().apply {\n            action = "xxx.xxxx.xxx"\n            addcategory("xxx")\n        })\n\n\n1\n2\n3\n4\n\n\nintent-filter我们单独梳理一章。\n\n\n# 启动其他应用\n\n# 包名，特定activity名拉起\n\n        startactivityforresult(intent().apply {\n            action = intent.action_main\n            component =\n                componentname("com.umeox.myapplication", "com.umeox.myapplication.bactivity")\n            putextra("name", "xiaohei")\n        }, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\nb应用需要在manifest文件对应activity添加\n\n       android:exported="true"\n\n\n1\n\n\n# 包名拉起（这里就是进去启动页）\n\n        packagemanager.getlaunchintentforpackage("com.umeox.myapplication")?.let {\n            startactivity(it.apply {\n                putextra("name", "xiaohei")\n            })\n        }\n\n\n1\n2\n3\n4\n5\n\n\n# url拉起\n\n        startactivity(intent().apply {\n            data = uri.parse("csd://pull.csd.demo/cyn?type=110")\n            putextra("name", "xiaohei")\n        })\n\n\n1\n2\n3\n4\n\n\nb应用需要在manifest文件对应activity添加\n\n<intent-filter>\n    <data\n        android:host="pull.csd.demo"\n        android:path="/cyn"\n        android:scheme="csd" />\n    <action android:name="android.intent.action.view" />\n    <category android:name="android.intent.category.default" />\n    <category android:name="android.intent.category.browsable" />\n</intent-filter>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 子进程启动activity\n\n清单配置\n\n        <activity android:name=".bactivity"\n            android:process=":test"\n            android:taskaffinity=":test"\n            android:exported="true"/>\n\n\n1\n2\n3\n4\n\n\n启动\n\n            startactivity(intent(this,bactivity::class.java).apply {\n                component =\n                    componentname("cc.fastcv.codelab", "cc.fastcv.codelab.bactivity")\n                flags = intent.flag_activity_new_task\n            })\n\n\n1\n2\n3\n4\n5\n\n\n此时，子进程奔溃了不会导致主进程奔溃。\n\n\n# a -> b\n\n从a传入数据到b还是比较简单的，还记得activity的启动方式吗？我们不管怎么操作，都是依赖的 intent 来启动的activity。这是因为在安卓平台中， intent 代表的是意图的意思，我们后面启动其他组件时也需要这个，接收的时候也是解读intent里面的内容。\n\n所以，我们要传入参数时，携带数据的载体就是 intent。它提供了一系列的putextra方法。我们只需要传入对应的参数即可。如：\n\n    override fun onclick(v: view?) {\n        log.d(tag, "传入值")\n        startactivity(intent(this,dactivity::class.java).apply {\n            putextra("name","xiaohei")\n        })\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n与之对应的是一系列的getxxxxextra的读取方法。如：在dactivity中的oncreate方法中，我们就可以读取\n\n    override fun oncreate(savedinstancestate: bundle?) {\n        super.oncreate(savedinstancestate)\n        setcontentview(r.layout.activity_main)\n        log.d(tag, "oncreate: ")\n\n        val stringextra = intent.getstringextra("name")?:""\n        log.d(tag, "oncreate: $stringextra")\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n2022-10-14 15:57:23.893 9851-9851/cc.fastcv.codelab d/cactivity: 传入值\n2022-10-14 15:57:23.940 9851-9851/cc.fastcv.codelab d/dactivity: oncreate: xiaohei\n\n\n1\n2\n\n\n这里需要注意的是：没有读取到的时候，会返回一个空值，需要处理！！\n\n\n# b 返回值给 a\n\n如果要返回值的话，就需要用到几个新的api。\n\n首先，启动activity的方法从startactivity改为了startactivityforresult，如：\n\n        log.d(tag, "传入值")\n        startactivityforresult(intent(this,dactivity::class.java).apply {\n            putextra("name","xiaohei")\n        },1000)\n\n\n1\n2\n3\n4\n\n\n这里的1000是个请求码，用来在接收返回值时做区分时使用的。因为我们可以会有多个返回值过来，在不知道响应码的情况下，我们可以用请求码来做区分。\n\n上面的代码是传值，那刚提到的接收值怎么操作呢？这个就是一个新的回调：\n\n    override fun onactivityresult(requestcode: int, resultcode: int, data: intent?) {\n        super.onactivityresult(requestcode, resultcode, data)\n        if (requestcode == 1000) {\n            data?.let {\n                log.d(tag, "获取返回值: ${it.getstringextra("result")}")\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们在activity中重写这个方法。\n\n最后就是dactivity发送返回值的方式了。我们需要这样子传入返回值\n\n        setresult(1000,intent().putextra("result","这是返回值"))\n        finish()\n\n\n1\n2\n\n\n在关闭activity的时候，先setresult再finish就可以传入返回值并关闭当前activity了。\n\n2022-10-14 16:17:44.071 11948-11948/cc.fastcv.codelab d/cactivity: 传入值\n2022-10-14 16:17:44.114 11948-11948/cc.fastcv.codelab d/dactivity: oncreate: xiaohei\n2022-10-14 16:17:50.456 11948-11948/cc.fastcv.codelab d/cactivity: 获取返回值: 这是返回值\n\n\n1\n2\n3\n\n\n这里有些特殊情况：\n\n应用内跳转，目标activity的启动模式不同时。\n\n * standard：可以正常返回\n * singletop：可以正常返回\n * singletask：如果目标activity未启动，可以正常返回；如果已经启动了且在同一个任务栈，无法正常返回\n * singleinstance：可以正常返回\n * singleinstancepertask：无法正常返回\n\n不同应用内跳转，目标activity的启动模式不同时。\n\n * standard：可以正常返回\n * singletop：可以正常返回\n * singletask：可以正常返回\n * singleinstance：可以正常返回\n * singleinstancepertask：无法正常返回\n\n总结来说就是：在同一个任务栈中（且调用activity存在的情况）才能正常返回，否则就无法正常返回。\n\n这里需要注意：传值可以跨任务，但是返回值无法跨任务传递，比如我们启动的activity的启动模式会单独启动一个任务栈，这个时候就会直接回调onactivityresult，并没有返回值。然后传递数据时，需要注意大小限制：通过 intent 发送数据时，应小心地将数据大小限制为几 kb。发送过多数据会导致系统抛出 transactiontoolargeexception 异常。\n\n\n# activity results api写法\n\n在android应用程序开发中，启动一个activity不一定是单项操作，从启动的activity获取数据是常见的场景，最传统的方式是通过intent携带数据，然后使用startactivityforresult方法来启动下一个activity，然后通过onactivityresult来接收返回的结果，代码如下：\n\n调用startactivityforresult方法启动\n\n startactivityforresult(intent,1)\n\n\n1\n\n\n实现onactivityresult方法\n\noverride fun onactivityresult(requestcode: int, resultcode: int, data: intent?) {\n        super.onactivityresult(requestcode, resultcode, data)\n        if(resultcode == 1 && resultcode == activity.result_ok){\n            // 处理第二个页面带回的数据\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上方式，onactivityresult就能获取从上一个界面返回的数据，这种方式非常有用，不仅能同一个应用中，也可以从其他应用中获取数据，比如我们常见的，调用系统相机、相册获取照片，获取系统通讯录等。\n\n这种好是好，但是每次都要处理 requestcode 、resultcode，做区分，代码堆积一堆逻辑判断，查看起来头疼，于是，官方推出了 activity results api。\n\n这个内容很多，涉及的模块也很广，所以会有一篇文章单独详细的写。这里只挑出 传值相关的 api 来讲。\n\n优化之后的代码就是这样的\n\n    private val myactivitylauncher = registerforactivityresult(activityresultcontracts.startactivityforresult()){ result ->\n        result.data?.let {\n            log.d(tag, "获取返回值: ${it.getstringextra("result")}")\n        }\n    }\n\n    override fun onclick(v: view?) {\n        log.d(tag, "传入值")\n        myactivitylauncher.launch(intent().apply {\n            data = uri.parse("csd://pull.csd.demo/cyn?type=110")\n            putextra("name", "xiaohei")\n        })\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n不再需要onactivityresult方法来做值回调处理了。\n\n\n# 深入学习activity\n\n\n# app启动流程\n\n待补充...\n\n\n# activity启动流程\n\n待补充...\n\n\n# 生命周期回调的源码逻辑梳理\n\n待补充...\n\n\n# 场景小技巧\n\n\n# 如何退出app后不再最近使用中保留\n\n在activity标签的属性中，有这样一个属性\n\nandroid:autoremovefromrecents\n\n\n1\n\n\n由具有该属性的 activity 启动的任务是否一直保留在最近任务中，直至任务中的最后一个 activity 完成为止。若为 true，则自动从概览屏幕中移除任务。它会替换调用方使用的 flag_activity_retain_in_recents。它必须是布尔值“true”或“false”。\n\n所以，我们只需要在根activity上加上这个属性设置为true即可。\n\n\n# 屏蔽所有configchange项\n\n稍微做过点开发的都应该知道，在清单文件中的目标activity上设置\n\nandroid:configchanges\n\n\n1\n\n\n标签的值，就可以避免这个activity在某种场景下不用重新创建。那这些值有哪些呢？\n\n值                      说明\n“density”              显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 api 级别 24 中引入。\n“fontscale”            字体缩放系数发生变更 - 用户已选择新的全局字号。\n“keyboard”             键盘类型发生变更 - 例如，用户插入外置键盘。\n“keyboardhidden”       键盘无障碍功能发生变更 - 例如，用户显示硬键盘。\n“layoutdirection”      布局方向发生变更 - 例如，自从左至右 (ltr) 更改为从右至左 (rtl)。在 api 级别 17 中引入。\n“locale”               语言区域发生变更 - 用户已为文本选择新的显示语言。\n“mcc”                  imsi 移动设备国家/地区代码 (mcc) 发生变更 - 检测到 sim 并更新 mcc。\n“mnc”                  imsi 移动设备网络代码 (mnc) 发生变更 - 检测到 sim 并更新 mnc。\n“navigation”           导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。）\n“orientation”          屏幕方向发生变更 - 用户旋转设备。注意：如果应用面向 android 3.2（api 级别\n                       13）或更高版本的系统，则还应声明 "screenlayout" 和 "screensize"\n                       配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。\n“screenlayout”         屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。\n“screensize”           当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在\n                       api 级别 13 中引入。\n“smallestscreensize”   物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应\n                       smallestwidth 配置的变化。在 api 级别 13 中引入。\n“touchscreen”          触摸屏发生变更。（这种情况通常不会发生。）\n“uimode”               界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅\n                       uimodemanager。在 api 级别 8 中引入。\n\n如果，你屏蔽它不是为了防止activity重新创建，而是想自己单独处理的话，请在activity中重写 onconfigurationchanged 方法，然后做区分处理即可。\n\n\n# 硬件加速\n\n相信大家在解决某些ui问题的时候，经常会看到说 关闭/开启硬件加速 的说法，有个一劳永逸的方法，我们直接在activity层面 关闭/开启硬件加速\n\nandroid:hardwareaccelerated\n\n\n1\n\n\n是否应为此 activity 启用硬件加速渲染 -“true”表示应启用，“false”表示不应启用。默认值为“false”。\n\n自 android 3.0 开始，应用可使用经硬件加速的 opengl 渲染器，从而提高许多常见 2d 图形运算的性能。启用硬件加速的渲染程序后，canvas、paint、xfermode、colorfilter、shader 和 camera 中的大多数操作都会加速。这样可使动画和滚动更流畅并且可提高整体响应能力，即使对于没有明确使用框架的 opengl 库的应用也是如此。启用硬件加速需要更多资源，因此应用会占用更多内存。\n\n请注意，并非所有 opengl 2d 操作都会加速。如果您启用硬件加速的渲染程序，请对应用进行测试，以确保它可以毫无错误地使用该渲染程序。\n\n\n# 禁用多窗口\n\n我们可以直接使用\n\nresizeableactivity\n\n\n1\n\n\n去设置即可。\n\n\n# 设置屏幕方向\n\nandroid:screenorientation\n\n\n1\n\n\nactivity 在设备上的显示方向。如果 activity 是在多窗口模式下运行，则系统会忽略该属性。\n\n其值可以是下列任一字符串：\n\n“unspecified”        默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文中所做的选择可能会有所差异。\n“behind”             与 activity 堆栈中紧接其后的 activity 的方向相同。\n“landscape”          屏幕方向为横向（显示的宽度大于高度）。\n“portrait”           屏幕方向为纵向（显示的高度大于宽度）。\n“reverselandscape”   屏幕方向是与正常横向方向相反的横向。 在 api 级别 9 中引入。\n“reverseportrait”    屏幕方向是与正常纵向方向相反的纵向。 在 api 级别 9 中引入。\n“sensorlandscape”    屏幕方向为横向，但可根据设备传感器调整为正常或反向的横向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 在 api\n                     级别 9 中引入。\n“sensorportrait”     屏幕方向为纵向，但可根据设备传感器调整为正常或反向的纵向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 在 api\n                     级别 9 中引入。\n“userlandscape”      屏幕方向为横向，但可根据设备传感器和用户首选项调整为正常或反向的横向。在 api 级别 18 中引入。\n“userportrait”       屏幕方向为纵向，但可根据设备传感器和用户首选项调整为正常或反向的纵向。 在 api 级别 18 中引入。\n“sensor”             屏幕方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。但在默认情况下，一些设备不会旋转为所有四种可能的方向。如要支持所有这四种方向，请使用\n                     "fullsensor"。即使用户锁定基于传感器的旋转，系统仍可使用传感器。\n“fullsensor”         屏幕方向由使用 4 种方向中任一方向的设备方向传感器决定。 这与 "sensor"\n                     类似，不同之处在于无论设备在正常情况下使用哪种方向，该值均支持所有 4\n                     种可能的屏幕方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但其支持这些方向）。在 api 级别 9 中引入。\n“nosensor”           确定屏幕方向时不考虑物理方向传感器。系统会忽略传感器，因此显示内容不会随用户手持设备的方向而旋转。\n“user”               用户当前的首选方向。\n“fulluser”           如果用户锁定基于传感器的旋转，则其行为与 user 相同，否则，其行为与 fullsensor 相同，并且支持所有 4\n                     种可能的屏幕方向。 在 api 级别 18 中引入。\n“locked”             将方向锁定在其当前的任意旋转方向。在 api 级别 18 中引入。\n\n\n# activity不保存数据，避免fragment重新加载出现问题\n\nandroid:screenorientation\n\n\n1\n\n\n能否在不保存 activity 状态的情况下将其终止并成功重新启动 -“true”表示可在不考虑其之前状态的情况下重新启动，“false”表示需要之前状态。默认值为“false”。\n\n正常情况下，为保存资源而暂时关闭 activity 前，系统会调用其 onsaveinstancestate() 方法。该方法会将 activity 的当前状态存储在一个 bundle 对象中，然后在 activity 重启时将其传递给 oncreate()。如果将该属性设置为“true”，则系统可能不会调用 onsaveinstancestate()，并且会向 oncreate() 传递 null（而非 bundle）- 这与 activity 首次启动时的情况完全相同。\n\n“true”设置可确保 activity 能够在未保留状态时重启。例如，显示主屏幕的 activity 可以使用该设置，确保系统不会在该 activity 因某种原因而崩溃时将其移除。\n\n\n# 设置通用主题\n\nandroid:theme\n\n\n1\n\n\n对定义 activity 总体主题的样式资源的引用。此属性会自动将 activity 的场景设置为使用该主题（请参阅 settheme()），并且还可引发 activity 启动前的“启动”动画（以更加符合 activity 的实际外观）。\n\n如果未设置该属性，则 activity 会继承通过 <application> 元素的 theme 属性为应用整体设置的主题。如果同样未设置该属性，则使用默认系统主题。\n\n\n# activity的键盘弹出/收起的处理\n\nandroid:windowsoftinputmode\n\n\n1\n\n\nactivity 的主窗口与包含屏幕软键盘的窗口之间的交互方式。该属性的设置会影响两点内容：\n\n * 当 activity 成为用户注意的焦点时软键盘的状态 - 隐藏还是可见。\n * 对 activity 主窗口所做的调整 - 是否将其尺寸调小，为软键盘腾出空间；或当软键盘遮盖部分窗口时，是否平移其内容以使当前焦点可见。\n\n该设置必须是下表所列的其中一项值，或一个“state...”值加上一个“adjust...”值的组合。在任一组中设置多个值（例如，多个“state...”值）均会产生未定义的结果。各个值之间用竖线 (|) 分隔。例如：\n\n<activity android:windowsoftinputmode="statevisible|adjustresize" ... >\n\n\n1\n\n\n此处设置的值（“stateunspecified”和“adjustunspecified”除外）会替换主题中设置的值。\n\n值                      说明\n“stateunspecified”     不指定软键盘的状态（隐藏还是可见）。系统会选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。\n“stateunchanged”       当 activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。\n“statehidden”          当用户选择 activity 时（换言之，当用户确实是向前导航到 activity，而不是因离开另一 activity\n                       而返回时）隐藏软键盘。\n“statealwayshidden”    当 activity 的主窗口有输入焦点时始终隐藏软键盘。\n“statevisible”         当用户选择 activity 时（换言之，当用户确实是向前导航到 activity，而不是因离开另一 activity\n                       而返回时）显示软键盘。\n“statealwaysvisible”   当窗口获得输入焦点时，会显示软键盘。\n“adjustunspecified”    不指定 activity\n                       的主窗口是否通过调整尺寸为软键盘腾出空间，或者是否通过平移窗口内容以在屏幕上显示当前焦点。根据窗口的内容是否存在任何可滚动其内容的布局视图，系统会自动选择其中一种模式。如果存在这种视图，系统会调整窗口尺寸，前提是可通过滚动操作在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。\n“adjustresize”         始终调整 activity 主窗口的尺寸，以为屏幕上的软键盘腾出空间。\n“adjustpan”            不通过调整 activity\n                       主窗口的尺寸为软键盘腾出空间。相反，窗口的内容会自动平移，使键盘永远无法遮盖当前焦点，以便用户始终能看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之进行交互。\n\n\n# 将一个 activity 设置成窗口的样式\n\n只需要给我们的 activity 配置如下属性即可。 android:theme="@android:style/theme.dialog"',charsets:{cjk:!0},lastUpdated:"10/29/2022",lastUpdatedTimestamp:166704324e4},{title:"广播基础",frontmatter:{title:"广播基础",date:"2022-10-10T14:28:27.000Z",permalink:"/pages/73feed/",categories:["Android","四大组件","BroadcastReceiver"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/02.BroadcastReceiver/00.%E5%B9%BF%E6%92%AD%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/00.四大组件/02.BroadcastReceiver/00.广播基础.md",key:"v-1ba8e18a",path:"/pages/73feed/",headers:[{level:2,title:"系统广播/非系统广播",slug:"系统广播-非系统广播",normalizedTitle:"系统广播/非系统广播",charIndex:620},{level:2,title:"全局广播/本地广播",slug:"全局广播-本地广播",normalizedTitle:"全局广播/本地广播",charIndex:1973},{level:3,title:"本地广播",slug:"本地广播",normalizedTitle:"本地广播",charIndex:432},{level:3,title:"广播权限",slug:"广播权限",normalizedTitle:"广播权限",charIndex:2207},{level:4,title:"带权限的发送",slug:"带权限的发送",normalizedTitle:"带权限的发送",charIndex:2275},{level:4,title:"带权限的接收",slug:"带权限的接收",normalizedTitle:"带权限的接收",charIndex:2750},{level:3,title:"指定包名",slug:"指定包名",normalizedTitle:"指定包名",charIndex:3506},{level:2,title:"有序广播/无序广播",slug:"有序广播-无序广播",normalizedTitle:"有序广播/无序广播",charIndex:3918},{level:3,title:"无序广播",slug:"无序广播",normalizedTitle:"无序广播",charIndex:447},{level:3,title:"有序广播",slug:"有序广播",normalizedTitle:"有序广播",charIndex:440},{level:2,title:"静态注册",slug:"静态注册",normalizedTitle:"静态注册",charIndex:4824},{level:2,title:"动态注册",slug:"动态注册",normalizedTitle:"动态注册",charIndex:4322},{level:2,title:"Android 9",slug:"android-9",normalizedTitle:"android 9",charIndex:7371},{level:2,title:"Android 8.0",slug:"android-8-0",normalizedTitle:"android 8.0",charIndex:7574},{level:2,title:"Android 7.0",slug:"android-7-0",normalizedTitle:"android 7.0",charIndex:7713},{level:2,title:"广播收到回调后不能开子线程做操作？开携程呢？",slug:"广播收到回调后不能开子线程做操作-开携程呢",normalizedTitle:"广播收到回调后不能开子线程做操作？开携程呢？",charIndex:7943}],headersStr:"系统广播/非系统广播 全局广播/本地广播 本地广播 广播权限 带权限的发送 带权限的接收 指定包名 有序广播/无序广播 无序广播 有序广播 静态注册 动态注册 Android 9 Android 8.0 Android 7.0 广播收到回调后不能开子线程做操作？开携程呢？",content:'# 写在前面\n\n什么是广播？ 下课时间到了，全校的铃声都响了，这个是铃声被广播出去了，被在校的人接收到了下课的信号；村里要开会，村长在喇叭里面喊，消息通知到了全村，村长要传递的消息通过广播传给了在村子里面的人。\n\n广播就是我们理解的广播，直接字面意思，它将消息传递出去，给到每个可以接收到的对象，每个对象对这个消息单独做处理。\n\n从上面的描述，我们可以抽取出广播中关键的两个点。\n\n * 广播发送者\n * 广播接收者\n\n其中，四大组件中的BroadcastRecever的全称就是广播接收者，那为啥要提广播发送者呢？\n\n因为广播不止是系统可以发送，我们APP也可以发送广播出去，给到其他APP使用。\n\n所以，四大组件中的广播接收者不只是广播接收者的内容，它更应该是广播这个大的内容。\n\n这部分内容从发送者和接收者来区分。\n\n\n# 广播发送者\n\n发送者更多的是关注广播的类型。从不同的参照出发，有以下几种类别：\n\n * 系统广播 和 非系统广播\n * 全局广播 和 本地广播\n * 有序广播 和 无序广播\n\n广播消息封装在 Intent 对象中。Intent 的操作字符串必须提供应用的 Java 软件包名称语法，并唯一标识广播事件。您可以使用 putExtra(String, Bundle) 向 intent 附加其他信息。您也可以对 intent 调用 setPackage(String)，将广播限定到同一组织中的一组应用。\n\n\n# 系统广播/非系统广播\n\n * Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播\n * 每个广播都有特定的Intent - Filter（包括具体的action）\n\n当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播。如电量变化，网络变化，开关机状态等等。如网络变化的广播\n\n    private void init() {\n        LogUtil.log("注册广播");\n        IntentFilter filter = new IntentFilter();\n        filter.addAction("android.net.conn.CONNECTIVITY_CHANGE");\n        netBraodcastReceiver = new NetBraodcastReceiver();\n        registerReceiver(netBraodcastReceiver,filter);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        LogUtil.log("注销广播");\n        unregisterReceiver(netBraodcastReceiver);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这仅仅是系统广播中的一个，我们列举一下常用的系统广播：\n\n字段                                    说明\nIntent.ACTION_AIRPLANE_MODE_CHANGED   关闭或打开飞行模式时的广播\nIntent.ACTION_BATTERY_CHANGED         充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册\nIntent.ACTION_BATTERY_LOW             表示电池电量低\nIntent.ACTION_BATTERY_OKAY            表示电池电量充足，即从电池电量低变化到饱满时会发出广播\nIntent.ACTION_BOOT_COMPLETED          在系统启动完成后，这个动作被广播一次（只有一次）\nIntent.ACTION_DATE_CHANGED            设备日期发生改变时会发出此广播\nIntent.ACTION_HEADSET_PLUG            在耳机口上插入耳机时发出的广播\nIntent.ACTION_INPUT_METHOD_CHANGED    改变输入法时发出的广播\nIntent.ACTION_LOCALE_CHANGED          设备当前区域设置已更改时发出的广播\n\n而非系统广播则是由三方APP发送的广播。\n\n\n# 全局广播/本地广播\n\n默认发送的广播都是全局广播，但是这样很不安全，如果外部应用想监听这个广播也是可以的。\n\n\n# 本地广播\n\n如果这个广播只是我们APP内部使用，则可以使用本地广播：\n\nLocalBroadcastManager.sendBroadcast 方法会将广播发送给与发送器位于同一应用中的接收器。如果您不需要跨应用发送广播，请使用本地广播。这种实现方法的效率更高（无需进行进程间通信），而且您无需担心其他应用在收发您的广播时带来的任何安全问题。\n\n\n# 广播权限\n\n也可以使用权限发送广播：\n\n您可以通过权限将广播限定到拥有特定权限的一组应用。您可以对广播的发送器或接收器施加限制。\n\n# 带权限的发送\n\n当您调用 sendBroadcast(Intent, String) 或 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle) 时，可以指定权限参数。接收器若要接收此广播，则必须通过其清单中的 标记请求该权限（如果存在危险，则会被授予该权限）。例如，以下代码会发送广播：\n\n    sendBroadcast(Intent("com.example.NOTIFY"), Manifest.permission.SEND_SMS)\n\n\n1\n\n\n要接收此广播，接收方应用必须请求如下权限：\n\n<uses-permission android:name="android.permission.SEND_SMS"/>\n\n\n1\n\n\n您可以指定现有的系统权限（如 SEND_SMS），也可以使用元素定义自定义权限。\n\n**注意：**自定义权限将在安装应用时注册。定义自定义权限的应用必须在使用自定义权限的应用之前安装。\n\n# 带权限的接收\n\n如果您在注册广播接收器时指定了权限参数（通过 registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 或清单中的标记指定），则广播方必须通过其清单中的标记请求该权限（如果存在危险，则会被授予该权限），才能向该接收器发送 Intent。\n\n例如，假设您的接收方应用具有如下所示的清单声明的接收器：\n\n<receiver android:name=".MyBroadcastReceiver"\n              android:permission="android.permission.SEND_SMS">\n        <intent-filter>\n            <action android:name="android.intent.action.AIRPLANE_MODE"/>\n        </intent-filter>\n    </receiver>\n    \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n或者您的接收方应用具有如下所示的上下文注册的接收器：\n\n    var filter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED)\n    registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null )\n    \n\n\n1\n2\n3\n\n\n那么，发送方应用必须请求如下权限，才能向这些接收器发送广播：\n\n<uses-permission android:name="android.permission.SEND_SMS"/>\n\n\n1\n\n\n\n# 指定包名\n\n * 在 Android 4.0 及更高版本中，您可以在发送广播时使用 setPackage(String) 指定软件包。系统会将广播限定到与该软件包匹配的一组应用。\n\n注意：\n\n1、如果不需要向应用以外的组件发送广播，使用LocalBroadcastManager 效率更高（无需进行进程间通信）。本地广播可在应用中作为通用的发布/订阅事件总线，而不会产生任何系统级广播开销。\n\n2、优先使用上下文注册而不是清单声明， 如果有许多应用在其清单中注册接收相同的广播，可能会导致系统启动大量应用，从而对设备性能和用户体验造成严重影响。有时，Android 系统本身会强制使用上下文注册的接收器。例如，CONNECTIVITY_ACTION 广播只会传送给上下文注册的接收器。\n\n3、onRecive返回后即有可能被系统回收，如需做耗时操作，尽量使用goAsync()开启后台任务或JobScheduler\n\n\n# 有序广播/无序广播\n\n\n# 无序广播\n\n默认发送的广播都是无序广播，即同级的广播是没有固定顺序来接收这个广播的，且无法停止。\n\nsendBroadcast(Intent) 方法会按随机的顺序向所有接收器发送广播。这称为常规广播。这种方法效率更高，但也意味着接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播。\n\n\n# 有序广播\n\n而有序广播则是，一个一个的发送，中途可以停止继续发送。\n\nsendOrderedBroadcast(Intent, String) 方法一次向一个接收器发送广播。当接收器逐个顺序执行时，接收器可以向下传递结果，也可以完全中止广播，使其不再传递给其他接收器。接收器的运行顺序可以通过匹配的 intent-filter 的 android:priority 属性来控制；具有相同优先级的接收器将按随机顺序运行。\n\n广播接受者接收广播的顺序规则（同时面向静态和动态注册的广播接受者）：\n\n * 按照Priority属性值从大-小排序；\n * Priority属性相同者，动态注册的广播优先；\n\n特点：\n\n * 接收广播按顺序接收\n * 先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播；\n * 先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播\n\n有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式： sendOrderedBroadcast(intent);\n\n注意：\n\n1、第一个广播接收器使用intent.getExtras()接收数据，后面的广播接收器使用getResultExtras(true)接收数据\n\n2、是否是有序广播：isOrderedBroadcast() 3、中断广播：abortBroadcast() 4、向下级传递数据：setResultExtras(bundle)，如果不是有序广播，调用会报错 5、IntentFilter中setPriority设置优先级\n\n * 优先级对无序广播也生效\n * 无需广播，先注册先生效\n\n附加说明\n\n * Android8中使用静态注册的广播接收器接收自定义广播时，会发生接收不到自定义广播的问题,需要在Android7的代码基础上在发送广播的intent中加上这一句：\n\n//ComponentName的第一个参数是自定义广播的包名，第二个参数是广播接收器的类\nbraodcast.setComponent(new ComponentName("pkgName","ReceiverName"));\n\n\n1\n2\n\n\n\n# 广播接收者\n\n接收者主要关注 注册监听的方式：\n\n * 静态注册\n * 动态注册\n\n\n# 静态注册\n\n1、创建 BroadcastReceiver 子类并实现 onReceive(Context, Intent)。以下示例中的广播接收器会记录并显示广播的内容：\n\n    private const val TAG = "MyBroadcastReceiver"\n\n    class MyBroadcastReceiver : BroadcastReceiver() {\n\n        override fun onReceive(context: Context, intent: Intent) {\n            StringBuilder().apply {\n                append("Action: ${intent.action}\\n")\n                append("URI: ${intent.toUri(Intent.URI_INTENT_SCHEME)}\\n")\n                toString().also { log ->\n                    Log.d(TAG, log)\n                    Toast.makeText(context, log, Toast.LENGTH_LONG).show()\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n2、在应用清单中指定 元素。\n\n    <receiver android:name=".MyBroadcastReceiver"  android:exported="true">\n        <intent-filter>\n            <action android:name="android.intent.action.BOOT_COMPLETED"/>\n            <action android:name="android.intent.action.INPUT_METHOD_CHANGED" />\n        </intent-filter>\n    </receiver>\n\n\n1\n2\n3\n4\n5\n6\n\n\n系统软件包管理器会在应用安装时注册接收器。然后，该接收器会成为应用的一个独立入口点，这意味着如果应用当前未运行，系统可以启动应用并发送广播。\n\n系统会创建新的 BroadcastReceiver 组件对象来处理它接收到的每个广播。此对象仅在调用 onReceive(Context, Intent) 期间有效。一旦从此方法返回代码，系统便会认为该组件不再活跃。\n\n\n# 动态注册\n\n1、创建 BroadcastReceiver 的实例。\n\n    val br: BroadcastReceiver = MyBroadcastReceiver()\n\n\n1\n\n\n2、创建 IntentFilter 并调用 registerReceiver(BroadcastReceiver, IntentFilter) 来注册接收器：\n\n    val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply {\n        addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)\n    }\n    registerReceiver(br, filter)\n\n\n1\n2\n3\n4\n\n\n**注意：**要注册本地广播，请调用 LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)。\n\n只要静态注册有效，静态注册的接收器就会接收广播。例如，如果您在 Activity 上下文中注册，只要 Activity 没有被销毁，您就会收到广播。如果您在应用上下文中注册，只要应用在运行，您就会收到广播。\n\n3、要停止接收广播，请调用 unregisterReceiver(android.content.BroadcastReceiver)。当您不再需要接收器或上下文不再有效时，请务必注销接收器。\n\n请注意注册和注销接收器的位置，比方说，如果您使用 Activity 上下文在 onCreate(Bundle) 中注册接收器，则应在 onDestroy() 中注销，以防接收器从 Activity 上下文中泄露出去。如果您在 onResume() 中注册接收器，则应在 onPause() 中注销，以防多次注册接收器（如果您不想在暂停时接收广播，这样可以减少不必要的系统开销）。请勿在 onSaveInstanceState(Bundle) 中注销，因为如果用户在历史记录堆栈中后退，则不会调用此方法。\n\n特别注意：\n\n * 动态广播最好在Activity 的 onResume()注册、onPause()注销。\n\n * 原因：\n   \n   1.对于动态广播，有注册就必然得有注销，否则会导致内存泄露。重复注册、重复注销也不允许。\n   \n   2.在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，进而防止内存泄露。\n\n\n# 版本变更\n\n\n# Android 9\n\n从 Android 9（API 级别 28）开始，NETWORK_STATE_CHANGED_ACTION 广播不再接收有关用户位置或个人身份数据的信息。\n\n此外，如果您的应用安装在搭载 Android 9 或更高版本的设备上，则通过 WLAN 接收的系统广播不包含 SSID、BSSID、连接信息或扫描结果。要获取这些信息，请调用 getConnectionInfo()。\n\n\n# Android 8.0\n\n从 Android 8.0（API 级别 26）开始，系统对清单声明的接收器施加了额外的限制。\n\n如果您的应用以 Android 8.0 或更高版本为目标平台，那么对于大多数隐式广播（没有明确针对您的应用的广播），您不能使用清单来声明接收器。\n\n\n# Android 7.0\n\nAndroid 7.0（API 级别 24）及更高版本不发送以下系统广播：\n\n * ACTION_NEW_PICTURE\n * ACTION_NEW_VIDEO\n\n此外，以 Android 7.0 及更高版本为目标平台的应用必须使用 registerReceiver(BroadcastReceiver, IntentFilter) 注册 CONNECTIVITY_ACTION 广播。无法在清单中声明接收器。\n\n\n# 补充\n\n\n# 广播收到回调后不能开子线程做操作？开携程呢？\n\n测试在收到消息后开启子线程做了30s的工作没有任何问题。',normalizedContent:'# 写在前面\n\n什么是广播？ 下课时间到了，全校的铃声都响了，这个是铃声被广播出去了，被在校的人接收到了下课的信号；村里要开会，村长在喇叭里面喊，消息通知到了全村，村长要传递的消息通过广播传给了在村子里面的人。\n\n广播就是我们理解的广播，直接字面意思，它将消息传递出去，给到每个可以接收到的对象，每个对象对这个消息单独做处理。\n\n从上面的描述，我们可以抽取出广播中关键的两个点。\n\n * 广播发送者\n * 广播接收者\n\n其中，四大组件中的broadcastrecever的全称就是广播接收者，那为啥要提广播发送者呢？\n\n因为广播不止是系统可以发送，我们app也可以发送广播出去，给到其他app使用。\n\n所以，四大组件中的广播接收者不只是广播接收者的内容，它更应该是广播这个大的内容。\n\n这部分内容从发送者和接收者来区分。\n\n\n# 广播发送者\n\n发送者更多的是关注广播的类型。从不同的参照出发，有以下几种类别：\n\n * 系统广播 和 非系统广播\n * 全局广播 和 本地广播\n * 有序广播 和 无序广播\n\n广播消息封装在 intent 对象中。intent 的操作字符串必须提供应用的 java 软件包名称语法，并唯一标识广播事件。您可以使用 putextra(string, bundle) 向 intent 附加其他信息。您也可以对 intent 调用 setpackage(string)，将广播限定到同一组织中的一组应用。\n\n\n# 系统广播/非系统广播\n\n * android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播\n * 每个广播都有特定的intent - filter（包括具体的action）\n\n当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播。如电量变化，网络变化，开关机状态等等。如网络变化的广播\n\n    private void init() {\n        logutil.log("注册广播");\n        intentfilter filter = new intentfilter();\n        filter.addaction("android.net.conn.connectivity_change");\n        netbraodcastreceiver = new netbraodcastreceiver();\n        registerreceiver(netbraodcastreceiver,filter);\n    }\n\n    @override\n    protected void ondestroy() {\n        super.ondestroy();\n        logutil.log("注销广播");\n        unregisterreceiver(netbraodcastreceiver);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这仅仅是系统广播中的一个，我们列举一下常用的系统广播：\n\n字段                                    说明\nintent.action_airplane_mode_changed   关闭或打开飞行模式时的广播\nintent.action_battery_changed         充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过context.registerreceiver()注册\nintent.action_battery_low             表示电池电量低\nintent.action_battery_okay            表示电池电量充足，即从电池电量低变化到饱满时会发出广播\nintent.action_boot_completed          在系统启动完成后，这个动作被广播一次（只有一次）\nintent.action_date_changed            设备日期发生改变时会发出此广播\nintent.action_headset_plug            在耳机口上插入耳机时发出的广播\nintent.action_input_method_changed    改变输入法时发出的广播\nintent.action_locale_changed          设备当前区域设置已更改时发出的广播\n\n而非系统广播则是由三方app发送的广播。\n\n\n# 全局广播/本地广播\n\n默认发送的广播都是全局广播，但是这样很不安全，如果外部应用想监听这个广播也是可以的。\n\n\n# 本地广播\n\n如果这个广播只是我们app内部使用，则可以使用本地广播：\n\nlocalbroadcastmanager.sendbroadcast 方法会将广播发送给与发送器位于同一应用中的接收器。如果您不需要跨应用发送广播，请使用本地广播。这种实现方法的效率更高（无需进行进程间通信），而且您无需担心其他应用在收发您的广播时带来的任何安全问题。\n\n\n# 广播权限\n\n也可以使用权限发送广播：\n\n您可以通过权限将广播限定到拥有特定权限的一组应用。您可以对广播的发送器或接收器施加限制。\n\n# 带权限的发送\n\n当您调用 sendbroadcast(intent, string) 或 sendorderedbroadcast(intent, string, broadcastreceiver, handler, int, string, bundle) 时，可以指定权限参数。接收器若要接收此广播，则必须通过其清单中的 标记请求该权限（如果存在危险，则会被授予该权限）。例如，以下代码会发送广播：\n\n    sendbroadcast(intent("com.example.notify"), manifest.permission.send_sms)\n\n\n1\n\n\n要接收此广播，接收方应用必须请求如下权限：\n\n<uses-permission android:name="android.permission.send_sms"/>\n\n\n1\n\n\n您可以指定现有的系统权限（如 send_sms），也可以使用元素定义自定义权限。\n\n**注意：**自定义权限将在安装应用时注册。定义自定义权限的应用必须在使用自定义权限的应用之前安装。\n\n# 带权限的接收\n\n如果您在注册广播接收器时指定了权限参数（通过 registerreceiver(broadcastreceiver, intentfilter, string, handler) 或清单中的标记指定），则广播方必须通过其清单中的标记请求该权限（如果存在危险，则会被授予该权限），才能向该接收器发送 intent。\n\n例如，假设您的接收方应用具有如下所示的清单声明的接收器：\n\n<receiver android:name=".mybroadcastreceiver"\n              android:permission="android.permission.send_sms">\n        <intent-filter>\n            <action android:name="android.intent.action.airplane_mode"/>\n        </intent-filter>\n    </receiver>\n    \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n或者您的接收方应用具有如下所示的上下文注册的接收器：\n\n    var filter = intentfilter(intent.action_airplane_mode_changed)\n    registerreceiver(receiver, filter, manifest.permission.send_sms, null )\n    \n\n\n1\n2\n3\n\n\n那么，发送方应用必须请求如下权限，才能向这些接收器发送广播：\n\n<uses-permission android:name="android.permission.send_sms"/>\n\n\n1\n\n\n\n# 指定包名\n\n * 在 android 4.0 及更高版本中，您可以在发送广播时使用 setpackage(string) 指定软件包。系统会将广播限定到与该软件包匹配的一组应用。\n\n注意：\n\n1、如果不需要向应用以外的组件发送广播，使用localbroadcastmanager 效率更高（无需进行进程间通信）。本地广播可在应用中作为通用的发布/订阅事件总线，而不会产生任何系统级广播开销。\n\n2、优先使用上下文注册而不是清单声明， 如果有许多应用在其清单中注册接收相同的广播，可能会导致系统启动大量应用，从而对设备性能和用户体验造成严重影响。有时，android 系统本身会强制使用上下文注册的接收器。例如，connectivity_action 广播只会传送给上下文注册的接收器。\n\n3、onrecive返回后即有可能被系统回收，如需做耗时操作，尽量使用goasync()开启后台任务或jobscheduler\n\n\n# 有序广播/无序广播\n\n\n# 无序广播\n\n默认发送的广播都是无序广播，即同级的广播是没有固定顺序来接收这个广播的，且无法停止。\n\nsendbroadcast(intent) 方法会按随机的顺序向所有接收器发送广播。这称为常规广播。这种方法效率更高，但也意味着接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播。\n\n\n# 有序广播\n\n而有序广播则是，一个一个的发送，中途可以停止继续发送。\n\nsendorderedbroadcast(intent, string) 方法一次向一个接收器发送广播。当接收器逐个顺序执行时，接收器可以向下传递结果，也可以完全中止广播，使其不再传递给其他接收器。接收器的运行顺序可以通过匹配的 intent-filter 的 android:priority 属性来控制；具有相同优先级的接收器将按随机顺序运行。\n\n广播接受者接收广播的顺序规则（同时面向静态和动态注册的广播接受者）：\n\n * 按照priority属性值从大-小排序；\n * priority属性相同者，动态注册的广播优先；\n\n特点：\n\n * 接收广播按顺序接收\n * 先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播；\n * 先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播\n\n有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式： sendorderedbroadcast(intent);\n\n注意：\n\n1、第一个广播接收器使用intent.getextras()接收数据，后面的广播接收器使用getresultextras(true)接收数据\n\n2、是否是有序广播：isorderedbroadcast() 3、中断广播：abortbroadcast() 4、向下级传递数据：setresultextras(bundle)，如果不是有序广播，调用会报错 5、intentfilter中setpriority设置优先级\n\n * 优先级对无序广播也生效\n * 无需广播，先注册先生效\n\n附加说明\n\n * android8中使用静态注册的广播接收器接收自定义广播时，会发生接收不到自定义广播的问题,需要在android7的代码基础上在发送广播的intent中加上这一句：\n\n//componentname的第一个参数是自定义广播的包名，第二个参数是广播接收器的类\nbraodcast.setcomponent(new componentname("pkgname","receivername"));\n\n\n1\n2\n\n\n\n# 广播接收者\n\n接收者主要关注 注册监听的方式：\n\n * 静态注册\n * 动态注册\n\n\n# 静态注册\n\n1、创建 broadcastreceiver 子类并实现 onreceive(context, intent)。以下示例中的广播接收器会记录并显示广播的内容：\n\n    private const val tag = "mybroadcastreceiver"\n\n    class mybroadcastreceiver : broadcastreceiver() {\n\n        override fun onreceive(context: context, intent: intent) {\n            stringbuilder().apply {\n                append("action: ${intent.action}\\n")\n                append("uri: ${intent.touri(intent.uri_intent_scheme)}\\n")\n                tostring().also { log ->\n                    log.d(tag, log)\n                    toast.maketext(context, log, toast.length_long).show()\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n2、在应用清单中指定 元素。\n\n    <receiver android:name=".mybroadcastreceiver"  android:exported="true">\n        <intent-filter>\n            <action android:name="android.intent.action.boot_completed"/>\n            <action android:name="android.intent.action.input_method_changed" />\n        </intent-filter>\n    </receiver>\n\n\n1\n2\n3\n4\n5\n6\n\n\n系统软件包管理器会在应用安装时注册接收器。然后，该接收器会成为应用的一个独立入口点，这意味着如果应用当前未运行，系统可以启动应用并发送广播。\n\n系统会创建新的 broadcastreceiver 组件对象来处理它接收到的每个广播。此对象仅在调用 onreceive(context, intent) 期间有效。一旦从此方法返回代码，系统便会认为该组件不再活跃。\n\n\n# 动态注册\n\n1、创建 broadcastreceiver 的实例。\n\n    val br: broadcastreceiver = mybroadcastreceiver()\n\n\n1\n\n\n2、创建 intentfilter 并调用 registerreceiver(broadcastreceiver, intentfilter) 来注册接收器：\n\n    val filter = intentfilter(connectivitymanager.connectivity_action).apply {\n        addaction(intent.action_airplane_mode_changed)\n    }\n    registerreceiver(br, filter)\n\n\n1\n2\n3\n4\n\n\n**注意：**要注册本地广播，请调用 localbroadcastmanager.registerreceiver(broadcastreceiver, intentfilter)。\n\n只要静态注册有效，静态注册的接收器就会接收广播。例如，如果您在 activity 上下文中注册，只要 activity 没有被销毁，您就会收到广播。如果您在应用上下文中注册，只要应用在运行，您就会收到广播。\n\n3、要停止接收广播，请调用 unregisterreceiver(android.content.broadcastreceiver)。当您不再需要接收器或上下文不再有效时，请务必注销接收器。\n\n请注意注册和注销接收器的位置，比方说，如果您使用 activity 上下文在 oncreate(bundle) 中注册接收器，则应在 ondestroy() 中注销，以防接收器从 activity 上下文中泄露出去。如果您在 onresume() 中注册接收器，则应在 onpause() 中注销，以防多次注册接收器（如果您不想在暂停时接收广播，这样可以减少不必要的系统开销）。请勿在 onsaveinstancestate(bundle) 中注销，因为如果用户在历史记录堆栈中后退，则不会调用此方法。\n\n特别注意：\n\n * 动态广播最好在activity 的 onresume()注册、onpause()注销。\n\n * 原因：\n   \n   1.对于动态广播，有注册就必然得有注销，否则会导致内存泄露。重复注册、重复注销也不允许。\n   \n   2.在onresume()注册、onpause()注销是因为onpause()在app死亡前一定会被执行，从而保证广播在app死亡前一定会被注销，进而防止内存泄露。\n\n\n# 版本变更\n\n\n# android 9\n\n从 android 9（api 级别 28）开始，network_state_changed_action 广播不再接收有关用户位置或个人身份数据的信息。\n\n此外，如果您的应用安装在搭载 android 9 或更高版本的设备上，则通过 wlan 接收的系统广播不包含 ssid、bssid、连接信息或扫描结果。要获取这些信息，请调用 getconnectioninfo()。\n\n\n# android 8.0\n\n从 android 8.0（api 级别 26）开始，系统对清单声明的接收器施加了额外的限制。\n\n如果您的应用以 android 8.0 或更高版本为目标平台，那么对于大多数隐式广播（没有明确针对您的应用的广播），您不能使用清单来声明接收器。\n\n\n# android 7.0\n\nandroid 7.0（api 级别 24）及更高版本不发送以下系统广播：\n\n * action_new_picture\n * action_new_video\n\n此外，以 android 7.0 及更高版本为目标平台的应用必须使用 registerreceiver(broadcastreceiver, intentfilter) 注册 connectivity_action 广播。无法在清单中声明接收器。\n\n\n# 补充\n\n\n# 广播收到回调后不能开子线程做操作？开携程呢？\n\n测试在收到消息后开启子线程做了30s的工作没有任何问题。',charsets:{cjk:!0},lastUpdated:"10/17/2022",lastUpdatedTimestamp:166599531e4},{title:"内容提供者基础",frontmatter:{title:"内容提供者基础",date:"2022-10-10T14:28:27.000Z",permalink:"/pages/f49146/",categories:["Android","四大组件","ContentProvider"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/03.ContentProvider/00.%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/00.四大组件/03.ContentProvider/00.内容提供者基础.md",key:"v-53802a1d",path:"/pages/f49146/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:942},{level:3,title:"1、实现ContentProvider抽象类，并实现相关方法",slug:"_1、实现contentprovider抽象类-并实现相关方法",normalizedTitle:"1、实现contentprovider抽象类，并实现相关方法",charIndex:951},{level:3,title:"2、清单注册",slug:"_2、清单注册",normalizedTitle:"2、清单注册",charIndex:3686},{level:3,title:"3、数据变更通知与监听",slug:"_3、数据变更通知与监听",normalizedTitle:"3、数据变更通知与监听",charIndex:4090},{level:2,title:"读写日历",slug:"读写日历",normalizedTitle:"读写日历",charIndex:4748},{level:2,title:"读取联系人",slug:"读取联系人",normalizedTitle:"读取联系人",charIndex:4943}],headersStr:"基本用法 1、实现ContentProvider抽象类，并实现相关方法 2、清单注册 3、数据变更通知与监听 读写日历 读取联系人",content:'# 简介\n\nontentProvider是Android四大组件之一，其本质上是一个标准化的数据管道，它屏蔽了底层的数据管理和服务等细节。\n\n主要用于在不同应用程序之间实现数据共享的功能，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。\n\nContent Provider维护特定的应用数据，并可以让其它应用轻松访问该数据。\n\n对数据使用者来说它是数据提供者。它提供统一的接口对数据进行操作，使用者不用关心数据到底是如何存储的以及数据类型到底是什么,用户可以灵活实现ContentProvider所封装的数据存储以及增删改查等，所有的ContentProvider 必须实现一个对外统一的接口（URI）。\n\n比如我们的APP去访问通讯录，日历，短信等。\n\nUri类似http url, 构成如下：content://authority/path，所有Content Provider的Uri必须以content://开头（#匹配一个数字字符串，*匹配一个文本字符串。）\n\nauthority是个字符串，它由开发者自己定义，用于来唯一标示一个ContentProvider。系统会根据这个标示查找ContentProvider。\n\npath也是字符串，表示要操作的数据，可根据自己的实现逻辑来指定：\n\n> content://contacts/people 表示要操作ContentProvider为contacts下的people表。 content://com.android.contacts/people/# 表示要操作表people中特定id的行(记录)。 content://downloads/download/10/name 表示要操作id为10的行的name字段。 content://downloads/download/* 表示操作download表中的所有字段。\n\n有文章单独介绍URI。\n\n内容提供者就是contentProvider，作用有如下：\n\n 1. 给多个应用提供数据\n 2. 类似一个接口\n 3. 可以和多个应用分享数据\n\n结合上面的说法，内容提供者大体可以分为两个方向：\n\n * 提供者\n * 使用者\n\n\n# 提供者\n\n\n# 基本用法\n\n\n# 1、实现ContentProvider抽象类，并实现相关方法\n\npublic class UserProvider extends ContentProvider {\n\n    private static final String TAG = "UserProvider";\n    private UserDatabaseHelper dbh;\n    private static UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    private static final int USER_MATCH_CODE = 1;\n    static {\n        uriMatcher.addURI("top.woodwhale.picgo","user",USER_MATCH_CODE);\n    }\n\n    @Override\n    public boolean onCreate() {\n        dbh = new UserDatabaseHelper(getContext());\n        return false;\n    }\n\n    @Nullable\n    @Override\n    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {\n        int res = uriMatcher.match(uri);\n        // 匹配规则\n        if (res == USER_MATCH_CODE) {\n            SQLiteDatabase db = dbh.getWritableDatabase();\n            return db.query(Constants.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);\n        } else {\n            throw new IllegalArgumentException("参数错误！");\n        }\n    }\n\n    @Nullable\n    @Override\n    public String getType(@NonNull Uri uri) {\n        return null;\n    }\n\n    @Nullable\n    @Override\n    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {\n        int res = uriMatcher.match(uri);\n        if (res == USER_MATCH_CODE) {\n            SQLiteDatabase db = dbh.getWritableDatabase();\n            long insertRes = db.insert(Constants.TABLE_NAME, null, values);\n            Uri resUri = Uri.parse("content://top.woodwhale.picgo/user/"+insertRes);\n            Log.d(TAG,"insertRes --\x3e "+ insertRes);\n            // 插入数据成功，数据变化了，需要通知其他地方\n            getContext().getContentResolver().notifyChange(resUri,null);\n            return resUri;\n        } else {\n            throw new IllegalArgumentException("参数错误！");\n        }\n    }\n\n    @Override\n    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {\n        return 0;\n    }\n\n    @Override\n    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {\n        return 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n一个具有内容提供者的APP中必须得有如下的类：\n\n * 该类继承ContentProvider，并且重写其中的方法（增删改查）\n * 赋予一个UriMatcher对象的成员变量\n * 进行一个Uri的匹配，authorities要和manifest中的一致，并且可以选择表进行内容共提供。这些都在静态代码块中实现，使用addURI方法即可\n * 重写增删改查方法，前提是Uri匹配！\n\n注意的是：ContentResolver中的CRUD操作方法都不是接收表名，而是使用一个Uri参数代替，这个参数被称为内容URI，它由两部分组成：authority和path。Authority是用于对不同的应用程序做区分的。Path是用于对同一应用程序中不同的两张表。如：content://com.example.app.privoder/table1。\n\n\n# 2、清单注册\n\n<provider\n            android:authorities="top.woodwhale.picgo"\n            android:name=".test.contentprovider.provider.UserProvider"\n            android:exported="true"\n            android:enabled="true"\n            android:grantUriPermissions="true"/>\n\n\n1\n2\n3\n4\n5\n6\n\n * authorities可以是包名\n * name就是自己定义的名字\n * exported=true可以让其他的APP来访问自己提供的内容\n\n这样子，别人就可以通过我们定义的 authorities + 表名 来操作我们应用的数据库了。\n\n\n# 3、数据变更通知与监听\n\nContentProvider支持多进程访问，当一个进程操作ContentProvider变更数据之后，可能希望其他进程能收到通知，比如进程A往数据库插入了一条聊天信息，希望在进程B的UI中展现出来，这个时候就需要一个通知机制，Android也是提供了支持，不过它是一个通用的数据变更同步通知：基于ContentService服务：\n\n\x3c!--1 注册--\x3e\npublic static void registerObserver(ContentObserver contentObserver) {\n\tContentResolver contentResolver = AppProfile.getAppContext().getContentResolver();\n\tcontentResolver.registerContentObserver(FileContentProvider.CONTENT_URI, true, contentObserver);\n}\n\n\x3c!--2 通知--\x3e\ncontentResolver.notifyChange(FileContentProvider.CONTENT_URI, null)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 使用者\n\nContentProvider将数据发布出来，通过ContentResolver对象结合Uri进行调用，通过ContentResolver对象可以调用ContentProvider的增删改查。\n\n\n# 读写日历\n\n在很多的情况下，我们会将一些事情写入到我们手机中的“日历”中，当到了预定的时间就会提醒，那么设置一个日历提醒事件怎么做到呢？——我们可以使用安卓开发给定的CalendarContract进行完成\n\nCalendarContract是日历内容提供者和APP之间的一个合同，当我们的APP获取了读、写日历的权限之后，就可以对手机自带的这个"日历APP"进行添加事件的操作。\n\n\n# 读取联系人\n\n\n# 多进程的问题\n\nContentProvider标签有 android:multiprocess 和 android:process 这两个标签。\n\n我们知道默认不指定android:process的话，provider组件所在的进程名就是包名，multiprocess默认为false，则provider会随着应用启动的时候加载。如果对provider指定android:process和android:multiprocess，那么会产生如下几种情况：\n\n * android:process=":fore"，android:multiprocess="true"：provider不会随应用的启动而加载，当调用到provider的时候才会加载，加载时provider是在调用者的进程中初始化的。这时候可能定义provider的fore进程还没有启动。\n * android:process=":fore"（android:multiprocess默认情况下为"false"）：provider不会随应用的启动而加载，当调用到provider的时候才会加载，加载时provider是在“fore”进程中初始化的。\n * android:multiprocess="true"：provider会随着应用启动的时候加载，加载时provider是在应用默认主进程中初始化的。对于android:multiprocess=true，意味着provider可以多实例，那么由调用者在自己的进程空间实例化一个ContentProvider对象，此时定义ContentProvider的App可能并没有启动。\n * android:multiprocess="false"：provider会随着应用启动的时候加载，加载时provider是在应用默认主进程中初始化的。对于android:multiprocess=false（默认值），由系统把定义该ContentProvider的App启动起来(一个独立的Process)并实例化ContentProvider，这种ContentProvider只有一个实例，运行在自己App的Process中。所有调用者共享该ContentProvider实例，调用者与ContentProvider实例位于两个不同的Process。\n\n总之，android:multiprocess 应该理解为：是否允许在调用者的进程里实例化provider，而跟定义它的进程没有关系。\n\n\n# 初始化流程',normalizedContent:'# 简介\n\nontentprovider是android四大组件之一，其本质上是一个标准化的数据管道，它屏蔽了底层的数据管理和服务等细节。\n\n主要用于在不同应用程序之间实现数据共享的功能，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。\n\ncontent provider维护特定的应用数据，并可以让其它应用轻松访问该数据。\n\n对数据使用者来说它是数据提供者。它提供统一的接口对数据进行操作，使用者不用关心数据到底是如何存储的以及数据类型到底是什么,用户可以灵活实现contentprovider所封装的数据存储以及增删改查等，所有的contentprovider 必须实现一个对外统一的接口（uri）。\n\n比如我们的app去访问通讯录，日历，短信等。\n\nuri类似http url, 构成如下：content://authority/path，所有content provider的uri必须以content://开头（#匹配一个数字字符串，*匹配一个文本字符串。）\n\nauthority是个字符串，它由开发者自己定义，用于来唯一标示一个contentprovider。系统会根据这个标示查找contentprovider。\n\npath也是字符串，表示要操作的数据，可根据自己的实现逻辑来指定：\n\n> content://contacts/people 表示要操作contentprovider为contacts下的people表。 content://com.android.contacts/people/# 表示要操作表people中特定id的行(记录)。 content://downloads/download/10/name 表示要操作id为10的行的name字段。 content://downloads/download/* 表示操作download表中的所有字段。\n\n有文章单独介绍uri。\n\n内容提供者就是contentprovider，作用有如下：\n\n 1. 给多个应用提供数据\n 2. 类似一个接口\n 3. 可以和多个应用分享数据\n\n结合上面的说法，内容提供者大体可以分为两个方向：\n\n * 提供者\n * 使用者\n\n\n# 提供者\n\n\n# 基本用法\n\n\n# 1、实现contentprovider抽象类，并实现相关方法\n\npublic class userprovider extends contentprovider {\n\n    private static final string tag = "userprovider";\n    private userdatabasehelper dbh;\n    private static urimatcher urimatcher = new urimatcher(urimatcher.no_match);\n    private static final int user_match_code = 1;\n    static {\n        urimatcher.adduri("top.woodwhale.picgo","user",user_match_code);\n    }\n\n    @override\n    public boolean oncreate() {\n        dbh = new userdatabasehelper(getcontext());\n        return false;\n    }\n\n    @nullable\n    @override\n    public cursor query(@nonnull uri uri, @nullable string[] projection, @nullable string selection, @nullable string[] selectionargs, @nullable string sortorder) {\n        int res = urimatcher.match(uri);\n        // 匹配规则\n        if (res == user_match_code) {\n            sqlitedatabase db = dbh.getwritabledatabase();\n            return db.query(constants.table_name, projection, selection, selectionargs, null, null, sortorder);\n        } else {\n            throw new illegalargumentexception("参数错误！");\n        }\n    }\n\n    @nullable\n    @override\n    public string gettype(@nonnull uri uri) {\n        return null;\n    }\n\n    @nullable\n    @override\n    public uri insert(@nonnull uri uri, @nullable contentvalues values) {\n        int res = urimatcher.match(uri);\n        if (res == user_match_code) {\n            sqlitedatabase db = dbh.getwritabledatabase();\n            long insertres = db.insert(constants.table_name, null, values);\n            uri resuri = uri.parse("content://top.woodwhale.picgo/user/"+insertres);\n            log.d(tag,"insertres --\x3e "+ insertres);\n            // 插入数据成功，数据变化了，需要通知其他地方\n            getcontext().getcontentresolver().notifychange(resuri,null);\n            return resuri;\n        } else {\n            throw new illegalargumentexception("参数错误！");\n        }\n    }\n\n    @override\n    public int delete(@nonnull uri uri, @nullable string selection, @nullable string[] selectionargs) {\n        return 0;\n    }\n\n    @override\n    public int update(@nonnull uri uri, @nullable contentvalues values, @nullable string selection, @nullable string[] selectionargs) {\n        return 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n一个具有内容提供者的app中必须得有如下的类：\n\n * 该类继承contentprovider，并且重写其中的方法（增删改查）\n * 赋予一个urimatcher对象的成员变量\n * 进行一个uri的匹配，authorities要和manifest中的一致，并且可以选择表进行内容共提供。这些都在静态代码块中实现，使用adduri方法即可\n * 重写增删改查方法，前提是uri匹配！\n\n注意的是：contentresolver中的crud操作方法都不是接收表名，而是使用一个uri参数代替，这个参数被称为内容uri，它由两部分组成：authority和path。authority是用于对不同的应用程序做区分的。path是用于对同一应用程序中不同的两张表。如：content://com.example.app.privoder/table1。\n\n\n# 2、清单注册\n\n<provider\n            android:authorities="top.woodwhale.picgo"\n            android:name=".test.contentprovider.provider.userprovider"\n            android:exported="true"\n            android:enabled="true"\n            android:granturipermissions="true"/>\n\n\n1\n2\n3\n4\n5\n6\n\n * authorities可以是包名\n * name就是自己定义的名字\n * exported=true可以让其他的app来访问自己提供的内容\n\n这样子，别人就可以通过我们定义的 authorities + 表名 来操作我们应用的数据库了。\n\n\n# 3、数据变更通知与监听\n\ncontentprovider支持多进程访问，当一个进程操作contentprovider变更数据之后，可能希望其他进程能收到通知，比如进程a往数据库插入了一条聊天信息，希望在进程b的ui中展现出来，这个时候就需要一个通知机制，android也是提供了支持，不过它是一个通用的数据变更同步通知：基于contentservice服务：\n\n\x3c!--1 注册--\x3e\npublic static void registerobserver(contentobserver contentobserver) {\n\tcontentresolver contentresolver = appprofile.getappcontext().getcontentresolver();\n\tcontentresolver.registercontentobserver(filecontentprovider.content_uri, true, contentobserver);\n}\n\n\x3c!--2 通知--\x3e\ncontentresolver.notifychange(filecontentprovider.content_uri, null)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 使用者\n\ncontentprovider将数据发布出来，通过contentresolver对象结合uri进行调用，通过contentresolver对象可以调用contentprovider的增删改查。\n\n\n# 读写日历\n\n在很多的情况下，我们会将一些事情写入到我们手机中的“日历”中，当到了预定的时间就会提醒，那么设置一个日历提醒事件怎么做到呢？——我们可以使用安卓开发给定的calendarcontract进行完成\n\ncalendarcontract是日历内容提供者和app之间的一个合同，当我们的app获取了读、写日历的权限之后，就可以对手机自带的这个"日历app"进行添加事件的操作。\n\n\n# 读取联系人\n\n\n# 多进程的问题\n\ncontentprovider标签有 android:multiprocess 和 android:process 这两个标签。\n\n我们知道默认不指定android:process的话，provider组件所在的进程名就是包名，multiprocess默认为false，则provider会随着应用启动的时候加载。如果对provider指定android:process和android:multiprocess，那么会产生如下几种情况：\n\n * android:process=":fore"，android:multiprocess="true"：provider不会随应用的启动而加载，当调用到provider的时候才会加载，加载时provider是在调用者的进程中初始化的。这时候可能定义provider的fore进程还没有启动。\n * android:process=":fore"（android:multiprocess默认情况下为"false"）：provider不会随应用的启动而加载，当调用到provider的时候才会加载，加载时provider是在“fore”进程中初始化的。\n * android:multiprocess="true"：provider会随着应用启动的时候加载，加载时provider是在应用默认主进程中初始化的。对于android:multiprocess=true，意味着provider可以多实例，那么由调用者在自己的进程空间实例化一个contentprovider对象，此时定义contentprovider的app可能并没有启动。\n * android:multiprocess="false"：provider会随着应用启动的时候加载，加载时provider是在应用默认主进程中初始化的。对于android:multiprocess=false（默认值），由系统把定义该contentprovider的app启动起来(一个独立的process)并实例化contentprovider，这种contentprovider只有一个实例，运行在自己app的process中。所有调用者共享该contentprovider实例，调用者与contentprovider实例位于两个不同的process。\n\n总之，android:multiprocess 应该理解为：是否允许在调用者的进程里实例化provider，而跟定义它的进程没有关系。\n\n\n# 初始化流程',charsets:{cjk:!0},lastUpdated:"10/29/2022",lastUpdatedTimestamp:166704324e4},{title:"服务基础",frontmatter:{title:"服务基础",date:"2022-10-10T14:28:27.000Z",permalink:"/pages/575d07/",categories:["Android","四大组件","Service"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/04.Service/00.%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/00.四大组件/04.Service/00.服务基础.md",key:"v-f7c2420a",path:"/pages/575d07/",headers:[{level:2,title:"显式启动",slug:"显式启动",normalizedTitle:"显式启动",charIndex:334},{level:2,title:"隐式启动",slug:"隐式启动",normalizedTitle:"隐式启动",charIndex:341},{level:2,title:"startService",slug:"startservice",normalizedTitle:"startservice",charIndex:365},{level:3,title:"启动 - 启动 - 启动",slug:"启动-启动-启动",normalizedTitle:"启动 - 启动 - 启动",charIndex:5554},{level:3,title:"启动 - 关闭 - 启动 - 启动",slug:"启动-关闭-启动-启动",normalizedTitle:"启动 - 关闭 - 启动 - 启动",charIndex:6045},{level:3,title:"启动  - 关闭 - 关闭 - 关闭",slug:"启动-关闭-关闭-关闭",normalizedTitle:"启动  - 关闭 - 关闭 - 关闭",charIndex:null},{level:3,title:"关闭 - 启动 - 启动 - 关闭",slug:"关闭-启动-启动-关闭",normalizedTitle:"关闭 - 启动 - 启动 - 关闭",charIndex:7016},{level:2,title:"bindService",slug:"bindservice",normalizedTitle:"bindservice",charIndex:430},{level:3,title:"绑定 - 绑定 - 绑定",slug:"绑定-绑定-绑定",normalizedTitle:"绑定 - 绑定 - 绑定",charIndex:7621},{level:3,title:"绑定 - 解绑 - 绑定 - 绑定",slug:"绑定-解绑-绑定-绑定",normalizedTitle:"绑定 - 解绑 - 绑定 - 绑定",charIndex:8109},{level:3,title:"绑定  - 解绑 - 解绑 - 解绑",slug:"绑定-解绑-解绑-解绑",normalizedTitle:"绑定  - 解绑 - 解绑 - 解绑",charIndex:null},{level:3,title:"解绑 - 绑定 - 绑定 - 解绑",slug:"解绑-绑定-绑定-解绑",normalizedTitle:"解绑 - 绑定 - 绑定 - 解绑",charIndex:10052},{level:2,title:"startService与bindService",slug:"startservice与bindservice",normalizedTitle:"startservice与bindservice",charIndex:10950},{level:2,title:"单向传递",slug:"单向传递",normalizedTitle:"单向传递",charIndex:11431},{level:2,title:"双向传递",slug:"双向传递",normalizedTitle:"双向传递",charIndex:12205},{level:2,title:"ANR问题",slug:"anr问题",normalizedTitle:"anr问题",charIndex:14052},{level:2,title:"源码解析",slug:"源码解析",normalizedTitle:"源码解析",charIndex:17987},{level:2,title:"JobScheduler",slug:"jobscheduler",normalizedTitle:"jobscheduler",charIndex:19828},{level:3,title:"JobInfo",slug:"jobinfo",normalizedTitle:"jobinfo",charIndex:20753},{level:3,title:"JobScheduler",slug:"jobscheduler-2",normalizedTitle:"jobscheduler",charIndex:19828},{level:3,title:"JobService",slug:"jobservice",normalizedTitle:"jobservice",charIndex:19909},{level:2,title:"AlarmManager",slug:"alarmmanager",normalizedTitle:"alarmmanager",charIndex:20265},{level:3,title:"Timer",slug:"timer",normalizedTitle:"timer",charIndex:25293},{level:3,title:"CountDownTimer",slug:"countdowntimer",normalizedTitle:"countdowntimer",charIndex:26201},{level:3,title:"AlarmManager",slug:"alarmmanager-2",normalizedTitle:"alarmmanager",charIndex:20265},{level:2,title:"JobIntentService",slug:"jobintentservice",normalizedTitle:"jobintentservice",charIndex:19792},{level:2,title:"WorkManager",slug:"workmanager",normalizedTitle:"workmanager",charIndex:19812},{level:3,title:"Worker",slug:"worker",normalizedTitle:"worker",charIndex:31982},{level:3,title:"WorkRequest",slug:"workrequest",normalizedTitle:"workrequest",charIndex:32207},{level:4,title:"WorkRequest加标签",slug:"workrequest加标签",normalizedTitle:"workrequest加标签",charIndex:33293},{level:4,title:"获取 WorkInfo",slug:"获取-workinfo",normalizedTitle:"获取 workinfo",charIndex:33872},{level:3,title:"WorkManager",slug:"workmanager-2",normalizedTitle:"workmanager",charIndex:19812},{level:3,title:"WorkStatus",slug:"workstatus",normalizedTitle:"workstatus",charIndex:39927},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:40312},{level:3,title:"含参Worker类",slug:"含参worker类",normalizedTitle:"含参worker类",charIndex:41567},{level:2,title:"跨进程通信的方式",slug:"跨进程通信的方式",normalizedTitle:"跨进程通信的方式",charIndex:46642},{level:3,title:"广播",slug:"广播",normalizedTitle:"广播",charIndex:20314},{level:3,title:"内容提供者",slug:"内容提供者",normalizedTitle:"内容提供者",charIndex:46713},{level:3,title:"Socket",slug:"socket",normalizedTitle:"socket",charIndex:46774},{level:3,title:"Messenger",slug:"messenger",normalizedTitle:"messenger",charIndex:46810},{level:4,title:"服务端",slug:"服务端",normalizedTitle:"服务端",charIndex:46949},{level:4,title:"客户端",slug:"客户端",normalizedTitle:"客户端",charIndex:3836},{level:4,title:"消息",slug:"消息",normalizedTitle:"消息",charIndex:18606},{level:4,title:"结果",slug:"结果",normalizedTitle:"结果",charIndex:3766},{level:4,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:49472},{level:4,title:"双向通信",slug:"双向通信",normalizedTitle:"双向通信",charIndex:50292},{level:3,title:"AIDl",slug:"aidl",normalizedTitle:"aidl",charIndex:51826},{level:4,title:"单向读写数据",slug:"单向读写数据",normalizedTitle:"单向读写数据",charIndex:51997},{level:4,title:"双向读写数据",slug:"双向读写数据",normalizedTitle:"双向读写数据",charIndex:59710},{level:4,title:"简析源码",slug:"简析源码",normalizedTitle:"简析源码",charIndex:64437},{level:3,title:"Binder",slug:"binder",normalizedTitle:"binder",charIndex:689},{level:2,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:75456}],headersStr:"显式启动 隐式启动 startService 启动 - 启动 - 启动 启动 - 关闭 - 启动 - 启动 启动  - 关闭 - 关闭 - 关闭 关闭 - 启动 - 启动 - 关闭 bindService 绑定 - 绑定 - 绑定 绑定 - 解绑 - 绑定 - 绑定 绑定  - 解绑 - 解绑 - 解绑 解绑 - 绑定 - 绑定 - 解绑 startService与bindService 单向传递 双向传递 ANR问题 源码解析 JobScheduler JobInfo JobScheduler JobService AlarmManager Timer CountDownTimer AlarmManager JobIntentService WorkManager Worker WorkRequest WorkRequest加标签 获取 WorkInfo WorkManager WorkStatus 基本用法 含参Worker类 跨进程通信的方式 广播 内容提供者 Socket Messenger 服务端 客户端 消息 结果 异常处理 双向通信 AIDl 单向读写数据 双向读写数据 简析源码 Binder 解决方法",content:'Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\n\n和Activity一样，它也有自己的生命周期。但是和Activity不同的是，不同的服务状态有不用的生命周期。\n\n所以，我们结合它的服务状态来探讨它的生命周期。但是在此之前，我们先了解下它的启动方式。\n\n\n# 启动方式\n\n这里和Activity一样，分为 显式启动 和 隐式启动。\n\n\n# 显式启动\n\n        startService(Intent(this,BaseService::class.java))\n\n\n1\n\n\n        bindService(Intent(this,BActivity::class.java),serviceConnection, BIND_AUTO_CREATE)\n\n\n1\n\n\n直接使用startService启动一个服务。\n\n这里解释下 bindService 中需要的几个参数：\n\nServiceConnection：需要实现的一个接口\n\npublic interface ServiceConnection {\n    void onServiceConnected(ComponentName name, IBinder service);\n\n    void onServiceDisconnected(ComponentName name);\n\n    default void onBindingDied(ComponentName name) {\n    }\n\n    default void onNullBinding(ComponentName name) {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nflags：我们一般使用 BIND_AUTO_CREATE\n\n\n# 隐式启动\n\n        startService(Intent().apply {\n            action = "cc.fastcv.codelab.services.BaseService"\n        })\n\n\n1\n2\n3\n\n\n        bindService(Intent().apply {\n            action = "cc.fastcv.codelab.services.BaseService"\n        },serviceConnection, BIND_AUTO_CREATE)\n\n\n1\n2\n3\n\n\n这里的action就是我们在清单文件中配置的intent-filter的action。清单文件中，service的标签属性如下：\n\n<service android:enabled=["true" | "false"]\n    android:exported=["true" | "false"]\n    android:icon="drawable resource"\n    android:isolatedProcess=["true" | "false"]\n    android:label="string resource"\n    android:name="string"\n    android:permission="string"\n    android:process="string" >\n    . . .\n</service>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n属性                        作用\nandroid:exported          代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。\nandroid:name              对应Service类名 android:permission：是权限声明\n                          android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。\nandroid:isolatedProcess   设置 true\n                          意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind\n                          and start)。\nandroid:enabled           是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true\n                          的情况下服务才会被激活，否则不会激活。\nandroid:label             描述标签\nandroid:permission        启动权限\nandroid:name              必填，指向Service的类名\n\n在安卓5.0之前，我们这样子去隐式启动一个服务是没有问题的。但是在安卓5.0之后，这样子启动就会报出错误：\n\n    java.lang.IllegalArgumentException: Service Intent must be explicit: Intent { act=cc.fastcv.codelab.services.BaseService }\n        at android.app.ContextImpl.validateServiceIntent(ContextImpl.java:1851)\n        at android.app.ContextImpl.startServiceCommon(ContextImpl.java:1892)\n        at android.app.ContextImpl.startService(ContextImpl.java:1864)\n        at android.content.ContextWrapper.startService(ContextWrapper.java:817)\n        at android.content.ContextWrapper.startService(ContextWrapper.java:817)\n        at cc.fastcv.codelab.MainActivity.onClick(MainActivity.kt:28)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nAndroid 5.0之后google出于安全的角度禁止了隐式声明Intent来启动Service。那么怎么适配呢？\n\n答案是：在现有基础上加上 packageName，如下：\n\n        startService(Intent().apply {\n            action = "cc.fastcv.codelab.services.BaseService"\n            `package` = packageName\n        })\n        \n\n\n1\n2\n3\n4\n5\n\n\n        bindService(Intent().apply {\n            action = "cc.fastcv.codelab.services.BaseService"\n            `package` = packageName\n        },serviceConnection, BIND_AUTO_CREATE)\n\n\n1\n2\n3\n4\n\n\n\n# 服务状态\n\n服务状态我在这里分为两种：\n\n * 启动状态：当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。\n * 绑定状态：当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。\n\n简单来说，就是启动服务的基础接口有两个：\n\n * startService\n * bindService\n\n如果不需要和服务进行交互，只是单方面的给服务写入指令的话，我们就可以使用startService；而要进行交互的话，就必须使用bindService了。\n\n一种更复杂的情况是，我们可能在不同的情况下分别使用 startService 和 bindService来处理业务。所以，我们需要非常了解不同情况下的生命周期是如何回调的，这样子才能更好的使用服务来处理我们的业务功能。\n\n\n# 生命周期\n\n先来一张官方图镇场！！！\n\n\n\n\n# startService\n\n从官方图上看，需要注意的是回调有：\n\n * onCreate\n * onStartCommand\n * onDestory\n\n其中 onStartCommand 是带参数的\n\n * intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service\n * flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：\n   * START_FLAG_REDELIVERY 这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。\n   * START_FLAG_RETRY 该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。\n * startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。\n\n实际上onStartCommand的返回值int类型才是最最值得注意的，它有三种可选值， START_STICKY，START_NOT_STICKY，START_REDELIVER_INTENT，它们具体含义如下：\n\n * START_STICKY 当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。\n * START_NOT_STICKY 当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。\n * START_REDELIVER_INTENT 当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。\n\n从应用场景来看的话，有以下场景需要验证：\n\n\n# 启动 - 启动 - 启动\n\n2022-10-24 15:06:45.091 4702-4702/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:06:45.091 4702-4702/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1\n2022-10-24 15:06:54.102 4702-4702/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2\n2022-10-24 15:06:54.799 4702-4702/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:3\n\n\n1\n2\n3\n4\n\n\n除了第一次启动会调用onCreate之外，后面都只会调用onStartCommand了。\n\n已验证：和Activity无关，可以跨Activity操作。\n\n\n# 启动 - 关闭 - 启动 - 启动\n\n2022-10-24 15:10:39.093 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:10:39.093 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1\n2022-10-24 15:11:29.012 5410-5410/cc.fastcv.codelab D/BaseService: onDestroy: \n2022-10-24 15:11:43.049 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:11:43.050 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1\n2022-10-24 15:11:47.284 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2\n\n\n1\n2\n3\n4\n5\n6\n\n\n已验证：和Activity无关，可以跨Activity操作。\n\n\n# 启动 - 关闭 - 关闭 - 关闭\n\n2022-10-24 15:12:34.205 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:12:34.205 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1\n2022-10-24 15:12:36.335 5410-5410/cc.fastcv.codelab D/BaseService: onDestroy: \n\n\n1\n2\n3\n\n\n如果服务已经关闭，则再次调用 stopService是没有任何反应的。\n\n已验证：和Activity无关，可以跨Activity操作。\n\n\n# 关闭 - 启动 - 启动 - 关闭\n\n2022-10-24 15:15:23.189 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:15:23.189 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1\n2022-10-24 15:15:26.936 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2\n2022-10-24 15:15:28.642 5410-5410/cc.fastcv.codelab D/BaseService: onDestroy: \n\n\n1\n2\n3\n4\n\n\n已验证：和Activity无关，可以跨Activity操作。\n\n\n# bindService\n\n从官方图上看，需要注意的是回调有：\n\n * onCreate\n * onBind\n * onUnbind\n * onDestory\n\n在这里需要注意的是，在Service的onBind回调中，如果返回的是null，会回调 onBind 但是，不会回调 connect里面的接口\n\n从应用场景来看的话，有以下场景需要验证：\n\n\n# 绑定 - 绑定 - 绑定\n\n2022-10-24 15:40:20.125 7906-7906/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:40:20.126 7906-7906/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 15:40:20.128 7906-7906/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 15:40:43.224 7906-7906/cc.fastcv.codelab D/BActivity: onCreate: \n2022-10-24 15:40:46.598 7906-7906/cc.fastcv.codelab D/BActivity: onServiceConnected: \n\n\n1\n2\n3\n4\n5\n\n\n不同的Activity绑定之后，会有不用的connect接收，但是绑定之后再绑定是不会有任何回调的。\n\n\n# 绑定 - 解绑 - 绑定 - 绑定\n\n2022-10-24 15:42:29.512 8164-8164/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:42:29.512 8164-8164/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 15:42:29.514 8164-8164/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 15:42:31.043 8164-8164/cc.fastcv.codelab D/BaseService: onUnbind: \n2022-10-24 15:42:31.043 8164-8164/cc.fastcv.codelab D/BaseService: onDestroy:\n2022-10-24 15:42:35.714 8164-8164/cc.fastcv.codelab D/BActivity: onCreate: \n2022-10-24 15:42:37.633 8164-8164/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:42:37.633 8164-8164/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 15:42:37.634 8164-8164/cc.fastcv.codelab D/BActivity: onServiceConnected: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n解绑之后，就会停止服务，再次绑定服务时，会重新启动服务。\n\n已验证：和Activity有关，不可以跨Activity操作。\n\n\n# 绑定 - 解绑 - 解绑 - 解绑\n\n2022-10-24 15:44:37.633 8585-8585/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:44:37.634 8585-8585/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 15:44:37.636 8585-8585/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 15:44:39.276 8585-8585/cc.fastcv.codelab D/BaseService: onUnbind: \n2022-10-24 15:44:39.276 8585-8585/cc.fastcv.codelab D/BaseService: onDestroy: \'\n2022-10-24 15:44:40.687 8585-8585/cc.fastcv.codelab E/AndroidRuntime: FATAL EXCEPTION: main\n    java.lang.IllegalArgumentException: Service not registered: cc.fastcv.codelab.MainActivity$serviceConnection$1@943aadb\n        at android.app.LoadedApk.forgetServiceDispatcher(LoadedApk.java:1991)\n        at android.app.ContextImpl.unbindService(ContextImpl.java:2076)\n        at android.content.ContextWrapper.unbindService(ContextWrapper.java:889)\n        at android.content.ContextWrapper.unbindService(ContextWrapper.java:889)\n        at cc.fastcv.codelab.MainActivity.onCreate$lambda-3(MainActivity.kt:45)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，在解绑之后，再次解绑的话，就会出现 Service not registered 的错误，并且应用会奔溃。\n\n\n# 解绑 - 绑定 - 绑定 - 解绑\n\n2022-10-24 15:46:18.706 8835-8835/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:46:18.706 8835-8835/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 15:46:18.709 8835-8835/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 15:46:21.301 8835-8835/cc.fastcv.codelab D/BaseService: onUnbind:\n2022-10-24 15:46:21.301 8835-8835/cc.fastcv.codelab D/BaseService: onDestroy:\n2022-10-24 15:46:21.994 8835-8835/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 15:46:21.995 8835-8835/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 15:46:21.997 8835-8835/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 15:46:22.577 8835-8835/cc.fastcv.codelab D/BaseService: onUnbind: \n2022-10-24 15:46:22.577 8835-8835/cc.fastcv.codelab D/BaseService: onDestroy:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里需要注意的是，如果绑定的数量与解绑的数量不相等时，是不会回调onUnbind和onDestroy的。\n\n\n# startService与bindService\n\n在前面分别对startService和bindService做了实验之后，我们可以得到：\n\nstartService：第一次启动会走onCreate，后面调用启动时，只会调用onStartCommand，然后调用stopService之后就会停止服务。可以重复调用停止服务。\n\nbindService：第一次绑定会走onBind，后面会直接返回binder对象，然后调用解绑操作之后就会停止服务。无法重复调用解绑操作。\n\n所以，当两者结合起来使用时，生命周期会变的复杂起来，这里我将它分为以下几个特例：\n\n1、Service是否启动了，如果没有启动则无论调用哪个都会先走onCreate。如果启动了，这个时候调用start会回调onStartCommand（每次调用都会回调）；调用bind就会调用onBind（多次调用只会回调一次）。\n\n2、如果即启动了又绑定了，则需要即解绑又停止服务才能停止服务，否则不会停止服务。\n\n3、如果有多个地方绑定了，则需要全部解绑了才算完解绑完成。\n\n\n# 数据传递\n\n\n# 单向传递\n\n从前面可以知道 startService 是个单项的操作，那我们怎么样传递数据到服务中呢？\n\n还记得 onStartCommand 回调吗？我们每次调用 startService 方法时都会调用它，而这个回调接口有三个参数，其中的 Intent 就是我们传递数据的载体。\n\n如：我们传递字符给服务：\n\n2022-10-24 16:00:00.608 9652-9652/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 16:00:00.609 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1\n2022-10-24 16:00:00.609 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: command = command1\n2022-10-24 16:00:03.378 9652-9652/cc.fastcv.codelab D/BActivity: onCreate: \n2022-10-24 16:00:04.770 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2\n2022-10-24 16:00:04.770 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: command = command2\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看到，我们分别将command1、command2写入到服务中。\n\n\n# 双向传递\n\n我们在 bindService 的connect 回调中 获取 Binder对象，如：\n\nclass BaseBinder : Binder() {\n\n    companion object {\n        private const val TAG = "BaseBinder"\n    }\n\n    private val callbacks = mutableListOf<Callback>()\n\n    fun addCallback(callback: Callback) {\n        Log.d(TAG, "addCallback: 绑定监听者 $callback")\n        if (!callbacks.contains(callback)) {\n            callbacks.add(callback)\n        }\n    }\n\n    fun removeCallback(callback: Callback) {\n        Log.d(TAG, "removeCallback: 解除监听者 $callback")\n        if (callbacks.contains(callback)) {\n            callbacks.remove(callback)\n        }\n    }\n\n    fun request() {\n        for (callback in callbacks) {\n            callback.onCall("收到请求")\n        }\n    }\n}\n\ninterface Callback {\n    fun onCall(msg:String)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n那么，在绑定成功的时候 addCallback 在解绑的时候 removeCallback。最后运行结果：\n\n2022-10-24 16:14:10.590 10620-10620/cc.fastcv.codelab D/MainActivity: onCreate: \n2022-10-24 16:14:14.544 10620-10620/cc.fastcv.codelab D/BaseService: onCreate: \n2022-10-24 16:14:14.545 10620-10620/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 16:14:14.547 10620-10620/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 16:14:14.547 10620-10620/cc.fastcv.codelab D/BaseBinder: addCallback: 绑定监听者 cc.fastcv.codelab.MainActivity@dc6dfb0\n2022-10-24 16:14:18.029 10620-10620/cc.fastcv.codelab D/BActivity: onCreate: \n2022-10-24 16:14:19.459 10620-10620/cc.fastcv.codelab D/BActivity: onServiceConnected: \n2022-10-24 16:14:19.459 10620-10620/cc.fastcv.codelab D/BaseBinder: addCallback: 绑定监听者 cc.fastcv.codelab.BActivity@ded60a8\n2022-10-24 16:14:23.244 10620-10620/cc.fastcv.codelab D/MainActivity: onCall: 收到请求\n2022-10-24 16:14:23.244 10620-10620/cc.fastcv.codelab D/BActivity: onCall: 收到请求\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ANR问题\n\n在这里需要注意的是，Service的回调都是在主线程中的，所以，如果我们在回调中做耗时操作的话，就会产生ANR的问题。\n\n2022-10-24 16:17:19.339 10906-10906/cc.fastcv.codelab D/BaseService: onCreate: main\n2022-10-24 16:17:19.339 10906-10906/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1  main\n2022-10-24 16:17:23.123 10906-10906/cc.fastcv.codelab D/BaseService: onBind: main\n2022-10-24 16:17:32.945 10906-10906/cc.fastcv.codelab D/BaseService: onUnbind: main\n2022-10-24 16:17:32.945 10906-10906/cc.fastcv.codelab D/BaseService: onDestroy: main\n\n\n1\n2\n3\n4\n5\n\n\n所以，如果需要在服务中做耗时操作的话，我们需要在服务的回调之后开启一个子线程做相关耗时操作。这样处理太过繁琐了，所以谷歌推出了IntentService来帮助我们做类似的操作。\n\n\n# IntentService\n\n客户端通过startService(Intent)来启动IntentService; 我们并不需要手动地区控制IntentService,当任务执行完后,IntentService会自动停止; 可以启动IntentService多次,每个耗时操作会以工作队列的方式在IntentService的 onHandleIntent回调方法中执行,并且每次只会执行一个工作线程,执行完一，再到二这样。如：\n\nclass BaseIntentService : IntentService("intent") {\n\n    companion object {\n        private const val TAG = "BaseIntentService"\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        Log.d(TAG, "onCreate: ")\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        Log.d(TAG, "onStartCommand: ")\n        return super.onStartCommand(intent, flags, startId)\n    }\n\n    override fun onHandleIntent(intent: Intent?) {\n        val workId = intent?.getStringExtra("workId")\n        Log.d(TAG, "onHandleIntent: workId = $workId  threadId = ${Thread.currentThread().name}")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(TAG, "onDestroy: ")\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们多次点击启动服务\n\n            val baseService = Intent(this, BaseIntentService::class.java)\n            baseService.putExtra("workId","" + index++ )\n            startService(baseService)\n\n\n1\n2\n3\n\n\n结果：\n\n2022-10-24 16:25:20.857 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: \n2022-10-24 16:25:20.857 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: \n2022-10-24 16:25:20.858 11738-11776/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 1  threadId = IntentService[intent]\n2022-10-24 16:25:20.859 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: \n2022-10-24 16:25:23.521 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: \n2022-10-24 16:25:23.522 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: \n2022-10-24 16:25:23.522 11738-11785/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 2  threadId = IntentService[intent]\n2022-10-24 16:25:23.523 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: \n2022-10-24 16:25:23.729 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: \n2022-10-24 16:25:23.729 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: \n2022-10-24 16:25:23.730 11738-11786/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 3  threadId = IntentService[intent]\n2022-10-24 16:25:23.731 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: \n2022-10-24 16:25:23.911 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: \n2022-10-24 16:25:23.911 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: \n2022-10-24 16:25:23.912 11738-11787/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 4  threadId = IntentService[intent]\n2022-10-24 16:25:23.913 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: \n2022-10-24 16:25:24.085 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: \n2022-10-24 16:25:24.086 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: \n2022-10-24 16:25:24.086 11738-11788/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 5  threadId = IntentService[intent]\n2022-10-24 16:25:24.087 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看到，最终的处理回调都是在子线程中进行的。我们来看看源码（比较简单的源码）\n\n\n# 源码解析\n\n首先看下这个类组成\n\npublic abstract class IntentService extends Service {}\n\n\n1\n\n\n可以看到，这是个抽象类，集成自Service。其中需要我们重写的 onHandleIntent 方法是个抽象方法。\n\n    protected abstract void onHandleIntent(@Nullable Intent intent);\n\n\n1\n\n\n那它在哪个地方回调的呢？可以看到，是在一个内部类ServiceHandler中回调的。\n\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            onHandleIntent((Intent)msg.obj);\n            stopSelf(msg.arg1);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n而ServiceHandler又是Handler的子类，用来接收消息，并且从ServiceHandler的构造方法可以看出，这里使用的 Looper是从外部传入的。我们看看 ServiceHandler 是在哪里被初始化的。\n\n可以轻易的找到\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");\n        thread.start();\n\n        mServiceLooper = thread.getLooper();\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n是在Service的onCreate回调中初始化的，而Looper是在本地启动了一个 HandlerThread 之后获取的 Looper。那子线程的问题应该就可以解释的通了。\n\n那我们的消息是怎么发送过来的呢？\n\n从之前的学习可以知道，要接收消息的话，只能从 onStartCommand 回调中去接收，那我们来看看 onStartCommand 回调接口里面做了什么？\n\n    @Override\n    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n    \n    @Override\n    public void onStart(@Nullable Intent intent, int startId) {\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n哦~，原来是在onStartCommand接收的消息，然后封装成 Message ，再通过 ServiceHandler 回调出来。\n\n虽然这个类很好用，但是，在官方文档上，Android 8.0之后 这个类被废弃掉了，推荐使用 JobIntentService 或者 WorkManager\n\n\n# JobScheduler\n\nAndroid从5.0开始，增加支持一种特殊的机制，即任务调度JobScheduler，为啥要先讲这个呢？\n\n因为，我们后面要提到的 JobService 和 JobIntentService 都是基于它来工作的，包括说后面推出的WorkManager也和它有很大的渊源，所以需要先了解一下这个工具先。\n\nApp除了通过屏幕向用户展示可交互的界面元素之外，还经常需要在后台做些背地里做的事情，比如说精密计算、文件下载、统计分析、数据导入、状态监控等等，这些用户看不到的事一般放在Service中处理。\n\n然而有时候我们希望在特定情况下再启动事务，比如说延迟若干时间之后，或者等手机空闲了再运行，这样一方面不会在系统资源紧张之时喧宾夺主，另一方面也起到削峰填谷提高系统效率的作用。对于这些额外的条件要求，Service并不能直接支持，往往需要加入其他手段，才能较好地满足相关的运行条件，比如：\n\n * 对于延迟时间执行，通常考虑利用系统的闹钟管理器AlarmManager进行定时管理\n * 对于是否联网、是否充电、是否空闲，一般要监听系统的相应广播，常见的系统广播说明如下：\n   * 1、网络状态变化需要监听系统广播android.net.conn.CONNECTIVITY_CHANGE；\n   * 2、设备是否充电需要监听系统广播Intent.ACTION_POWER_CONNECTED也就是android.intent.action.ACTION_POWER_CONNECTED；\n   * 3、设备是否空闲需要监听系统广播Intent.ACTION_SCREEN_OFF也就是android.intent.action.SCREEN_OFF；\n\n可是要想给Service补充以上条件，势必加大了程序逻辑的复杂度，一会儿注册这个事件，一会儿注册那个事件，工程代码将变得不易维护。\n\n有鉴于此，Android从5.0开始，增加支持一种特殊的机制，即任务调度JobScheduler，该工具集成了常见的几种运行条件，开发者只需添加少数几行代码，即可完成原来要多种组件配合的工作。\n\n任务调度机制由三个工具组成，首先是JobInfo，它指定了一个任务的概要信息，比如何时启动，启动时需要满足什么条件等等；其次是JobScheduler，它是系统提供的任务调度服务，它的实例从系统服务Context.JOB_SCHEDULER_SERVICE中获得；最后是JobService，它描述了该任务内部的具体业务逻辑，它的运行时刻由JobScheduler根据JobInfo指定的条件而计算决定。下面分别说明这三个工具的编码过程：\n\n\n# JobInfo\n\n任务信息的运行条件由JobInfo.Builder来构造，下面是Builder的函数说明：\n\n * 构造函数：指定该任务来源与目的，与Intent类似，第二个参数指定了开发者自定义的JobService。\n\n * setRequiredNetworkType：设置需要的网络条件，有三个取值：\n   \n   * JobInfo.NETWORK_TYPE_NONE（无网络时执行，默认）\n   * JobInfo.NETWORK_TYPE_ANY（有网络时执行）\n   * JobInfo.NETWORK_TYPE_UNMETERED（网络无需付费时执行）\n\n * setPersisted：重启后是否还要继续执行，此时需要声明权限RECEIVE_BOOT_COMPLETED，否则会报错“java.lang.IllegalArgumentException: Error: requested job be persisted without holding RECEIVE_BOOT_COMPLETED permission.”而且RECEIVE_BOOT_COMPLETED需要在安装的时候就要声明，如果一开始没声明，而在升级时才声明，那么依然会报权限不足的错误。\n\n * setRequiresCharging：是否在充电时执行\n\n * setRequiresDeviceIdle：是否在空闲时执行\n\n * setPeriodic：设置时间间隔，单位毫秒。该方法不能和setMinimumLatency、setOverrideDeadline这两个同时调用，否则会报错“java.lang.IllegalArgumentException: Can\'t call setMinimumLatency() on a periodic job”，或者报错“java.lang.IllegalArgumentException: Can\'t call setOverrideDeadline() on a periodic job”。\n\n * setMinimumLatency：设置至少延迟多久后执行，单位毫秒。\n\n * setOverrideDeadline：设置最多延迟多久后执行，单位毫秒。\n\n * build：完成条件设置，返回构建好的JobInfo对象。\n\n如：\n\n        val jobinfo = JobInfo.Builder(10001, ComponentName(this, MyJobService::class.java))\n            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE)\n            .setPersisted(false)\n            .setRequiresCharging(false)\n            .setRequiresDeviceIdle(true)\n            .setPeriodic(5 * 1000L)\n            .build()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# JobScheduler\n\n任务调度的实例从系统服务Context.JOB_SCHEDULER_SERVICE中获得，代码举例如下：\n\n\tval js = getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler\t\n\n\n1\n\n\n获得任务调度实例后，即可进行任务调度操作，下面是任务调度的相关方法：\n\n * schedule：把指定的JobInfo对象放入调度队列，并在条件满足时触发该对象中定义的JobService。\n * cancel：取消指定编号的任务。\n * cancelAll：取消所有任务。\n * getAllPendingJobs：获取所有挂起（即尚未执行）的任务。\n\n        val js = getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler\n        js.schedule(jobinfo)\n        js.cancel(10001)\n        js.cancelAll()\n        for (allPendingJob in js.allPendingJobs) {\n            Log.d(TAG, "test: allPendingJob.id.")\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# JobService\n\n任务服务是一种特殊的Service，它描述了该任务内部的具体业务逻辑，需要开发者重写的方法如下： onStartJob：在任务开始执行时触发。返回false表示执行完毕，返回true表示需要开发者自己调用jobFinished方法通知系统已执行完成。 onStopJob：在任务停止执行时触发。 JobService内部另外实现了两个方法，说明如下\n\n1、onBind方法，源码如下所示\n\n    public final IBinder onBind(Intent intent) {\n        return mBinder.asBinder();\n    }\n\n\n1\n2\n3\n\n\nJobService实现了onBind方法，表示任务调度在工作的时候，JobService是通过绑定方式启动的。\n\n2、jobFinished方法，源码如下所示\n\n    public final void jobFinished(JobParameters params, boolean needsReschedule) {\n        ensureHandler();\n        Message m = Message.obtain(mHandler, MSG_JOB_FINISHED, params);\n        m.arg2 = needsReschedule ? 1 : 0;\n        m.sendToTarget();\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n因为JobService由系统触发，不是在App的主线程中，所以这里通过Message机制与主线程进行通信。\n\n示例：\n\nclass MyJobService : JobService() {\n\n    companion object {\n        private const val TAG = "MyJobService"\n    }\n\n    private val mHandler: Handler = object : Handler(Looper.getMainLooper()) {\n        override fun handleMessage(msg: Message) {\n            try {\n                Thread.sleep(5000)\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            }\n            val param = msg.obj as JobParameters\n            jobFinished(param, true)\n            Log.d(TAG, "jobFinished")\n        }\n    }\n\n\n    override fun onStartJob(params: JobParameters?): Boolean {\n        Log.d(TAG, "onStartJob")\n        val message = Message.obtain()\n        message.obj = params\n        mHandler.sendMessage(message)\n        //返回false表示执行完毕，返回true表示需要开发者自己调用jobFinished方法通知系统已执行完成\n        return true\n    }\n\n    override fun onStopJob(params: JobParameters?): Boolean {\n        //停止，不是结束。jobFinished不会直接触发onStopJob\n        //必须在“onStartJob之后，jobFinished之前”取消任务，才会在jobFinished之后触发onStopJob\n        Log.d(TAG, "onStopJob")\n        mHandler.removeMessages(0)\n        return true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n以上代码需要注意的是： 1、因为系统服务是通过绑定方式启动JobService，所以此时onStartCommand方法永远不会执行； 2、onStopJob顾名思义是在任务停止时触发，但是直接调用jobFinished方法并不能触发onStopJob。原因是onStopJob的触发是有条件的，首先这里的停止指的是取消任务而不是完成任务；其次必须在“onStartJob之后，jobFinished之前”取消任务，才会在jobFinished之后触发onStopJob。 另外注意在AndroidManifest.xml中补充服务声明：\n\n        <service\n            android:name=".service.MyJobService"\n            android:permission="android.permission.BIND_JOB_SERVICE" />\n\n\n1\n2\n3\n\n\n\n# AlarmManager\n\n\n# Timer\n\nJava中的定时器机制有现成的方案，就是Timer+TimerTask。其中TimerTask用来描述时刻到达后的事务处理，而Timer用来调度定时任务，如何时启动、间隔多久再次运行等等。\n\nTimer的调度方法是schedule，主要有三个参数。第一个参数表示用来调度的定时任务，第二个参数表示延迟多久首次启动任务，第三个参数表示间隔多久再次启动任务。 public void schedule(TimerTask task, long delay, long period)\n\n定时任务得自己写个继承自TimerTask的新类，并重写run方法填入具体的事务处理代码。调用Timer的schedule方法，定时任务便会按照调度设置按时启动；TimerTask不能直接设置运行的次数上限，一旦启动就会持续定时运行，除非对象销毁或者调用了TimerTask的cancel方法。调用cancel方法停止定时任务后，若想重启该定时任务，只能重新声明TimerTask对象，并且重新调用schedule方法。\n\nTimer+TimerTask的实质是利用开启Thread来触发定时任务，所以TimerTask实际上运行于非UI线程，也就无法直接操作UI。若想在TimerTask中修改UI控件，得通过Handler发送消息来间接实现。\n\n示例：\n\n    //创建任务\n    private val timerTask = object : TimerTask() {\n        override fun run() {\n            Log.d(TAG, "run: 执行任务 ${Thread.currentThread().name}")\n        }\n    }\n    \n    //开始任务\n    val timer = Timer()\n    timer.schedule(timerTask,3000,3000)\n    \n    //取消任务\n    timerTask.cancel()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# CountDownTimer\n\nCountDownTimer是Android提供的倒计时器，日常生活中时有见到倒计时的场景，比如说火箭发射倒计时。\n\n通常我们要自定义一个CountDownTimer的派生类，并重写如下的三个方法：\n\n * 构造函数 : 第一个参数是总的计时长度，第二个参数是每次的计时间隔（好像时钟的滴答）。\n * onTick : 每次计时触发的事件。\n * onFinish : 计时结束事件。\n\n要想启动CountDownTimer计时，调用它的start方法即可，停止计时则调用cancel方法。另外倒计时器触发的onTick和onFinish都运行于非UI线程，所以与Timer一样，也得借助于Handler机制才能操作UI元素。\n\n示例：\n\n    //创建任务\n    private val countDownTimer = object : CountDownTimer(60000, 1000) {\n        override fun onTick(millisUntilFinished: Long) {\n            Log.d(TAG, "onTick: $millisUntilFinished   ${Thread.currentThread().name}")\n        }\n\n        override fun onFinish() {\n            Log.d(TAG, "onFinish:    ${Thread.currentThread().name}")\n        }\n    }\n    \n    //开始任务\n    countDownTimer.start()\n    \n    //取消任务\n    countDownTimer.cancel()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# AlarmManager\n\nAlarmManager是Android提供的一个全局定时器，其使用范围要大于Timer方式。\n\n因为Timer方式采用Thread通信，所以只适用于线程间通信，并且生命周期也有限。如果在Activity中定义Timer，那么Activity页面销毁后，定时器也失效了；如果在Application中定义Timer，那么APP退出后，定时器也要失效。相比之下，AlarmManager利用系统的提醒服务定时发送广播，所以不但适用于线程间通信，而且也适用于进程间通信。另外，由于是系统服务发送广播，因此只要再次打开APP，就会自动收到广播发来的定时任务。\n\nAlarmManager常用的启动方法有两个：\n\n * set : 该方法用于设置一次性定时器。第一个参数表示定时器类型，第二个参数表示任务执行时间，第三个参数表示定时任务。\n * setRepeating : 该方法用于设置重复定时器。第一个参数表示定时器类型，第二个参数表示任务首次执行时间，第三个参数表示再次执行的间隔时间，第四个参数表示定时任务。其中定时器类型主要取值有： RTC_WAKEUP : 表示定时器即使在睡眠状态下也会启用，此时定时器使用系统时间 RTC : 表示定时器在睡眠状态下不可用，此时定时器使用系统时间 ELAPSED_REALTIME_WAKEUP : 表示定时器即使在睡眠状态下也会启用，此时定时器使用相对时间（相对于系统启动开始） ELAPSED_REALTIME : 表示定时器在睡眠状态下不可用，此时定时器使用相对时间\n\n因为AlarmManager使用的是系统服务来发送广播，所以在注册广播接收器时需要注意以下几点： 1、要在AndroidManifest.xml中定义receiver 2、代码中注册接收器必须使用Context.registerReceiver，不能使用LocalBroadcastManager来注册\n\nAlarmManager启动方法中的定时任务使用了PendingIntent类，PendingIntent顾名思义就是一个延迟处理的通信工具。PendingIntent的实例可通过下列三种方法得到：\n\n * getActivity : 获取用于启动页面的实例\n * getService : 获取用于启动服务的实例\n * getBroadcast : 获取用于发送广播的实例\n\n三个方法的参数是一样的，第一个参数表示Context，第二个参数表示请求代码用于标识本次请求的唯一性，第三个参数表示Intent实例（可捆绑具体参数信息Bundle），第四个参数表示PendingIntent的启动标志，具体取值说明如下：\n\n * FLAG_ONE_SHOT : 此时启动的PendingIntent只能使用一次。\n * FLAG_NO_CREATE : 如果不存在描述的PendingIntent，则不会创建新任务。\n * FLAG_CANCEL_CURRENT : 如果已存在描述的PendingIntent，则先取消该任务再创建新任务。\n * FLAG_UPDATE_CURRENT : 一般用这个标志。如果已存在描述的PendingIntent，则更新而不是取消该任务。\n\n示例：\n\n        //创建任务\n        val filter = IntentFilter("cc.fastcv.codelab.alarmReceiver")\n        registerReceiver(alarmReceiver, filter)\n\n        val intent = Intent("cc.fastcv.codelab.alarmReceiver")\n        val pIntent = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n            PendingIntent.getBroadcast(\n                this, R.string.app_name, intent, PendingIntent.FLAG_UPDATE_CURRENT or  PendingIntent.FLAG_IMMUTABLE)\n        } else {\n            PendingIntent.getBroadcast(\n                this, R.string.app_name, intent, PendingIntent.FLAG_UPDATE_CURRENT)\n        }\n\n        Log.d(TAG, "onCreate: 发送警告任务")\n        val alarmMgr = getSystemService(ALARM_SERVICE) as AlarmManager\n        alarmMgr.setRepeating(\n            AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 3000, pIntent);\n            \n        //设置接收器\n        private val alarmReceiver = object  : BroadcastReceiver() {\n            override fun onReceive(context: Context?, intent: Intent?) {\n                Log.d(TAG, "onReceive: 收到警报消息")\n            }\n        }\n        val filter = IntentFilter("cc.fastcv.codelab.alarmReceiver")\n        registerReceiver(alarmReceiver, filter)\n        \n        \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# JobIntentService\n\nJobIntentService实质为Service其继承关系如下所示。\n\n java.lang.Object\n    ↳   android.content.Context\n       ↳    android.content.ContextWrapper\n           ↳    android.app.Service\n               ↳    android.support.v4.app.JobIntentService\n\n\n1\n2\n3\n4\n5\n\n\n用于处理被加入到job或service任务的一个辅助工具。\n\n * 8.0以下被当作普通的Intent使用startSerivce()启动service来执行。\n * 8.0以上任务被作为job用jobScheduler.enqueue()方法来分发。\n\n说到Jobscheduler，应该不陌生了，框架提供的用来APP调度任务的接口，根据APP要求构建JobInfo，系统会在适当的时间调用JobInfo指定的JobService来执行你的任务。\n\n所以在Android8.0及以上JobIntentService和JobService做的事情是相同的，都是等着JobScheduler分配任务来执行。\n\n不同点在于，JobService使用的handler使用的是主线程的Looper，因此需要在onStartJob（）中手动创建AsyncTask去执行耗时任务，而JobIntentService则帮我们处理这一过程，使用它只需要写需要做的任务逻辑即可，不用关心卡住主线程的问题。另外，向jobScheduler传递任务操作也更简单了，不需要在指定JobInfo中的参数，直接enqueue(context,intent)就可以。\n\n这有点像Service和IntentService的关系。\n\n示例：\n\n    Intent workIntent = new Intent();\n    workIntent.putExtra("work","work num:"+num);\n    MyJobIntentService.enqueueWork(getApplicationContext(),workIntent);\n\n\n1\n2\n3\n\n\npublic class MyJobIntentService extends JobIntentService {\n\n    /**\n     * 这个Service 唯一的id\n     */\n    static final int JOB_ID = 10111;\n\n    /**\n     * Convenience method for enqueuing work in to this service.\n     */\n    static void enqueueWork(Context context, Intent work) {\n        enqueueWork(context, MyJobIntentService.class, JOB_ID, work);\n    }\n\n    @Override\n    protected void onHandleWork( Intent intent) {\n        Log.d("houson", "onHandleWork: "+intent.getStringExtra("work").toString());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意manifest！\n\n<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>\n<service android:name=".MyJobIntentService"></service>\n\n\n1\n2\n\n\n\n# WorkManager\n\n关于workmanager 的介绍 官网上是这么说的: 使用 WorkManager API 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。 重点是后面的几个字,运行可延迟的异步任务, 在退出或者重启的时候,我们在之前要实现这种任务可能需要 BroadcastReceiver 或者 AlarmManager,现在的话可以使用WorkManager,这个框架最高兼容至Android api 14。\n\n * Android 23以上是采用JobScheduler\n * Android 14-22 采用的是BroadcastReceiver 和 AlarmManager\n\n要使用的话，需要添加依赖：\n\n       def work_version = "2.3.1"\n\n        // (Java only)\n        implementation "androidx.work:work-runtime:$work_version"//java 语言选这个\n\n        // Kotlin + coroutines\n        implementation "androidx.work:work-runtime-ktx:$work_version"//kotlin 选这个\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在使用之前，我们介绍下它的几个成员：\n\n\n# Worker\n\n任务的执行者，是一个抽象类，用于指定需要执行的具体任务，需要实现doWork() 这一个方法，它是执行在一个单独的后台线程里的。所有需要在后台执行的任务都在这个方法里完成。 doWork()函数的返回值：\n\n * Worker.Result.SUCCESS:任务执行成功。\n * Worker.Result.FAILURE:任务执行失败。\n * Worker.Result.RETRY:任务需要重新执行，如果出现这个返回结果，就需要与WorkRequest.Builder中的setBackoffCriteria()函数一起使用。\n\n如：\n\nclass UploadPicWork(\n    private val context: Context,\n    private val workerParameters: WorkerParameters\n) :\n    Worker(context, workerParameters) {\n    override fun doWork(): Result {\n\n       val params = inputData.getString("params_tag")//获取传递的参数\n\n        try {\n            uploadPic()//上传图片\n        } catch (e: Exception) {\n            return Result.failure(Data())//执行失败了\n        }\n\n        return Result.success()\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# WorkRequest\n\n代表一个单独的任务，对Worker任务进行包装，一个WorkRequest对应一个Worker类。可以通过WorkRequest来给Worker类添加约束细节，比如设备是否空闲，设备电池是否不应低于临界阈值，指定设备在充电时是否启动任务等等。WorkRequest是一个抽象类，具体要使用两个子类：\n\n * OneTimeWorkRequest(任务只执行一遍)\n * PeriodicWorkRequest(任务周期性的执行)。\n\n如：\n\nval UploadPicWork =\n                OneTimeWorkRequestBuilder<UploadPicWork>()\n                    .setInputData(workDataOf("params_tag" to "params"))//传递参数\n                    .setConstraints(triggerContentMaxDelay)//设置约束条件\n                    .addTag("tag")//设置tag\n                    .build()\n\n\n1\n2\n3\n4\n5\n6\n\n\n# WorkRequest加标签\n\n可以通过addTag给WorkRequest加入标签，比如：\n\n PeriodicWorkRequest request = new PeriodicWorkRequest.Builder(MyWorker.class, 15, TimeUnit.SECONDS)\n                .setInputData(data)\n                .addTag("A")\n                .build();\nPeriodicWorkRequest request2 = new PeriodicWorkRequest.Builder(MyWorker.class, 15, TimeUnit.SECONDS)\n                .setInputData(data)\n                .addTag("A")\n                .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过addTag()，将WorkRequest成为了一个组：A组。以后可以直接控制整个组就行了，组内的每个成员都会受到影响。比如通过WorkManager的cancelAllWorkByTag(String tag):取消一组带有相同标签的任务。\n\n# 获取 WorkInfo\n\n * 听过 id 获取,可以听过 WorkManager.getWorkInfoById(UUID) 或 WorkManager.getWorkInfoByIdLiveData(UUID) 来通过 WorkRequest id 来获取 WorkInfo。\n\n WorkManager.getInstance(this)\n                .getWorkInfoByIdLiveData(UploadPicWork.id)// 通过id 获取\n                .observe(this, Observer { //it:WorkInfo\n                    it?.apply {\n                        when (this.state) {\n                            WorkInfo.State.BLOCKED -> println("BLOCKED")\n                            WorkInfo.State.CANCELLED -> println("CANCELLED")\n                            WorkInfo.State.RUNNING -> println("RUNNING")\n                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")\n                            WorkInfo.State.FAILED -> println("FAILED")\n                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")\n                            else -> println("else status ${this.state}")\n                        }\n                    }\n\n                })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 通过 tag 获取,可以利用 WorkManager.getWorkInfosByTag(String) 或 WorkManager.getWorkInfosByTagLiveData(String) 来通过 WorkRequest 的 WorkInfo 对象。\n\n//要通过 tag 获取,则需要先设置 tag\nval UploadPicWork =\n                OneTimeWorkRequestBuilder<UploadPicWork>()\n                    .setInputData(workDataOf("params_tag" to "params"))//传递参数\n                    .setConstraints(triggerContentMaxDelay)//设置约束条件\n                    .addTag("tag")//设置tag\n                    .build()\n\n//获取 workInfo\n\nWorkManager.getInstance(this)\n                .getWorkInfosByTagLiveData("tag")\n                .observe(this, Observer {it:List<WorkInfo>//此处返回的是一个集合,作为示例代码,默认只取 0 index\n                    it?.apply {\n                        when (this[0].state) {\n                            WorkInfo.State.BLOCKED -> println("BLOCKED")\n                            WorkInfo.State.CANCELLED -> println("CANCELLED")\n                            WorkInfo.State.RUNNING -> println("RUNNING")\n                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")\n                            WorkInfo.State.FAILED -> println("FAILED")\n                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")\n                            else -> println("else status ${this[0]}")\n                        }\n                    }\n\n                })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 对于 唯一工作名称 的一个 Worker ,可以利用 WorkManager.getWorkInfosForUniqueWork(String) 或 WorkManager.getWorkInfosForUniqueWorkLiveData(String) 检索所有匹配的 WorkRequest 的 WorkInfo 对象。此处估计不太好理解,唯一工作是一个概念性非常强的术语，可确保一次只有一个具有特定名称的工作链。与 id 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 WorkManager 自动生成。与标记不同，唯一名称仅与“一个”工作链关联。您可以通过调用 WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest) 或 WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest) 创建唯一工作序列。\n\nWorkManager.getInstance(this)\n                .getWorkInfosForUniqueWorkLiveData("UploadPicWork")//唯一工作名称 \n                .observe(this, Observer {it:List<WorkInfo> //此处返回的是一个集合,作为示例代码,默认只取 0\n\n                    it?.apply {\n                        when (this[0].state) {\n                            WorkInfo.State.BLOCKED -> println("BLOCKED")\n                            WorkInfo.State.CANCELLED -> println("CANCELLED")\n                            WorkInfo.State.RUNNING -> println("RUNNING")\n                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")\n                            WorkInfo.State.FAILED -> println("FAILED")\n                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")\n                            else -> println("else status ${this[0]}")\n                        }\n                    }\n\n                })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 注意如采用这种方式获取 workinfo ,在执行 worker 的时候与之前不一样,需要采用 WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest) 或 WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest) 来执行\n\n//全部代码如下\n\n\n//创建约束条件\nval triggerContentMaxDelay =\n                Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED)\n//                    .setRequiresDeviceIdle(false)\n                    .setRequiresBatteryNotLow(true)\n                    .setRequiresStorageNotLow(true)\n                    .setRequiresCharging(true)\n                    .setTriggerContentMaxDelay(1000 * 1, TimeUnit.MILLISECONDS)\n                    .build()\n\n// 创建workrequest\n            val UploadPicWork =\n                OneTimeWorkRequestBuilder<UploadPicWork>()\n                    .setInputData(workDataOf("params_tag" to "params"))\n                    .setConstraints(triggerContentMaxDelay)\n                    .build()\n\n    //注意!!!,此处区别与之前的 WorkManager.getInstance(this).enqueue(UploadPicWork)\n    \n    // "UploadPicWork" 需要与下面代码 getWorkInfosForUniqueWorkLiveData("UploadPicWork") 中字符串对应\n    // ExistingWorkPolicy.APPEND 一个枚举值,worker 执行的策略,想要了解的同学,可以看下面的链接\n    WorkManager.getInstance(this).enqueueUniqueWork("UploadPicWork",ExistingWorkPolicy.APPEND,UploadPicWork)\n\n            WorkManager.getInstance(this)\n                .getWorkInfosForUniqueWorkLiveData("UploadPicWork")\n                .observe(this, Observer {\n\n                    it?.apply {\n                        when (this[0].state) {\n                            WorkInfo.State.BLOCKED -> println("BLOCKED")\n                            WorkInfo.State.CANCELLED -> println("CANCELLED")\n                            WorkInfo.State.RUNNING -> println("RUNNING")\n                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")\n                            WorkInfo.State.FAILED -> println("FAILED")\n                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")\n                            else -> println("else status ${this[0]}")\n                        }\n                    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# WorkManager\n\n主要管理任务请求和任务队列，将WorkRequest加入任务队列。 通过WorkManager来调度任务，以分散系统资源的负载。\n\n\n# WorkStatus\n\n当 WorkManager 把任务加入队列后，会为每个WorkRequest对象提供一个 LiveData， LiveData 持有 WorkStatus，包含有任务的状态和任务的信息。\n\npublic enum State {\n\n    ENQUEUED,\n\n    RUNNING,\n\n    SUCCEEDED,\n\n    FAILED,\n\n    BLOCKED,\n\n    CANCELLED;\n\n    public boolean isFinished() {\n        return (this == SUCCEEDED || this == FAILED || this == CANCELLED);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 基本用法\n\n基本用法分为3步：\n\n 1. 定义后台任务，并实现相关逻辑\n 2. 配置该后台任务的运行条件和约束条件\n 3. 构建后台任务请求\n\n定义后台任务，并实现相关逻辑 定义自己的Worker类继承自Worker类并重写doWork方法\n\ndoWork方法指定Worker类如何执行操作，但是不能出现任何关于任务何时运行的信息\n\n\nclass myWorker(context: Context, params: WorkerParameters) : Worker(context, params){\n    override fun doWork() : Result{\n        //执行操作\n        return Result.success()\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n配置该后台任务的运行条件和约束条件 在MainActivity中根据myWorker类创建OneTimeWorkRequest对象\n\nval myConstraints = Constraints.Builder().build()\nval myRequest = OneTimeWorkRequest.Builder(myWorker::class.java)\n                                  .setConstraints(myContraints)\n                                  .build()\n\n\n1\n2\n3\n4\n\n\nOneTimeWorkRequest.Builder用于构建单次运行的后台任务请求\n\nPeriodicWorkRequest.Builder用于构建周期运行的后台任务请求，且运行间隔不能短于15 mins\n\n在创建Constraints和创建WorkRequest时可以配置各种各样的运行条件和约束条件\n\n构建后台任务请求 在MainActivity中将该后台任务请求传入WorkManager的enqueue方法。\n\nWorkManager.getInstance(this).enqueue(myRequest)\n\n\n1\n\n\n检查任务状态方法：\n\n WorkManager.getInstance(this).getWorkInfoByIdLiveData(myRequest.id)\n                              .observe(this){ workInfo ->\n \tif (workInfo.state == WorkInfo.State.SUCCEEDED){\n                //利用workInfo对结果进行判断\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n取消任务方法：\n\nWorkManager.getInstance(this).cancelByWorkId(myRequest.id)\n\n\n1\n\n\n\n# 含参Worker类\n\n使用键值对和Data对象进行参数的输入和结果的返回。\n\n在主函数中通过观察任务的WorkStatus获取输出\n\nTestWorker类\n\nclass TestWorker(context: Context, params: WorkerParameters) : Worker(context, params) {\n    companion object{\n        const val KEY_INT_ARG = "INT"\n        const val KEY_STR_ARG = "STR"\n        const val KEY_LIST_ARG = "LIST"\n        const val KEY_CLASS_ARG = "CLASS"\n        const val KEY_RESULT = "RESULT"\n    }\n    @SuppressLint("RestrictedApi")\n    override fun doWork(): Result {\n    //获取参数\n    val int = inputData.getInt(KEY_INT_ARG, 0)\n    println("int:$int.toString()")\n    val str = inputData.getString(KEY_STR_ARG)\n    /**\n     * 仅传递基础数据类型和其构成的数组\n     * 对于类和类组成的数组，需要使用Gson转换成json字符串\n     * Gson依赖：implementation \'com.google.code.gson:gson:2.8.6\'\n     */\n    val list: ArrayList<TestClass> = Gson().fromJson(\n        inputData.getString(KEY_LIST_ARG),\n        object : TypeToken<ArrayList<TestClass>>() {}.type\n    )\n    val cls: TestClass = Gson().fromJson(\n        inputData.getString(KEY_CLASS_ARG),\n        object : TypeToken<TestClass>() {}.type\n    )\n\n    //对参数进行操作\n    println("TestWorker:")\n    println("int:$int.toString()")\n    println("str:$str")\n    for (item in list){\n        println("list:${item.text}")\n    }\n    println("class:${cls.text}")\n\n    //返回值\n    val listString = Gson().toJson(list)\n    val result = Data.Builder().putString(KEY_RESULT, listString).build()\n    return Result.Success(result)\n}\n}\n\n\n主函数\n\nclass MainActivity : AppCompatActivity() {\n    @SuppressLint("EnqueueWork")\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        //非基本类型参数转换成String\n        val cls = TestClass("TestClass")\n        val clsString = Gson().toJson(cls)\n        val list = ArrayList<TestClass>()\n        list.add(TestClass("TestClass1"))\n        list.add(TestClass("TestClass2"))\n        list.add(TestClass("TestClass3"))\n        val listString = Gson().toJson(list)\n        //创建参数\n        val myData = Data.Builder().putInt(TestWorker.KEY_INT_ARG, 999)\n                                   .putString(TestWorker.KEY_STR_ARG, "String")\n                                   .putString(TestWorker.KEY_CLASS_ARG, clsString)\n                                   .putString(TestWorker.KEY_LIST_ARG, listString)\n                                   .build()\n        //构建后台\n        val work = OneTimeWorkRequest.Builder(TestWorker::class.java)\n                                     .setInputData(myData)\n                                     .build()\n        WorkManager.getInstance(this).enqueue(work)\n        //获得返回值\n        WorkManager.getInstance(this).getWorkInfoByIdLiveData(work.id)\n                                     .observe(this){workInfo ->\n            val str = workInfo.outputData.getString(TestWorker.KEY_RESULT)\n            if (str != null){\n                val result: ArrayList<TestClass> = Gson().fromJson(str, object : TypeToken<ArrayList<TestClass>>() {}.type)\n                for (item in result){\n                    println("result:${item.text}")\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n链式任务 WorkManager允许我们创建和排队多个任务的工作序列，以及它们按照什么顺序运行。\n\n任何一个任务返回Work.WorkResult.FAILURE，整个序列结束\n\nWorkManager.getInstance(this).beginWith(workA)\n                             .then(workB)\n                             .then(workC)\n                             .enqueue()\n\n\n1\n2\n3\n4\n\n\n允许多个对象传递给begin()和then()\n\nWorkManager并行运行同一次方法传进的任务\n\nWorkManager.getInstance(this).beginWith(listOf(workerA1, workerA2, workerA3))\n                             .then(listOf(workerB1, workerB2))\n                             .then(workerC)\n                             .enqueue()\n\n\n1\n2\n3\n4\n\n\n允许使用WorkContinuation.combine方法连接多个链\n\nWorkManager根据连接链的顺序依次运行。\n\n链内任务按顺序执行\n\n链间任务可能重叠导致任务顺序的改变。\n\nval chain1 = WorkManager.getInstance(this)\n                         .beginWith(workerA1)\n                         .then(workerB1)\nval chain2 = WorkManager.getInstance(this)\n                        .beginWith(workerA2)\n                        .then(workerB2)\nWorkContinuation.combine(listOf(chain1, chain2))\n                .then(workerC)\n                .enqueue()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# IPC\n\n为啥要在这里突然提起IPC呢？ 因为服务在我们日常的开发中，它还有一个重要的使用场景：作为一个子进程！！！，既然有多个进程，肯定会涉及到进程间通信的问题。那 进程间通信 就是 IPC 了\n\nIPC (Inter processCommunication) 就是指的是不同进程之间的数据交换。也被叫做进程间通信。那么，在安卓中，我们怎么去测试多进程的内容。这个就首先涉及到了安卓应用开启多进程的方式。我们只需要在四大组件的xml属性中加上\n\nandroid:precess = "xxx"\n\n\n1\n\n\n就可以了。\n\n既然分了多个进程，肯定会出现数据不同步的问题，大佬们总结了一下，有一下几个：\n\n * 静态成员和单例完全失效\n * 线程同步机制完全失效\n * SharedPreferences的可靠性下降\n * Apllication会多次创建\n\n这个问题总的来说，就是因为不在同一个进程，没有共享内存，那么生成的字节码相互之间访问不了，地址都不同，肯定是会出问题的。这就涉及到了跨进程通信的使用了。\n\n这里，我们就在服务里面使用\n\nandroid:precess = "xxx"\n\n\n1\n\n\n属性将其变为子进程。再看看之前的绑定交换数据的操作能不能成功。\n\nemmmmm , 一运行就出问题了\n\n    java.lang.ClassCastException: android.os.BinderProxy cannot be cast to cc.fastcv.codelab.services.BaseBinder\n\n\n1\n\n\n它告诉我无法强转？ 我就是返回的 BaseBinder 对象呀，为啥无法强转呢？\n\n因为我们返回的是这个对象的引用，但是在不同的进程里面，都不在同一块内存了，引用根本无法访问，更别说强转了。那该怎么办呢？\n\n无法访问对象引用，那只能将数据完完整整的传递过去了。常见的IPC方式有：\n\n\n# 跨进程通信的方式\n\n\n# 广播\n\n广播的话，是最容易理解的，就比如系统广播一样，可以携带一些数据给其他应用。这个可以去看广播的章节。\n\n\n# 内容提供者\n\n这个也是一样的，提供一个URI给外部应用区访问内部应用的数据库数据。这个可以去看内容提供者的章节。\n\n\n# Socket\n\n这个也可以理解，直接以网络的形式进行数据传输。\n\n\n# Messenger\n\nMessenger可以翻译为信使，顾名思义，通过它可以在不同进程传递Message对象，在Message中放入我们需要传递的数据，就可以轻松的实现数据的进程间传递了。Messenger是一种轻量级的IPC方案，就像上面说的，它的底层实现时AIDL。\n\n# 服务端\n\n我们首先实现一个服务端：\n\nclass BaseService : Service() {\n    companion object {\n        private const val TAG = "BaseService"\n    }\n\n    private val messengerHandler = object : Handler(Looper.getMainLooper()) {\n        override fun handleMessage(msg: Message) {\n            Log.d(TAG, "receive msg from Client: " + msg.data.getString("msg"))\n        }\n    }\n\n    private val messenger = Messenger(messengerHandler)\n\n    override fun onCreate() {\n        super.onCreate()\n        Log.d(TAG, "onCreate: ${Thread.currentThread().name}")\n    }\n\n    override fun onBind(intent: Intent?): IBinder? {\n        return messenger.binder\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注册为单个进程\n\n    <service android:name="xxx"\n            android:process=":remote"/>\n\n\n1\n2\n\n\n# 客户端\n\n再实现客户端：\n\n    private var messenger: Messenger? = null\n\n    private val serviceConnection = object : ServiceConnection {\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n            Log.d(TAG, "onServiceConnected: ")\n            messenger = Messenger(service)\n        }\n\n        override fun onServiceDisconnected(name: ComponentName?) {\n            Log.d(TAG, "onServiceDisconnected: ")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 消息\n\n发送消息：\n\n    val message = Message.obtain()\n    val bundle = Bundle()\n    bundle.putString("msg","Hello I\'m Client")\n    message.data = bundle\n    messenger?.send(message)\n\n\n1\n2\n3\n4\n5\n\n\n# 结果\n\n结果：\n\n2022-10-24 17:30:30.080 16283-16283/cc.fastcv.codelab D/MainActivity: onCreate: \n2022-10-24 17:30:33.282 16458-16458/cc.fastcv.codelab D/BaseService: onCreate: main\n2022-10-24 17:30:33.282 16458-16458/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 17:30:33.284 16283-16283/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 17:30:35.763 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I\'m Client\n2022-10-24 17:30:36.924 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I\'m Client\n2022-10-24 17:30:39.025 16458-16458/cc.fastcv.codelab D/BaseService: unbindService: \n2022-10-24 17:30:39.026 16458-16458/cc.fastcv.codelab D/BaseService: onDestroy: \n2022-10-24 17:30:40.699 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I\'m Client\n2022-10-24 17:30:41.532 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I\'m Client\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从结果上看，我们明明已经停止服务了。为啥还可以继续发送消息呢？\n\n这是因为，我们的 Binder 服务已经跑起来了，相互建立连接后，依赖的是 Binder 服务在通信，和Service无关了。\n\n# 异常处理\n\n如果我们的远程服务进程死掉了，那么我们再发送消息的时候就会出现一个异常：\n\n     Caused by: android.os.DeadObjectException\n        at android.os.BinderProxy.transactNative(Native Method)\n        at android.os.BinderProxy.transact(BinderProxy.java:510)\n        at android.os.IMessenger$Stub$Proxy.send(IMessenger.java:123)\n        at android.os.Messenger.send(Messenger.java:57)\n        at com.example.pipixia.MainActivity.send(MainActivity.kt:68)\n\n\n1\n2\n3\n4\n5\n6\n\n\n所以，我们在发送消息时，需要做异常处理。\n\n    fun send(view: View?) {\n        val message = Message.obtain()\n        val bundle = Bundle()\n        bundle.putString("msg","Hello I\'m Client")\n        message.data = bundle\n\n        try {\n            messenger?.send(message)\n        } catch (e: RemoteException) {\n            Log.d(TAG, "send: messenger 消息发送失败")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 双向通信\n\n其实，实现双向通信的诀窍在 Message 的 replyTo 字段上，我们可以把我们客户端加一个 Messenger 当成一个 服务端来使用。只要将客户端服务器的 binder 地址发送给服务端即可。\n\n客户端\n\n    //新增服务\n    private val messengerHandler = object : Handler(Looper.getMainLooper()) {\n        override fun handleMessage(msg: Message) {\n            Log.d(TAG, "receive msg from Server: " + msg.data.getString("msg"))\n        }\n    }\n\n    private val messengerServer = Messenger(messengerHandler)\n    \n    //发送消息时 带上服务地址\n    val message = Message.obtain()\n    val bundle = Bundle()\n    bundle.putString("msg","Hello I\'m Client")\n    message.data = bundle\n    message.replyTo = messengerServer\n    messenger?.send(message)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n服务端：\n\n    //收到消息 回复\n    val message = Message.obtain()\n    val bundle = Bundle()\n    bundle.putString("msg","Hello I\'m Server")\n    message.data = bundle\n    msg.replyTo.send(message)\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果：\n\n2022-10-24 17:47:32.433 17222-17222/cc.fastcv.codelab D/MainActivity: onCreate: \n2022-10-24 17:47:39.798 17280-17280/cc.fastcv.codelab D/BaseService: onCreate: main\n2022-10-24 17:47:39.799 17280-17280/cc.fastcv.codelab D/BaseService: onBind: \n2022-10-24 17:47:39.801 17222-17222/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-24 17:47:43.332 17280-17280/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I\'m Client\n2022-10-24 17:47:43.333 17222-17222/cc.fastcv.codelab D/MainActivity: receive msg from Server: Hello I\'m Server\n\n\n1\n2\n3\n4\n5\n6\n\n\n总结\n\n * 优点：使用简单，上手很快\n * 缺点：执行方法时串行的，只能一个一个的执行，不能进行大量的并发处理。这个时候还是得用AIDL。\n\n\n# AIDl\n\nAIDL是Android中IPC（Inter-Process Communication）方式中的一种，AIDL是Android Interface definition language的缩写，对于小白来说，AIDL的作用是让你可以在自己的APP里绑定一个其他APP的service，这样你的APP可以和其他APP交互。\n\n# 单向读写数据\n\n通过as我们在我们的包下新建一个AIDL文件，我们项目目录就会出现一个aidl文件夹，里面有我们刚才新建的那个AIDL文件，查看文件可以看到，如\n\ninterface IMyAidlInterface {\n    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,\n            double aDouble, String aString);\n}\n\n\n1\n2\n3\n4\n\n\n序列化\n\n前面说过，如果要把数据跨进程传输，需要把数据序列化之后才行，所以，这里我们举个例子，将Book类实现序列化接口：\n\ndata class Book(var bookId: Int, var bookName: String?) : Parcelable {\n    constructor(parcel: Parcel) : this(parcel.readInt(), parcel.readString()) {}\n\n    override fun writeToParcel(parcel: Parcel, flags: Int) {\n        parcel.writeInt(bookId)\n        parcel.writeString (bookName)\n    }\n\n    override fun describeContents(): Int {\n        return 0\n    }\n\n    companion object CREATOR : Parcelable.Creator<Book> {\n        override fun createFromParcel(parcel: Parcel): Book {\n            return Book(parcel)\n        }\n\n        override fun newArray(size: Int): Array<Book?> {\n            return arrayOfNulls(size)\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n实现AIDL文件\n\nimport cc.fastcv.codelab.Book;\n\ninterface IBookManagerInterface {\n\n    //得到所有的书籍\n    List<Book> getBookList();\n\n    //新增书籍\n    void addBook(in Book book);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n构建module自动生成类文件\n\n我们build下我们的项目模块，然后可以在\n\nbuild/generated/aidl_source_output_dir/[debug|release]/out/<packageName>/xxx/xxxx.java\n\n\n1\n\n\n我们可以点开看一下：(这里我们把它拆解一下)\n\npublic interface IBookManagerInterface extends android.os.IInterface\n{\n  public static class Default implements cc.fastcv.codelab.IBookManagerInterface\n  { ... }\n\n  public static abstract class Stub extends android.os.Binder implements cc.fastcv.codelab.IBookManagerInterface\n  {\n    ...\n    \n    private static class Proxy implements cc.fastcv.codelab.IBookManagerInterface\n    {\n     ...\n    }\n  }\n  //得到所有的书籍\n\n  public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException;\n  //新增书籍\n\n  public void addBook(cc.fastcv.codelab.Book book) throws android.os.RemoteException;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这样子，整体结构就比较清晰了，首先是一个大的接口类：IBookManagerInterface，然后在内部有一个静态的默认实现类Default实现了IBookManagerInterface接口。还有一个抽象代理类Stub也实现了IBookManagerInterface并且继承自 android.os.Binder，如果你仔细看这个Stub类的内容，你会发现很多很奇怪的内容，如：\n\n        case TRANSACTION_getBookList:\n        {\n          data.enforceInterface(descriptor);\n          java.util.List<cc.fastcv.codelab.Book> _result = this.getBookList();\n          reply.writeNoException();\n          reply.writeTypedList(_result);\n          return true;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n还有就是它本身没有实现IBookManagerInterface接口的方法，它只是定义了一些常量和相应常量的底层处理逻辑。那谁实现了IBookManagerInterface接口？\n\n没错就是最后一个类 Proxy 实现的这个接口，从它的内容来看，它并不关心底层的逻辑是怎么样处理的，它只用实现 IBookManagerInterface 的方法，然后通过 android.os.IBinder mRemote 来实现底层逻辑，如：\n\n            @Override\n            public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                java.util.List<cc.fastcv.codelab.Book> _result;\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);\n                    if (!_status && getDefaultImpl() != null) {\n                        return getDefaultImpl().getBookList();\n                    }\n                    _reply.readException();\n                    _result = _reply.createTypedArrayList(cc.fastcv.codelab.Book.CREATOR);\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n服务端\n\nclass BookService : Service() {\n    companion object {\n        val TAG = "ServerService"\n    }\n\n    val manager = object : IBookManagerInterface.Stub() {\n        override fun getBookList(): MutableList<Book> {\n            Log.d(TAG, "getBookList:  pid = ${myPid()}")\n            return books\n        }\n\n        override fun addBook(book: Book?) {\n            Log.d(TAG, "addBook: $book  pid = ${myPid()}")\n            books.add(book!!)\n        }\n    }\n\n    val books = ArrayList<Book>()\n\n    override fun onBind(intent: Intent?): IBinder? {\n        Log.d(TAG, "onBind: ")\n        return manager\n    }\n\n    override fun onUnbind(intent: Intent?): Boolean {\n        Log.d(TAG, "onUnbind: ")\n        return super.onUnbind(intent)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(TAG, "onDestroy: ")\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n记得在清单文件加上\n\n        <service android:name=".services.BookService"\n            android:process=":remote"/>\n\n\n1\n2\n\n\n客户端\n\n    var stub:IBookManagerInterface? = null\n\n    private val serviceConnection = object : ServiceConnection {\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n            Log.d(TAG, "onServiceConnected: ")\n            stub = IBookManagerInterface.Stub.asInterface(service)\n        }\n\n        override fun onServiceDisconnected(name: ComponentName?) {\n            Log.d(TAG, "onServiceDisconnected: ")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n新增\n\n       stub?.addBook(Book(index++,"C语言$index 册"))\n\n\n1\n\n\n查询\n\n        stub?.bookList?.let {\n            for (book in it) {\n                Log.d(TAG, "书籍信息: $book")\n            }\n        }\n\n\n1\n2\n3\n4\n5\n\n\n结果：\n\n2022-10-25 14:10:12.960 13642-13656/cc.fastcv.codelab D/ServerService: getBookList:  pid = 13642\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=1, bookName=C语言2 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=2, bookName=C语言3 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=3, bookName=C语言4 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=4, bookName=C语言5 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=5, bookName=C语言6 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=6, bookName=C语言7 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=7, bookName=C语言8 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=8, bookName=C语言9 册)\n2022-10-25 14:10:26.973 13642-13656/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=9, bookName=C语言10 册)  pid = 13642\n2022-10-25 14:10:31.545 13642-13656/cc.fastcv.codelab D/ServerService: getBookList:  pid = 13642\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=1, bookName=C语言2 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=2, bookName=C语言3 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=3, bookName=C语言4 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=4, bookName=C语言5 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=5, bookName=C语言6 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=6, bookName=C语言7 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=7, bookName=C语言8 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=8, bookName=C语言9 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=9, bookName=C语言10 册)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 双向读写数据\n\n在实现双向读写数据时，我们先记住一些常识，如AIDL支持的数据类型有哪些\n\n * 基本数据类型（int、long、char、boolean、double等）\n * String 和 CharSequence\n * List：只支持ArrayList，里面的每个元素都必须能够被AIDL支持\n * Map：只支持HashMap，里面的每个元素都必须能够被AIDL支持，包括key和value\n * Parcelable：所有实现了Parcelable接口的对象\n * AIDL ：所有的AIDL接口本身也可以在AIDL文件中使用\n\n但是，其中自定义的parcelable对象和AIDL对象必须显示import进来，不管它们是否和当前的AIDL文件位于同一个包内。就像我们的Book\n\nimport cc.fastcv.codelab.Book;\n\n\n1\n\n\n接下来，我们想象一下，怎么样实现双向读写数据。从上面的代码，我们可以看到，客户端向服务器读写数据时，是拿到了服务器的一个BInder对象然后进行数据读写的，那么我们可不可以逆向思维，把客户端也当成一个服务器，实现一个BInder接口。因为上面说了，可以把AIDL接口本身进行传递，我们来试一下\n\n首先实现客户端接收消息的AIDL\n\ninterface IServerNotyfyInterface {\n    void nofity(int limit);\n}\n\n\n1\n2\n3\n\n\n然后，修改之前服务端实现的接口，需要把我们客户端的接口注册过去，还得取消注册\n\nimport cc.fastcv.codelab.Book;\nimport cc.fastcv.codelab.IServerNotyfyInterface;\n\ninterface IBookManagerInterface {\n\n    //得到所有的书籍\n    List<Book> getBookList();\n\n    //新增书籍\n    void addBook(in Book book);\n\n    //传入我们的Binder\n    void register(IServerNotyfyInterface listener);\n\n    //取消监听\n    void unRegister(IServerNotyfyInterface listener);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n实现客户端接收消息\n\n    val listener = object : IServerNotyfyInterface.Stub() {\n        override fun nofity(limit: Int) {\n            Log.d(TAG, "nofity: limit = $limit")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n\n\n    //注册监听\n    stub?.register(listener)\n    //注销监听\n    stub?.register(listener)\n\n\n1\n2\n3\n4\n\n\n服务端接收客户端的binder注册和反注册\n\n    var notify:IServerNotyfyInterface? = null\n\n    val manager = object : IBookManagerInterface.Stub() {\n        override fun getBookList(): MutableList<Book> {\n            Log.d(TAG, "getBookList:  pid = ${myPid()}")\n            return books\n        }\n\n        override fun addBook(book: Book?) {\n            Log.d(TAG, "addBook: $book  pid = ${myPid()}")\n            if (notify != null && notify!!.asBinder().isBinderAlive && books.size%5 == 0) {\n                notify!!.nofity(books.size)\n            }\n            books.add(book!!)\n        }\n\n        override fun register(listener: IServerNotyfyInterface?) {\n            Log.d(TAG, "register: ${listener.hashCode()}")\n            notify = listener\n        }\n\n        override fun unRegister(listener: IServerNotyfyInterface?) {\n            Log.d(TAG, "register: ${listener.hashCode()}")\n            notify = null\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在代码中可以看到，我们添加书籍的数量达到5的倍数后就会提醒客户端一次。\n\n2022-10-25 15:22:37.921 23575-23575/cc.fastcv.codelab D/ServerService: onBind: \n2022-10-25 15:22:37.922 23521-23521/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-25 15:22:37.923 23575-23588/cc.fastcv.codelab D/ServerService: register: 107797164\n2022-10-25 15:22:44.897 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=1, bookName=C语言2 册)  pid = 23575\n2022-10-25 15:22:44.898 23521-23521/cc.fastcv.codelab D/MainActivity: nofity: limit = 0\n2022-10-25 15:22:47.277 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=2, bookName=C语言3 册)  pid = 23575\n2022-10-25 15:22:49.655 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=3, bookName=C语言4 册)  pid = 23575\n2022-10-25 15:22:51.132 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=4, bookName=C语言5 册)  pid = 23575\n2022-10-25 15:22:52.287 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=5, bookName=C语言6 册)  pid = 23575\n2022-10-25 15:22:53.610 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=6, bookName=C语言7 册)  pid = 23575\n2022-10-25 15:22:53.611 23521-23521/cc.fastcv.codelab D/MainActivity: nofity: limit = 5\n2022-10-25 15:22:55.674 23521-23533/cc.fastcv.codelab W/System: A resource failed to call close. \n2022-10-25 15:22:55.726 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=7, bookName=C语言8 册)  pid = 23575\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样子，我们就实现了双向读写操作了。\n\n这里还存在一个问题\n\n我们看，我们注册的listener的hashcode和 取消注册的hashcode 的值\n\n2022-10-25 15:28:54.154 23929-23929/cc.fastcv.codelab D/ServerService: onBind: \n2022-10-25 15:28:54.155 23881-23881/cc.fastcv.codelab D/MainActivity: onServiceConnected: \n2022-10-25 15:28:54.157 23929-23946/cc.fastcv.codelab D/ServerService: register: 107797164\n2022-10-25 15:28:56.525 23929-23946/cc.fastcv.codelab D/ServerService: register: 67220341\n2022-10-25 15:28:56.527 23929-23929/cc.fastcv.codelab D/ServerService: onUnbind: \n2022-10-25 15:28:56.527 23929-23929/cc.fastcv.codelab D/ServerService: onDestroy:\n\n\n1\n2\n3\n4\n5\n6\n\n\n两个值不一样，那么，如果存在多个listener组成一个集合，如：\n\n    val nofitys = ArrayList<IServerNotyfyInterface>()\n\n\n1\n\n\n那么，在取消监听的时候，就会出现一个问题，我们无法从集合中remove掉这个对象，那这种情况怎么处理呢？我们可以使用：\n\n    val nofitys = RemoteCallbackList<IServerNotyfyInterface>()   \n    \n    nofitys.register(listener)   \n    \n    nofitys.unregister(listener)\n\n\n1\n2\n3\n4\n5\n\n\n# 简析源码\n\n我们前面简单看过 AIDL文件生成的 接口文件的组成\n\n * 真正的接口文件\n * Stub Binder的继承者，接口的实现者，实现底层数据处理逻辑，是个抽象类\n * Proxy 接口的代理类，具体接口方法的实现类\n\n然后，看看我们服务端的具体实现\n\n    val manager = object : IBookManagerInterface.Stub() {\n        override fun getBookList(): MutableList<Book> {\n            Log.d(TAG, "getBookList:  pid = ${myPid()}")\n            return books\n        }\n\n        override fun addBook(book: Book?) {\n            Log.d(TAG, "addBook: $book  pid = ${myPid()}")\n            if (notify != null && notify!!.asBinder().isBinderAlive && books.size%5 == 0) {\n                notify!!.nofity(books.size)\n            }\n            books.add(book!!)\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以看到，这里用匿名类的方法实现了IBookManagerInterface.Stub 这个抽象类，并且处理真正的数据。那当我们新增书籍的时候到底做了哪些事情呢？我们看看。\n\n首先在客户端，我们拿到binder对象的方式为：\n\n    var stub:IBookManagerInterface? = null\n    stub = IBookManagerInterface.Stub.asInterface(service)\n\n\n1\n2\n\n\n这里用到了asInterface方法：\n\n    public static cc.fastcv.codelab.IBookManagerInterface asInterface(android.os.IBinder obj)\n    {\n      if ((obj==null)) {\n        return null;\n      }\n      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n      if (((iin!=null)&&(iin instanceof cc.fastcv.codelab.IBookManagerInterface))) {\n        return ((cc.fastcv.codelab.IBookManagerInterface)iin);\n      }\n      return new cc.fastcv.codelab.IBookManagerInterface.Stub.Proxy(obj);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将binder本身传入，然后通过Stub.Proxy代理的方式，获取到代理类。\n\n    private static class Proxy implements cc.fastcv.codelab.IBookManagerInterface\n    {\n      private android.os.IBinder mRemote;\n      \n      Proxy(android.os.IBinder remote)\n      {\n        mRemote = remote;\n      }\n      \n      @Override public android.os.IBinder asBinder()\n      {\n        return mRemote;\n      }\n      \n      public java.lang.String getInterfaceDescriptor()\n      {\n        return DESCRIPTOR;\n      }\n      \n      //得到所有的书籍\n      @Override public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException\n      {\n        ...\n      }\n      \n      //新增书籍\n\n      @Override public void addBook(cc.fastcv.codelab.Book book) throws android.os.RemoteException\n      {\n        ...\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n可以看到，Stub.Proxy本身与Binder无关，只是引用外部传入的mRemote做的操作，并且实现了IBookManagerInterface接口的相关方法。\n\n那也就是说，调用新增书籍的方法是从这里进入的。\n\n      //新增书籍\n      @Override public void addBook(cc.fastcv.codelab.Book book) throws android.os.RemoteException\n      {\n        //分配数据载体对象\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        //分配数据返回对象\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        try {\n          //写入标识\n          _data.writeInterfaceToken(DESCRIPTOR);\n          if ((book!=null)) {\n            _data.writeInt(1);\n            //写入序列化数据\n            book.writeToParcel(_data, 0);\n          }\n          else {\n            _data.writeInt(0);\n          }\n          //获取数据传输结果\n          boolean _status = mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);\n          ...\n          //读取返回是否有异常信息\n          _reply.readException();\n        }\n        finally {\n          //回收资源\n          _reply.recycle();\n          _data.recycle();\n        }\n      }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这里逻辑比较简单，我们继续看 mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); 是怎么样的处理逻辑\n\n这里的mRemote，有印象的人会知道它是 IBookManagerInterface.Stub 的实现类，也就是我们在服务端实现的 匿名类，它本身实现的onTransact为：\n\n    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n    {\n      java.lang.String descriptor = DESCRIPTOR;\n      //code 方法标识\n      switch (code)\n      {\n        ...\n        case TRANSACTION_addBook:\n        {\n          //校验标识 如果存在错误的接口类型，则会引发 SecurityException。\n          data.enforceInterface(descriptor);\n          cc.fastcv.codelab.Book _arg0;\n          //检验是否有写入值 如果有则反序列化\n          if ((0!=data.readInt())) {\n            _arg0 = cc.fastcv.codelab.Book.CREATOR.createFromParcel(data);\n          }\n          else {\n            _arg0 = null;\n          }\n          this.addBook(_arg0);\n          reply.writeNoException();\n          return true;\n        }\n        ...\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n可以看到，这里最终调用了this.addBook(_arg0); ，也就是最终调用到了我们实现的匿名类中。\n\n新增是客户端往服务端写，那读取列表是怎么实现的呢？\n\n      @Override public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException\n      {\n        android.os.Parcel _data = android.os.Parcel.obtain();\n        android.os.Parcel _reply = android.os.Parcel.obtain();\n        java.util.List<cc.fastcv.codelab.Book> _result;\n        try {\n          _data.writeInterfaceToken(DESCRIPTOR);\n          boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);\n          if (!_status && getDefaultImpl() != null) {\n            return getDefaultImpl().getBookList();\n          }\n          _reply.readException();\n          //如果没有出现异常，则读取数据\n          _result = _reply.createTypedArrayList(cc.fastcv.codelab.Book.CREATOR);\n        }\n        finally {\n          _reply.recycle();\n          _data.recycle();\n        }\n        return _result;\n      }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n    {\n      java.lang.String descriptor = DESCRIPTOR;\n      switch (code)\n      {\n        ...\n        case TRANSACTION_getBookList:\n        {\n          data.enforceInterface(descriptor);\n          java.util.List<cc.fastcv.codelab.Book> _result = this.getBookList();\n          reply.writeNoException();\n          reply.writeTypedList(_result);\n          return true;\n        }\n        ...\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到，最后就是通过 reply 写入返回值。\n\n总结\n\n客户端总的来说：（带返回值的）\n\n * 首先创建一个Parcel _data用于传值\n * 再创建一个Parcel _reply用于收值\n * 最后创建个我们要接收的类型，之后开始写入 如果没有就不写\n * 首先_data写入我们的标识， _data.writeInterfaceToken(DESCRIPTOR);\n * 如果有值要传入，就写_data.writeStrongBinder((((listener!=null))?(listener.asBinder()):(null))); 否则不写\n * 最后发起请求Ibinder.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0)\n * 再_reply.readException();\n * 最后从_reply 取值 _result = _reply.createTypedArrayList(com.example.pipixia.ipc.aidl.Book.CREATOR); 如果没有值取就不写\n * 然后回收 Parcel\n\n服务端：\n\n * data.enforceInterface(descriptor); 必须写\n * 如果有返回值 则拿值 java.util.List<com.example.pipixia.ipc.aidl.Book> _result = this.getBookList(); ， 没有则不写\n * 如果有传入的值，则拿值 arg0 = com.example.pipixia.ipc.aidl.Book.CREATOR.createFromParcel(data);; ， 没有则不写\n * eply.writeNoException();\n * 如果有返回值就写这行 reply.writeTypedList(_result); 否则不写\n * return true;\n\n这里我们虽然能猜到onTransact方法大概是干嘛的，但是它最后一个参数还是要讲一下：\n\n其中四个参数的意义是：\n\n字段      作用\ncode    是一个整形的唯一标识，用于区分执行哪个方法，客户端会传递此参数，告诉服务端执行哪个方法\ndata    客户端传递过来的参数\nreply   服务器返回回去的值\nflags   标明是否有返回值，0为有（双向），1为没有（单向）\n\n\n# Binder\n\n说了这么久的Binder，那Binder到底是什么？\n\nIBinder是远程对象的基本接口，是为了高性能而设计的轻量级远程调用机制的核心部分。但它不仅用于远程调用，也用于进程内调用。该接口定义了与远程对象间交互的协议。但不要直接实现 这个接口，而是继承(extends)Binder。\n\nIBinder主要的API是transact()，与之对应的API是Binder.onTransact()。通过前者，你能 想远程IBinder对象发送发出调用，后者使你的远程对象能够响应接收到的调用。IBinder的API都是 Syncronous(同步)执行的，比如transact()直到对方的Binder.onTransact()方法调用玩 后才返回。 调用发生在进程内时无疑是这样的，而在进程间时，在IPC的帮助下，也是同样的效果。\n\n通过transact()发送的数据是Parcel，Parcel是一种一般的缓冲区，除了有数据外还带有 一些描述它内容的元数据。元数据用于管理IBinder对象的引用，这样就能在缓冲区从一个进程移动 到另一个进程时保存这些引用。这样就保证了当一个IBinder被写入到Parcel并发送到另一个进程中， 如果另一个进程把同一个IBinder的引用回发到原来的进程，那么这个原来的进程就能接收到发出的 那个IBinder的引用。这种机制使IBinder和Binder像唯一标志符那样在进程间管理。\n\n系统为每个进程维护一个存放交互线程的线程池。这些交互线程用于派送所有从另外进程发来的IPC 调用。例如：当一个IPC从进程Ａ发到进程Ｂ，Ａ中那个发出调用的线程(这个应该不在线程池中)就阻塞 在transact()中了。进程Ｂ中的交互线程池中的一个线程接收了这个调用，它调用 Binder.onTransact()，完成后用一个Parcel来做为结果返回。然后进程Ａ中的那个等待的线程在 收到返回的Parcel后得以继续执行。实际上，另一个进程看起来就像是当前进程的一个线程， 但不是当前进程创建的。\n\nBinder机制还支持进程间的递归调用。例如，进程Ａ执行自己的IBinder的transact()调用进程Ｂ 的Binder，而进程Ｂ在其Binder.onTransact()中又用transact()向进程Ａ发起调用，那么进程Ａ 在等待它发出的调用返回的同时，还会用Binder.onTransact()响应进程Ｂ的transact()。 总之Binder造成的结果就是让我们感觉到跨进程的调用与进程内的调用没什么区别。\n\n直观来说，Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager(AM，WM，等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端就会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通服务和基于AIDL的服务。\n\nBinder能干什么？Binder可以提供系统中任何程序都可以访问的全局服务。这个功能当然是任何系统都应该提供的，下面我们简单看一下Android的Binder的框架\n\nAndroid Binder框架分为服务器接口、Binder驱动、以及客户端接口；简单想一下，需要提供一个全局服务，那么全局服务那端即是服务器接口，任何程序即客户端接口，它们之间通过一个Binder驱动访问。\n\n服务器端接口：实际上是Binder类的对象，该对象一旦创建，内部则会启动一个隐藏线程，会接收Binder驱动发送的消息，收到消息后，会执行Binder对象中的onTransact()函数，并按照该函数的参数执行不同的服务器端代码。\n\nBinder驱动：该对象也为Binder类的实例，客户端通过该对象访问远程服务。\n\n客户端接口：获得Binder驱动，调用其transact()发送消息至服务器\n\nBinder在运行过程中，可能由于某些原因导致异常终止了，这个时候我们到服务端的Binder连接断裂（称之为Binder死亡），会导致我们的远程调用失败。更为关键的是，如果我们不知道Binder连接已经断裂，那么客户端的功能就会收到影响。为了解决这个问题，Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath我们可以给Binder设置一个死亡代理，当Binder死亡时，我们就会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接。\n\n    val deathRecipient = IBinder.DeathRecipient {\n        Log.d(TAG, ": binderDied")\n    }\n\n    private val serviceConnection = object : ServiceConnection {\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n            Log.d(TAG, "onServiceConnected: ")\n            service?.linkToDeath(deathRecipient,0)\n            stub = IBookManagerInterface.Stub.asInterface(service)\n        }\n\n        override fun onServiceDisconnected(name: ComponentName?) {\n            Log.d(TAG, "onServiceDisconnected: ")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n默认情况下，我们的远程服务任何人都可以连接，但这不应该是我们愿意看到的。所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务中的方法。这里有两种方式：\n\n声明权限\n\n    <permission android:name="com.example.pipixia.ipc.permission" />\n\n\n1\n\n\n在需要判断的地方加上这个\n\n            val check = checkCallingOrSelfPermission("com.example.pipixia.ipc.permission")            \n            if (check == PackageManager.PERMISSION_DENIED) {\n                return false\n            }\n\n\n1\n2\n3\n4\n\n\n申请权限\n\n    <uses-permission android:name="com.example.pipixia.ipc.permission" />\n\n\n1\n\n\n\n# Android 8.0\n\n * 在 Android 8.0 （API26）之前，创建前台服务的方式通常是先创建一个后台服务，然后将该服务推到前台。\n\n * Android 8.0 （API26）有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。\n\n * 在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。\n\n * 如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。\n\nandroid.app.RemoteServiceException: Context.startForegroundService() did not then call Service.startForeground()\nat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1768)\nat android.os.Handler.dispatchMessage(Handler.java:106)\nat android.os.Looper.loop(Looper.java:164)\nat android.app.ActivityThread.main(ActivityThread.java:6494)\nat java.lang.reflect.Method.invoke(Native Method)\nat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解决方法\n\n将 调用 startService启动Service 改为调用 startForegroundService\n\npublic static void start() {\n        Intent intent = new Intent(AppContext.me(), ScoreRefreshServer.class);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            AppContext.me().startForegroundService(intent);\n        } else {\n            AppContext.me().startService(intent);\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n并且，在service的onCreate方法中调用startForeground()\n\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {   \n          ...\n          Notification.Builder builder = new Notification.Builder(getApplicationContext(), AppEnv.UMENG_CHANNEL)\n                    .setContentTitle("正在后台运行")\n                    .setSmallIcon(R.mipmap.logo);\n          startForeground(1, builder.build());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到startForeground 方法需要传入一个通知，也就是，我们需要给用户一个直观的表现，我们有个应用在后台运行。通知的知识我们会有单独的章节总结。\n\n或者按照官方的推荐，我们使用 JobIntentService。\n\n\n# Android 9.0\n\n在 Android 9.0 中，应用在使用前台服务之前必须先申请 FOREGROUND_SERVICE 权限，否则就会抛出 SecurityException 异常。\n\n此外，由于 FOREGROUND_SERVICE 权限只是普通权限，因此开发者只需在 AndroidManifest.xml 中注册此权限即可，系统会自动对此权限进行授权：\n\n\n# Android 13.0\n\n这里对通知的改动比较大，所以需要提一下，注意下通知的变化。',normalizedContent:'service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (ipc)。 例如，服务可以处理网络事务、播放音乐，执行文件 i/o 或与内容提供程序交互，而所有这一切均可在后台进行。\n\n和activity一样，它也有自己的生命周期。但是和activity不同的是，不同的服务状态有不用的生命周期。\n\n所以，我们结合它的服务状态来探讨它的生命周期。但是在此之前，我们先了解下它的启动方式。\n\n\n# 启动方式\n\n这里和activity一样，分为 显式启动 和 隐式启动。\n\n\n# 显式启动\n\n        startservice(intent(this,baseservice::class.java))\n\n\n1\n\n\n        bindservice(intent(this,bactivity::class.java),serviceconnection, bind_auto_create)\n\n\n1\n\n\n直接使用startservice启动一个服务。\n\n这里解释下 bindservice 中需要的几个参数：\n\nserviceconnection：需要实现的一个接口\n\npublic interface serviceconnection {\n    void onserviceconnected(componentname name, ibinder service);\n\n    void onservicedisconnected(componentname name);\n\n    default void onbindingdied(componentname name) {\n    }\n\n    default void onnullbinding(componentname name) {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nflags：我们一般使用 bind_auto_create\n\n\n# 隐式启动\n\n        startservice(intent().apply {\n            action = "cc.fastcv.codelab.services.baseservice"\n        })\n\n\n1\n2\n3\n\n\n        bindservice(intent().apply {\n            action = "cc.fastcv.codelab.services.baseservice"\n        },serviceconnection, bind_auto_create)\n\n\n1\n2\n3\n\n\n这里的action就是我们在清单文件中配置的intent-filter的action。清单文件中，service的标签属性如下：\n\n<service android:enabled=["true" | "false"]\n    android:exported=["true" | "false"]\n    android:icon="drawable resource"\n    android:isolatedprocess=["true" | "false"]\n    android:label="string resource"\n    android:name="string"\n    android:permission="string"\n    android:process="string" >\n    . . .\n</service>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n属性                        作用\nandroid:exported          代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。\nandroid:name              对应service类名 android:permission：是权限声明\n                          android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：app-packagename:remote。\nandroid:isolatedprocess   设置 true\n                          意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的api(bind\n                          and start)。\nandroid:enabled           是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true\n                          的情况下服务才会被激活，否则不会激活。\nandroid:label             描述标签\nandroid:permission        启动权限\nandroid:name              必填，指向service的类名\n\n在安卓5.0之前，我们这样子去隐式启动一个服务是没有问题的。但是在安卓5.0之后，这样子启动就会报出错误：\n\n    java.lang.illegalargumentexception: service intent must be explicit: intent { act=cc.fastcv.codelab.services.baseservice }\n        at android.app.contextimpl.validateserviceintent(contextimpl.java:1851)\n        at android.app.contextimpl.startservicecommon(contextimpl.java:1892)\n        at android.app.contextimpl.startservice(contextimpl.java:1864)\n        at android.content.contextwrapper.startservice(contextwrapper.java:817)\n        at android.content.contextwrapper.startservice(contextwrapper.java:817)\n        at cc.fastcv.codelab.mainactivity.onclick(mainactivity.kt:28)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nandroid 5.0之后google出于安全的角度禁止了隐式声明intent来启动service。那么怎么适配呢？\n\n答案是：在现有基础上加上 packagename，如下：\n\n        startservice(intent().apply {\n            action = "cc.fastcv.codelab.services.baseservice"\n            `package` = packagename\n        })\n        \n\n\n1\n2\n3\n4\n5\n\n\n        bindservice(intent().apply {\n            action = "cc.fastcv.codelab.services.baseservice"\n            `package` = packagename\n        },serviceconnection, bind_auto_create)\n\n\n1\n2\n3\n4\n\n\n\n# 服务状态\n\n服务状态我在这里分为两种：\n\n * 启动状态：当应用组件（如 activity）通过调用 startservice() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。\n * 绑定状态：当应用组件通过调用 bindservice() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (ipc) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。\n\n简单来说，就是启动服务的基础接口有两个：\n\n * startservice\n * bindservice\n\n如果不需要和服务进行交互，只是单方面的给服务写入指令的话，我们就可以使用startservice；而要进行交互的话，就必须使用bindservice了。\n\n一种更复杂的情况是，我们可能在不同的情况下分别使用 startservice 和 bindservice来处理业务。所以，我们需要非常了解不同情况下的生命周期是如何回调的，这样子才能更好的使用服务来处理我们的业务功能。\n\n\n# 生命周期\n\n先来一张官方图镇场！！！\n\n\n\n\n# startservice\n\n从官方图上看，需要注意的是回调有：\n\n * oncreate\n * onstartcommand\n * ondestory\n\n其中 onstartcommand 是带参数的\n\n * intent ：启动时，启动组件传递过来的intent，如activity可利用intent封装所需要的参数并传递给service\n * flags：表示启动请求时是否有额外数据，可选值有 0，start_flag_redelivery，start_flag_retry，0代表没有，它们具体含义如下：\n   * start_flag_redelivery 这个值代表了onstartcommand方法的返回值为 start_redeliver_intent，而且在上一次服务被杀死前会去调用stopself方法停止服务。其中start_redeliver_intent意味着当service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 intent 调用 onstartcommand()，此时intent时有值的。\n   * start_flag_retry 该flag代表当onstartcommand调用后一直没有返回值时，会尝试重新去调用onstartcommand()。\n * startid ： 指明当前服务的唯一id，与stopselfresult (int startid)配合使用，stopselfresult 可以更安全地根据id停止服务。\n\n实际上onstartcommand的返回值int类型才是最最值得注意的，它有三种可选值， start_sticky，start_not_sticky，start_redeliver_intent，它们具体含义如下：\n\n * start_sticky 当service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此service，一旦创建成功后将回调onstartcommand方法，但其中的intent将是null，除非有挂起的intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。\n * start_not_sticky 当service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此service。除非程序中再次调用startservice启动此service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。\n * start_redeliver_intent 当service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 intent 调用 onstartcommand()，任何挂起 intent均依次传递。与start_sticky不同的是，其中的传递的intent将是非空，是最后一次调用startservice中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。\n\n从应用场景来看的话，有以下场景需要验证：\n\n\n# 启动 - 启动 - 启动\n\n2022-10-24 15:06:45.091 4702-4702/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:06:45.091 4702-4702/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1\n2022-10-24 15:06:54.102 4702-4702/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:2\n2022-10-24 15:06:54.799 4702-4702/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:3\n\n\n1\n2\n3\n4\n\n\n除了第一次启动会调用oncreate之外，后面都只会调用onstartcommand了。\n\n已验证：和activity无关，可以跨activity操作。\n\n\n# 启动 - 关闭 - 启动 - 启动\n\n2022-10-24 15:10:39.093 5410-5410/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:10:39.093 5410-5410/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1\n2022-10-24 15:11:29.012 5410-5410/cc.fastcv.codelab d/baseservice: ondestroy: \n2022-10-24 15:11:43.049 5410-5410/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:11:43.050 5410-5410/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1\n2022-10-24 15:11:47.284 5410-5410/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:2\n\n\n1\n2\n3\n4\n5\n6\n\n\n已验证：和activity无关，可以跨activity操作。\n\n\n# 启动 - 关闭 - 关闭 - 关闭\n\n2022-10-24 15:12:34.205 5410-5410/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:12:34.205 5410-5410/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1\n2022-10-24 15:12:36.335 5410-5410/cc.fastcv.codelab d/baseservice: ondestroy: \n\n\n1\n2\n3\n\n\n如果服务已经关闭，则再次调用 stopservice是没有任何反应的。\n\n已验证：和activity无关，可以跨activity操作。\n\n\n# 关闭 - 启动 - 启动 - 关闭\n\n2022-10-24 15:15:23.189 5410-5410/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:15:23.189 5410-5410/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1\n2022-10-24 15:15:26.936 5410-5410/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:2\n2022-10-24 15:15:28.642 5410-5410/cc.fastcv.codelab d/baseservice: ondestroy: \n\n\n1\n2\n3\n4\n\n\n已验证：和activity无关，可以跨activity操作。\n\n\n# bindservice\n\n从官方图上看，需要注意的是回调有：\n\n * oncreate\n * onbind\n * onunbind\n * ondestory\n\n在这里需要注意的是，在service的onbind回调中，如果返回的是null，会回调 onbind 但是，不会回调 connect里面的接口\n\n从应用场景来看的话，有以下场景需要验证：\n\n\n# 绑定 - 绑定 - 绑定\n\n2022-10-24 15:40:20.125 7906-7906/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:40:20.126 7906-7906/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 15:40:20.128 7906-7906/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 15:40:43.224 7906-7906/cc.fastcv.codelab d/bactivity: oncreate: \n2022-10-24 15:40:46.598 7906-7906/cc.fastcv.codelab d/bactivity: onserviceconnected: \n\n\n1\n2\n3\n4\n5\n\n\n不同的activity绑定之后，会有不用的connect接收，但是绑定之后再绑定是不会有任何回调的。\n\n\n# 绑定 - 解绑 - 绑定 - 绑定\n\n2022-10-24 15:42:29.512 8164-8164/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:42:29.512 8164-8164/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 15:42:29.514 8164-8164/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 15:42:31.043 8164-8164/cc.fastcv.codelab d/baseservice: onunbind: \n2022-10-24 15:42:31.043 8164-8164/cc.fastcv.codelab d/baseservice: ondestroy:\n2022-10-24 15:42:35.714 8164-8164/cc.fastcv.codelab d/bactivity: oncreate: \n2022-10-24 15:42:37.633 8164-8164/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:42:37.633 8164-8164/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 15:42:37.634 8164-8164/cc.fastcv.codelab d/bactivity: onserviceconnected: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n解绑之后，就会停止服务，再次绑定服务时，会重新启动服务。\n\n已验证：和activity有关，不可以跨activity操作。\n\n\n# 绑定 - 解绑 - 解绑 - 解绑\n\n2022-10-24 15:44:37.633 8585-8585/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:44:37.634 8585-8585/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 15:44:37.636 8585-8585/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 15:44:39.276 8585-8585/cc.fastcv.codelab d/baseservice: onunbind: \n2022-10-24 15:44:39.276 8585-8585/cc.fastcv.codelab d/baseservice: ondestroy: \'\n2022-10-24 15:44:40.687 8585-8585/cc.fastcv.codelab e/androidruntime: fatal exception: main\n    java.lang.illegalargumentexception: service not registered: cc.fastcv.codelab.mainactivity$serviceconnection$1@943aadb\n        at android.app.loadedapk.forgetservicedispatcher(loadedapk.java:1991)\n        at android.app.contextimpl.unbindservice(contextimpl.java:2076)\n        at android.content.contextwrapper.unbindservice(contextwrapper.java:889)\n        at android.content.contextwrapper.unbindservice(contextwrapper.java:889)\n        at cc.fastcv.codelab.mainactivity.oncreate$lambda-3(mainactivity.kt:45)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，在解绑之后，再次解绑的话，就会出现 service not registered 的错误，并且应用会奔溃。\n\n\n# 解绑 - 绑定 - 绑定 - 解绑\n\n2022-10-24 15:46:18.706 8835-8835/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:46:18.706 8835-8835/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 15:46:18.709 8835-8835/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 15:46:21.301 8835-8835/cc.fastcv.codelab d/baseservice: onunbind:\n2022-10-24 15:46:21.301 8835-8835/cc.fastcv.codelab d/baseservice: ondestroy:\n2022-10-24 15:46:21.994 8835-8835/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 15:46:21.995 8835-8835/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 15:46:21.997 8835-8835/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 15:46:22.577 8835-8835/cc.fastcv.codelab d/baseservice: onunbind: \n2022-10-24 15:46:22.577 8835-8835/cc.fastcv.codelab d/baseservice: ondestroy:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里需要注意的是，如果绑定的数量与解绑的数量不相等时，是不会回调onunbind和ondestroy的。\n\n\n# startservice与bindservice\n\n在前面分别对startservice和bindservice做了实验之后，我们可以得到：\n\nstartservice：第一次启动会走oncreate，后面调用启动时，只会调用onstartcommand，然后调用stopservice之后就会停止服务。可以重复调用停止服务。\n\nbindservice：第一次绑定会走onbind，后面会直接返回binder对象，然后调用解绑操作之后就会停止服务。无法重复调用解绑操作。\n\n所以，当两者结合起来使用时，生命周期会变的复杂起来，这里我将它分为以下几个特例：\n\n1、service是否启动了，如果没有启动则无论调用哪个都会先走oncreate。如果启动了，这个时候调用start会回调onstartcommand（每次调用都会回调）；调用bind就会调用onbind（多次调用只会回调一次）。\n\n2、如果即启动了又绑定了，则需要即解绑又停止服务才能停止服务，否则不会停止服务。\n\n3、如果有多个地方绑定了，则需要全部解绑了才算完解绑完成。\n\n\n# 数据传递\n\n\n# 单向传递\n\n从前面可以知道 startservice 是个单项的操作，那我们怎么样传递数据到服务中呢？\n\n还记得 onstartcommand 回调吗？我们每次调用 startservice 方法时都会调用它，而这个回调接口有三个参数，其中的 intent 就是我们传递数据的载体。\n\n如：我们传递字符给服务：\n\n2022-10-24 16:00:00.608 9652-9652/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 16:00:00.609 9652-9652/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1\n2022-10-24 16:00:00.609 9652-9652/cc.fastcv.codelab d/baseservice: onstartcommand: command = command1\n2022-10-24 16:00:03.378 9652-9652/cc.fastcv.codelab d/bactivity: oncreate: \n2022-10-24 16:00:04.770 9652-9652/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:2\n2022-10-24 16:00:04.770 9652-9652/cc.fastcv.codelab d/baseservice: onstartcommand: command = command2\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看到，我们分别将command1、command2写入到服务中。\n\n\n# 双向传递\n\n我们在 bindservice 的connect 回调中 获取 binder对象，如：\n\nclass basebinder : binder() {\n\n    companion object {\n        private const val tag = "basebinder"\n    }\n\n    private val callbacks = mutablelistof<callback>()\n\n    fun addcallback(callback: callback) {\n        log.d(tag, "addcallback: 绑定监听者 $callback")\n        if (!callbacks.contains(callback)) {\n            callbacks.add(callback)\n        }\n    }\n\n    fun removecallback(callback: callback) {\n        log.d(tag, "removecallback: 解除监听者 $callback")\n        if (callbacks.contains(callback)) {\n            callbacks.remove(callback)\n        }\n    }\n\n    fun request() {\n        for (callback in callbacks) {\n            callback.oncall("收到请求")\n        }\n    }\n}\n\ninterface callback {\n    fun oncall(msg:string)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n那么，在绑定成功的时候 addcallback 在解绑的时候 removecallback。最后运行结果：\n\n2022-10-24 16:14:10.590 10620-10620/cc.fastcv.codelab d/mainactivity: oncreate: \n2022-10-24 16:14:14.544 10620-10620/cc.fastcv.codelab d/baseservice: oncreate: \n2022-10-24 16:14:14.545 10620-10620/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 16:14:14.547 10620-10620/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 16:14:14.547 10620-10620/cc.fastcv.codelab d/basebinder: addcallback: 绑定监听者 cc.fastcv.codelab.mainactivity@dc6dfb0\n2022-10-24 16:14:18.029 10620-10620/cc.fastcv.codelab d/bactivity: oncreate: \n2022-10-24 16:14:19.459 10620-10620/cc.fastcv.codelab d/bactivity: onserviceconnected: \n2022-10-24 16:14:19.459 10620-10620/cc.fastcv.codelab d/basebinder: addcallback: 绑定监听者 cc.fastcv.codelab.bactivity@ded60a8\n2022-10-24 16:14:23.244 10620-10620/cc.fastcv.codelab d/mainactivity: oncall: 收到请求\n2022-10-24 16:14:23.244 10620-10620/cc.fastcv.codelab d/bactivity: oncall: 收到请求\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# anr问题\n\n在这里需要注意的是，service的回调都是在主线程中的，所以，如果我们在回调中做耗时操作的话，就会产生anr的问题。\n\n2022-10-24 16:17:19.339 10906-10906/cc.fastcv.codelab d/baseservice: oncreate: main\n2022-10-24 16:17:19.339 10906-10906/cc.fastcv.codelab d/baseservice: onstartcommand: flags:0  startid:1  main\n2022-10-24 16:17:23.123 10906-10906/cc.fastcv.codelab d/baseservice: onbind: main\n2022-10-24 16:17:32.945 10906-10906/cc.fastcv.codelab d/baseservice: onunbind: main\n2022-10-24 16:17:32.945 10906-10906/cc.fastcv.codelab d/baseservice: ondestroy: main\n\n\n1\n2\n3\n4\n5\n\n\n所以，如果需要在服务中做耗时操作的话，我们需要在服务的回调之后开启一个子线程做相关耗时操作。这样处理太过繁琐了，所以谷歌推出了intentservice来帮助我们做类似的操作。\n\n\n# intentservice\n\n客户端通过startservice(intent)来启动intentservice; 我们并不需要手动地区控制intentservice,当任务执行完后,intentservice会自动停止; 可以启动intentservice多次,每个耗时操作会以工作队列的方式在intentservice的 onhandleintent回调方法中执行,并且每次只会执行一个工作线程,执行完一，再到二这样。如：\n\nclass baseintentservice : intentservice("intent") {\n\n    companion object {\n        private const val tag = "baseintentservice"\n    }\n\n    override fun oncreate() {\n        super.oncreate()\n        log.d(tag, "oncreate: ")\n    }\n\n    override fun onstartcommand(intent: intent?, flags: int, startid: int): int {\n        log.d(tag, "onstartcommand: ")\n        return super.onstartcommand(intent, flags, startid)\n    }\n\n    override fun onhandleintent(intent: intent?) {\n        val workid = intent?.getstringextra("workid")\n        log.d(tag, "onhandleintent: workid = $workid  threadid = ${thread.currentthread().name}")\n    }\n\n    override fun ondestroy() {\n        super.ondestroy()\n        log.d(tag, "ondestroy: ")\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们多次点击启动服务\n\n            val baseservice = intent(this, baseintentservice::class.java)\n            baseservice.putextra("workid","" + index++ )\n            startservice(baseservice)\n\n\n1\n2\n3\n\n\n结果：\n\n2022-10-24 16:25:20.857 11738-11738/cc.fastcv.codelab d/baseintentservice: oncreate: \n2022-10-24 16:25:20.857 11738-11738/cc.fastcv.codelab d/baseintentservice: onstartcommand: \n2022-10-24 16:25:20.858 11738-11776/cc.fastcv.codelab d/baseintentservice: onhandleintent: workid = 1  threadid = intentservice[intent]\n2022-10-24 16:25:20.859 11738-11738/cc.fastcv.codelab d/baseintentservice: ondestroy: \n2022-10-24 16:25:23.521 11738-11738/cc.fastcv.codelab d/baseintentservice: oncreate: \n2022-10-24 16:25:23.522 11738-11738/cc.fastcv.codelab d/baseintentservice: onstartcommand: \n2022-10-24 16:25:23.522 11738-11785/cc.fastcv.codelab d/baseintentservice: onhandleintent: workid = 2  threadid = intentservice[intent]\n2022-10-24 16:25:23.523 11738-11738/cc.fastcv.codelab d/baseintentservice: ondestroy: \n2022-10-24 16:25:23.729 11738-11738/cc.fastcv.codelab d/baseintentservice: oncreate: \n2022-10-24 16:25:23.729 11738-11738/cc.fastcv.codelab d/baseintentservice: onstartcommand: \n2022-10-24 16:25:23.730 11738-11786/cc.fastcv.codelab d/baseintentservice: onhandleintent: workid = 3  threadid = intentservice[intent]\n2022-10-24 16:25:23.731 11738-11738/cc.fastcv.codelab d/baseintentservice: ondestroy: \n2022-10-24 16:25:23.911 11738-11738/cc.fastcv.codelab d/baseintentservice: oncreate: \n2022-10-24 16:25:23.911 11738-11738/cc.fastcv.codelab d/baseintentservice: onstartcommand: \n2022-10-24 16:25:23.912 11738-11787/cc.fastcv.codelab d/baseintentservice: onhandleintent: workid = 4  threadid = intentservice[intent]\n2022-10-24 16:25:23.913 11738-11738/cc.fastcv.codelab d/baseintentservice: ondestroy: \n2022-10-24 16:25:24.085 11738-11738/cc.fastcv.codelab d/baseintentservice: oncreate: \n2022-10-24 16:25:24.086 11738-11738/cc.fastcv.codelab d/baseintentservice: onstartcommand: \n2022-10-24 16:25:24.086 11738-11788/cc.fastcv.codelab d/baseintentservice: onhandleintent: workid = 5  threadid = intentservice[intent]\n2022-10-24 16:25:24.087 11738-11738/cc.fastcv.codelab d/baseintentservice: ondestroy: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看到，最终的处理回调都是在子线程中进行的。我们来看看源码（比较简单的源码）\n\n\n# 源码解析\n\n首先看下这个类组成\n\npublic abstract class intentservice extends service {}\n\n\n1\n\n\n可以看到，这是个抽象类，集成自service。其中需要我们重写的 onhandleintent 方法是个抽象方法。\n\n    protected abstract void onhandleintent(@nullable intent intent);\n\n\n1\n\n\n那它在哪个地方回调的呢？可以看到，是在一个内部类servicehandler中回调的。\n\n    private final class servicehandler extends handler {\n        public servicehandler(looper looper) {\n            super(looper);\n        }\n\n        @override\n        public void handlemessage(message msg) {\n            onhandleintent((intent)msg.obj);\n            stopself(msg.arg1);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n而servicehandler又是handler的子类，用来接收消息，并且从servicehandler的构造方法可以看出，这里使用的 looper是从外部传入的。我们看看 servicehandler 是在哪里被初始化的。\n\n可以轻易的找到\n\n    @override\n    public void oncreate() {\n        super.oncreate();\n        handlerthread thread = new handlerthread("intentservice[" + mname + "]");\n        thread.start();\n\n        mservicelooper = thread.getlooper();\n        mservicehandler = new servicehandler(mservicelooper);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n是在service的oncreate回调中初始化的，而looper是在本地启动了一个 handlerthread 之后获取的 looper。那子线程的问题应该就可以解释的通了。\n\n那我们的消息是怎么发送过来的呢？\n\n从之前的学习可以知道，要接收消息的话，只能从 onstartcommand 回调中去接收，那我们来看看 onstartcommand 回调接口里面做了什么？\n\n    @override\n    public int onstartcommand(@nullable intent intent, int flags, int startid) {\n        onstart(intent, startid);\n        return mredelivery ? start_redeliver_intent : start_not_sticky;\n    }\n    \n    @override\n    public void onstart(@nullable intent intent, int startid) {\n        message msg = mservicehandler.obtainmessage();\n        msg.arg1 = startid;\n        msg.obj = intent;\n        mservicehandler.sendmessage(msg);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n哦~，原来是在onstartcommand接收的消息，然后封装成 message ，再通过 servicehandler 回调出来。\n\n虽然这个类很好用，但是，在官方文档上，android 8.0之后 这个类被废弃掉了，推荐使用 jobintentservice 或者 workmanager\n\n\n# jobscheduler\n\nandroid从5.0开始，增加支持一种特殊的机制，即任务调度jobscheduler，为啥要先讲这个呢？\n\n因为，我们后面要提到的 jobservice 和 jobintentservice 都是基于它来工作的，包括说后面推出的workmanager也和它有很大的渊源，所以需要先了解一下这个工具先。\n\napp除了通过屏幕向用户展示可交互的界面元素之外，还经常需要在后台做些背地里做的事情，比如说精密计算、文件下载、统计分析、数据导入、状态监控等等，这些用户看不到的事一般放在service中处理。\n\n然而有时候我们希望在特定情况下再启动事务，比如说延迟若干时间之后，或者等手机空闲了再运行，这样一方面不会在系统资源紧张之时喧宾夺主，另一方面也起到削峰填谷提高系统效率的作用。对于这些额外的条件要求，service并不能直接支持，往往需要加入其他手段，才能较好地满足相关的运行条件，比如：\n\n * 对于延迟时间执行，通常考虑利用系统的闹钟管理器alarmmanager进行定时管理\n * 对于是否联网、是否充电、是否空闲，一般要监听系统的相应广播，常见的系统广播说明如下：\n   * 1、网络状态变化需要监听系统广播android.net.conn.connectivity_change；\n   * 2、设备是否充电需要监听系统广播intent.action_power_connected也就是android.intent.action.action_power_connected；\n   * 3、设备是否空闲需要监听系统广播intent.action_screen_off也就是android.intent.action.screen_off；\n\n可是要想给service补充以上条件，势必加大了程序逻辑的复杂度，一会儿注册这个事件，一会儿注册那个事件，工程代码将变得不易维护。\n\n有鉴于此，android从5.0开始，增加支持一种特殊的机制，即任务调度jobscheduler，该工具集成了常见的几种运行条件，开发者只需添加少数几行代码，即可完成原来要多种组件配合的工作。\n\n任务调度机制由三个工具组成，首先是jobinfo，它指定了一个任务的概要信息，比如何时启动，启动时需要满足什么条件等等；其次是jobscheduler，它是系统提供的任务调度服务，它的实例从系统服务context.job_scheduler_service中获得；最后是jobservice，它描述了该任务内部的具体业务逻辑，它的运行时刻由jobscheduler根据jobinfo指定的条件而计算决定。下面分别说明这三个工具的编码过程：\n\n\n# jobinfo\n\n任务信息的运行条件由jobinfo.builder来构造，下面是builder的函数说明：\n\n * 构造函数：指定该任务来源与目的，与intent类似，第二个参数指定了开发者自定义的jobservice。\n\n * setrequirednetworktype：设置需要的网络条件，有三个取值：\n   \n   * jobinfo.network_type_none（无网络时执行，默认）\n   * jobinfo.network_type_any（有网络时执行）\n   * jobinfo.network_type_unmetered（网络无需付费时执行）\n\n * setpersisted：重启后是否还要继续执行，此时需要声明权限receive_boot_completed，否则会报错“java.lang.illegalargumentexception: error: requested job be persisted without holding receive_boot_completed permission.”而且receive_boot_completed需要在安装的时候就要声明，如果一开始没声明，而在升级时才声明，那么依然会报权限不足的错误。\n\n * setrequirescharging：是否在充电时执行\n\n * setrequiresdeviceidle：是否在空闲时执行\n\n * setperiodic：设置时间间隔，单位毫秒。该方法不能和setminimumlatency、setoverridedeadline这两个同时调用，否则会报错“java.lang.illegalargumentexception: can\'t call setminimumlatency() on a periodic job”，或者报错“java.lang.illegalargumentexception: can\'t call setoverridedeadline() on a periodic job”。\n\n * setminimumlatency：设置至少延迟多久后执行，单位毫秒。\n\n * setoverridedeadline：设置最多延迟多久后执行，单位毫秒。\n\n * build：完成条件设置，返回构建好的jobinfo对象。\n\n如：\n\n        val jobinfo = jobinfo.builder(10001, componentname(this, myjobservice::class.java))\n            .setrequirednetworktype(jobinfo.network_type_none)\n            .setpersisted(false)\n            .setrequirescharging(false)\n            .setrequiresdeviceidle(true)\n            .setperiodic(5 * 1000l)\n            .build()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# jobscheduler\n\n任务调度的实例从系统服务context.job_scheduler_service中获得，代码举例如下：\n\n\tval js = getsystemservice(context.job_scheduler_service) as jobscheduler\t\n\n\n1\n\n\n获得任务调度实例后，即可进行任务调度操作，下面是任务调度的相关方法：\n\n * schedule：把指定的jobinfo对象放入调度队列，并在条件满足时触发该对象中定义的jobservice。\n * cancel：取消指定编号的任务。\n * cancelall：取消所有任务。\n * getallpendingjobs：获取所有挂起（即尚未执行）的任务。\n\n        val js = getsystemservice(context.job_scheduler_service) as jobscheduler\n        js.schedule(jobinfo)\n        js.cancel(10001)\n        js.cancelall()\n        for (allpendingjob in js.allpendingjobs) {\n            log.d(tag, "test: allpendingjob.id.")\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# jobservice\n\n任务服务是一种特殊的service，它描述了该任务内部的具体业务逻辑，需要开发者重写的方法如下： onstartjob：在任务开始执行时触发。返回false表示执行完毕，返回true表示需要开发者自己调用jobfinished方法通知系统已执行完成。 onstopjob：在任务停止执行时触发。 jobservice内部另外实现了两个方法，说明如下\n\n1、onbind方法，源码如下所示\n\n    public final ibinder onbind(intent intent) {\n        return mbinder.asbinder();\n    }\n\n\n1\n2\n3\n\n\njobservice实现了onbind方法，表示任务调度在工作的时候，jobservice是通过绑定方式启动的。\n\n2、jobfinished方法，源码如下所示\n\n    public final void jobfinished(jobparameters params, boolean needsreschedule) {\n        ensurehandler();\n        message m = message.obtain(mhandler, msg_job_finished, params);\n        m.arg2 = needsreschedule ? 1 : 0;\n        m.sendtotarget();\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n因为jobservice由系统触发，不是在app的主线程中，所以这里通过message机制与主线程进行通信。\n\n示例：\n\nclass myjobservice : jobservice() {\n\n    companion object {\n        private const val tag = "myjobservice"\n    }\n\n    private val mhandler: handler = object : handler(looper.getmainlooper()) {\n        override fun handlemessage(msg: message) {\n            try {\n                thread.sleep(5000)\n            } catch (e: interruptedexception) {\n                e.printstacktrace()\n            }\n            val param = msg.obj as jobparameters\n            jobfinished(param, true)\n            log.d(tag, "jobfinished")\n        }\n    }\n\n\n    override fun onstartjob(params: jobparameters?): boolean {\n        log.d(tag, "onstartjob")\n        val message = message.obtain()\n        message.obj = params\n        mhandler.sendmessage(message)\n        //返回false表示执行完毕，返回true表示需要开发者自己调用jobfinished方法通知系统已执行完成\n        return true\n    }\n\n    override fun onstopjob(params: jobparameters?): boolean {\n        //停止，不是结束。jobfinished不会直接触发onstopjob\n        //必须在“onstartjob之后，jobfinished之前”取消任务，才会在jobfinished之后触发onstopjob\n        log.d(tag, "onstopjob")\n        mhandler.removemessages(0)\n        return true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n以上代码需要注意的是： 1、因为系统服务是通过绑定方式启动jobservice，所以此时onstartcommand方法永远不会执行； 2、onstopjob顾名思义是在任务停止时触发，但是直接调用jobfinished方法并不能触发onstopjob。原因是onstopjob的触发是有条件的，首先这里的停止指的是取消任务而不是完成任务；其次必须在“onstartjob之后，jobfinished之前”取消任务，才会在jobfinished之后触发onstopjob。 另外注意在androidmanifest.xml中补充服务声明：\n\n        <service\n            android:name=".service.myjobservice"\n            android:permission="android.permission.bind_job_service" />\n\n\n1\n2\n3\n\n\n\n# alarmmanager\n\n\n# timer\n\njava中的定时器机制有现成的方案，就是timer+timertask。其中timertask用来描述时刻到达后的事务处理，而timer用来调度定时任务，如何时启动、间隔多久再次运行等等。\n\ntimer的调度方法是schedule，主要有三个参数。第一个参数表示用来调度的定时任务，第二个参数表示延迟多久首次启动任务，第三个参数表示间隔多久再次启动任务。 public void schedule(timertask task, long delay, long period)\n\n定时任务得自己写个继承自timertask的新类，并重写run方法填入具体的事务处理代码。调用timer的schedule方法，定时任务便会按照调度设置按时启动；timertask不能直接设置运行的次数上限，一旦启动就会持续定时运行，除非对象销毁或者调用了timertask的cancel方法。调用cancel方法停止定时任务后，若想重启该定时任务，只能重新声明timertask对象，并且重新调用schedule方法。\n\ntimer+timertask的实质是利用开启thread来触发定时任务，所以timertask实际上运行于非ui线程，也就无法直接操作ui。若想在timertask中修改ui控件，得通过handler发送消息来间接实现。\n\n示例：\n\n    //创建任务\n    private val timertask = object : timertask() {\n        override fun run() {\n            log.d(tag, "run: 执行任务 ${thread.currentthread().name}")\n        }\n    }\n    \n    //开始任务\n    val timer = timer()\n    timer.schedule(timertask,3000,3000)\n    \n    //取消任务\n    timertask.cancel()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# countdowntimer\n\ncountdowntimer是android提供的倒计时器，日常生活中时有见到倒计时的场景，比如说火箭发射倒计时。\n\n通常我们要自定义一个countdowntimer的派生类，并重写如下的三个方法：\n\n * 构造函数 : 第一个参数是总的计时长度，第二个参数是每次的计时间隔（好像时钟的滴答）。\n * ontick : 每次计时触发的事件。\n * onfinish : 计时结束事件。\n\n要想启动countdowntimer计时，调用它的start方法即可，停止计时则调用cancel方法。另外倒计时器触发的ontick和onfinish都运行于非ui线程，所以与timer一样，也得借助于handler机制才能操作ui元素。\n\n示例：\n\n    //创建任务\n    private val countdowntimer = object : countdowntimer(60000, 1000) {\n        override fun ontick(millisuntilfinished: long) {\n            log.d(tag, "ontick: $millisuntilfinished   ${thread.currentthread().name}")\n        }\n\n        override fun onfinish() {\n            log.d(tag, "onfinish:    ${thread.currentthread().name}")\n        }\n    }\n    \n    //开始任务\n    countdowntimer.start()\n    \n    //取消任务\n    countdowntimer.cancel()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# alarmmanager\n\nalarmmanager是android提供的一个全局定时器，其使用范围要大于timer方式。\n\n因为timer方式采用thread通信，所以只适用于线程间通信，并且生命周期也有限。如果在activity中定义timer，那么activity页面销毁后，定时器也失效了；如果在application中定义timer，那么app退出后，定时器也要失效。相比之下，alarmmanager利用系统的提醒服务定时发送广播，所以不但适用于线程间通信，而且也适用于进程间通信。另外，由于是系统服务发送广播，因此只要再次打开app，就会自动收到广播发来的定时任务。\n\nalarmmanager常用的启动方法有两个：\n\n * set : 该方法用于设置一次性定时器。第一个参数表示定时器类型，第二个参数表示任务执行时间，第三个参数表示定时任务。\n * setrepeating : 该方法用于设置重复定时器。第一个参数表示定时器类型，第二个参数表示任务首次执行时间，第三个参数表示再次执行的间隔时间，第四个参数表示定时任务。其中定时器类型主要取值有： rtc_wakeup : 表示定时器即使在睡眠状态下也会启用，此时定时器使用系统时间 rtc : 表示定时器在睡眠状态下不可用，此时定时器使用系统时间 elapsed_realtime_wakeup : 表示定时器即使在睡眠状态下也会启用，此时定时器使用相对时间（相对于系统启动开始） elapsed_realtime : 表示定时器在睡眠状态下不可用，此时定时器使用相对时间\n\n因为alarmmanager使用的是系统服务来发送广播，所以在注册广播接收器时需要注意以下几点： 1、要在androidmanifest.xml中定义receiver 2、代码中注册接收器必须使用context.registerreceiver，不能使用localbroadcastmanager来注册\n\nalarmmanager启动方法中的定时任务使用了pendingintent类，pendingintent顾名思义就是一个延迟处理的通信工具。pendingintent的实例可通过下列三种方法得到：\n\n * getactivity : 获取用于启动页面的实例\n * getservice : 获取用于启动服务的实例\n * getbroadcast : 获取用于发送广播的实例\n\n三个方法的参数是一样的，第一个参数表示context，第二个参数表示请求代码用于标识本次请求的唯一性，第三个参数表示intent实例（可捆绑具体参数信息bundle），第四个参数表示pendingintent的启动标志，具体取值说明如下：\n\n * flag_one_shot : 此时启动的pendingintent只能使用一次。\n * flag_no_create : 如果不存在描述的pendingintent，则不会创建新任务。\n * flag_cancel_current : 如果已存在描述的pendingintent，则先取消该任务再创建新任务。\n * flag_update_current : 一般用这个标志。如果已存在描述的pendingintent，则更新而不是取消该任务。\n\n示例：\n\n        //创建任务\n        val filter = intentfilter("cc.fastcv.codelab.alarmreceiver")\n        registerreceiver(alarmreceiver, filter)\n\n        val intent = intent("cc.fastcv.codelab.alarmreceiver")\n        val pintent = if (build.version.sdk_int >= build.version_codes.s) {\n            pendingintent.getbroadcast(\n                this, r.string.app_name, intent, pendingintent.flag_update_current or  pendingintent.flag_immutable)\n        } else {\n            pendingintent.getbroadcast(\n                this, r.string.app_name, intent, pendingintent.flag_update_current)\n        }\n\n        log.d(tag, "oncreate: 发送警告任务")\n        val alarmmgr = getsystemservice(alarm_service) as alarmmanager\n        alarmmgr.setrepeating(\n            alarmmanager.rtc_wakeup, system.currenttimemillis(), 3000, pintent);\n            \n        //设置接收器\n        private val alarmreceiver = object  : broadcastreceiver() {\n            override fun onreceive(context: context?, intent: intent?) {\n                log.d(tag, "onreceive: 收到警报消息")\n            }\n        }\n        val filter = intentfilter("cc.fastcv.codelab.alarmreceiver")\n        registerreceiver(alarmreceiver, filter)\n        \n        \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# jobintentservice\n\njobintentservice实质为service其继承关系如下所示。\n\n java.lang.object\n    ↳   android.content.context\n       ↳    android.content.contextwrapper\n           ↳    android.app.service\n               ↳    android.support.v4.app.jobintentservice\n\n\n1\n2\n3\n4\n5\n\n\n用于处理被加入到job或service任务的一个辅助工具。\n\n * 8.0以下被当作普通的intent使用startserivce()启动service来执行。\n * 8.0以上任务被作为job用jobscheduler.enqueue()方法来分发。\n\n说到jobscheduler，应该不陌生了，框架提供的用来app调度任务的接口，根据app要求构建jobinfo，系统会在适当的时间调用jobinfo指定的jobservice来执行你的任务。\n\n所以在android8.0及以上jobintentservice和jobservice做的事情是相同的，都是等着jobscheduler分配任务来执行。\n\n不同点在于，jobservice使用的handler使用的是主线程的looper，因此需要在onstartjob（）中手动创建asynctask去执行耗时任务，而jobintentservice则帮我们处理这一过程，使用它只需要写需要做的任务逻辑即可，不用关心卡住主线程的问题。另外，向jobscheduler传递任务操作也更简单了，不需要在指定jobinfo中的参数，直接enqueue(context,intent)就可以。\n\n这有点像service和intentservice的关系。\n\n示例：\n\n    intent workintent = new intent();\n    workintent.putextra("work","work num:"+num);\n    myjobintentservice.enqueuework(getapplicationcontext(),workintent);\n\n\n1\n2\n3\n\n\npublic class myjobintentservice extends jobintentservice {\n\n    /**\n     * 这个service 唯一的id\n     */\n    static final int job_id = 10111;\n\n    /**\n     * convenience method for enqueuing work in to this service.\n     */\n    static void enqueuework(context context, intent work) {\n        enqueuework(context, myjobintentservice.class, job_id, work);\n    }\n\n    @override\n    protected void onhandlework( intent intent) {\n        log.d("houson", "onhandlework: "+intent.getstringextra("work").tostring());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意manifest！\n\n<uses-permission android:name="android.permission.wake_lock"></uses-permission>\n<service android:name=".myjobintentservice"></service>\n\n\n1\n2\n\n\n\n# workmanager\n\n关于workmanager 的介绍 官网上是这么说的: 使用 workmanager api 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。 重点是后面的几个字,运行可延迟的异步任务, 在退出或者重启的时候,我们在之前要实现这种任务可能需要 broadcastreceiver 或者 alarmmanager,现在的话可以使用workmanager,这个框架最高兼容至android api 14。\n\n * android 23以上是采用jobscheduler\n * android 14-22 采用的是broadcastreceiver 和 alarmmanager\n\n要使用的话，需要添加依赖：\n\n       def work_version = "2.3.1"\n\n        // (java only)\n        implementation "androidx.work:work-runtime:$work_version"//java 语言选这个\n\n        // kotlin + coroutines\n        implementation "androidx.work:work-runtime-ktx:$work_version"//kotlin 选这个\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在使用之前，我们介绍下它的几个成员：\n\n\n# worker\n\n任务的执行者，是一个抽象类，用于指定需要执行的具体任务，需要实现dowork() 这一个方法，它是执行在一个单独的后台线程里的。所有需要在后台执行的任务都在这个方法里完成。 dowork()函数的返回值：\n\n * worker.result.success:任务执行成功。\n * worker.result.failure:任务执行失败。\n * worker.result.retry:任务需要重新执行，如果出现这个返回结果，就需要与workrequest.builder中的setbackoffcriteria()函数一起使用。\n\n如：\n\nclass uploadpicwork(\n    private val context: context,\n    private val workerparameters: workerparameters\n) :\n    worker(context, workerparameters) {\n    override fun dowork(): result {\n\n       val params = inputdata.getstring("params_tag")//获取传递的参数\n\n        try {\n            uploadpic()//上传图片\n        } catch (e: exception) {\n            return result.failure(data())//执行失败了\n        }\n\n        return result.success()\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# workrequest\n\n代表一个单独的任务，对worker任务进行包装，一个workrequest对应一个worker类。可以通过workrequest来给worker类添加约束细节，比如设备是否空闲，设备电池是否不应低于临界阈值，指定设备在充电时是否启动任务等等。workrequest是一个抽象类，具体要使用两个子类：\n\n * onetimeworkrequest(任务只执行一遍)\n * periodicworkrequest(任务周期性的执行)。\n\n如：\n\nval uploadpicwork =\n                onetimeworkrequestbuilder<uploadpicwork>()\n                    .setinputdata(workdataof("params_tag" to "params"))//传递参数\n                    .setconstraints(triggercontentmaxdelay)//设置约束条件\n                    .addtag("tag")//设置tag\n                    .build()\n\n\n1\n2\n3\n4\n5\n6\n\n\n# workrequest加标签\n\n可以通过addtag给workrequest加入标签，比如：\n\n periodicworkrequest request = new periodicworkrequest.builder(myworker.class, 15, timeunit.seconds)\n                .setinputdata(data)\n                .addtag("a")\n                .build();\nperiodicworkrequest request2 = new periodicworkrequest.builder(myworker.class, 15, timeunit.seconds)\n                .setinputdata(data)\n                .addtag("a")\n                .build();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过addtag()，将workrequest成为了一个组：a组。以后可以直接控制整个组就行了，组内的每个成员都会受到影响。比如通过workmanager的cancelallworkbytag(string tag):取消一组带有相同标签的任务。\n\n# 获取 workinfo\n\n * 听过 id 获取,可以听过 workmanager.getworkinfobyid(uuid) 或 workmanager.getworkinfobyidlivedata(uuid) 来通过 workrequest id 来获取 workinfo。\n\n workmanager.getinstance(this)\n                .getworkinfobyidlivedata(uploadpicwork.id)// 通过id 获取\n                .observe(this, observer { //it:workinfo\n                    it?.apply {\n                        when (this.state) {\n                            workinfo.state.blocked -> println("blocked")\n                            workinfo.state.cancelled -> println("cancelled")\n                            workinfo.state.running -> println("running")\n                            workinfo.state.enqueued -> println("enqueued")\n                            workinfo.state.failed -> println("failed")\n                            workinfo.state.succeeded -> println("succeeded")\n                            else -> println("else status ${this.state}")\n                        }\n                    }\n\n                })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 通过 tag 获取,可以利用 workmanager.getworkinfosbytag(string) 或 workmanager.getworkinfosbytaglivedata(string) 来通过 workrequest 的 workinfo 对象。\n\n//要通过 tag 获取,则需要先设置 tag\nval uploadpicwork =\n                onetimeworkrequestbuilder<uploadpicwork>()\n                    .setinputdata(workdataof("params_tag" to "params"))//传递参数\n                    .setconstraints(triggercontentmaxdelay)//设置约束条件\n                    .addtag("tag")//设置tag\n                    .build()\n\n//获取 workinfo\n\nworkmanager.getinstance(this)\n                .getworkinfosbytaglivedata("tag")\n                .observe(this, observer {it:list<workinfo>//此处返回的是一个集合,作为示例代码,默认只取 0 index\n                    it?.apply {\n                        when (this[0].state) {\n                            workinfo.state.blocked -> println("blocked")\n                            workinfo.state.cancelled -> println("cancelled")\n                            workinfo.state.running -> println("running")\n                            workinfo.state.enqueued -> println("enqueued")\n                            workinfo.state.failed -> println("failed")\n                            workinfo.state.succeeded -> println("succeeded")\n                            else -> println("else status ${this[0]}")\n                        }\n                    }\n\n                })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 对于 唯一工作名称 的一个 worker ,可以利用 workmanager.getworkinfosforuniquework(string) 或 workmanager.getworkinfosforuniqueworklivedata(string) 检索所有匹配的 workrequest 的 workinfo 对象。此处估计不太好理解,唯一工作是一个概念性非常强的术语，可确保一次只有一个具有特定名称的工作链。与 id 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 workmanager 自动生成。与标记不同，唯一名称仅与“一个”工作链关联。您可以通过调用 workmanager.enqueueuniquework(string, existingworkpolicy, onetimeworkrequest) 或 workmanager.enqueueuniqueperiodicwork(string, existingperiodicworkpolicy, periodicworkrequest) 创建唯一工作序列。\n\nworkmanager.getinstance(this)\n                .getworkinfosforuniqueworklivedata("uploadpicwork")//唯一工作名称 \n                .observe(this, observer {it:list<workinfo> //此处返回的是一个集合,作为示例代码,默认只取 0\n\n                    it?.apply {\n                        when (this[0].state) {\n                            workinfo.state.blocked -> println("blocked")\n                            workinfo.state.cancelled -> println("cancelled")\n                            workinfo.state.running -> println("running")\n                            workinfo.state.enqueued -> println("enqueued")\n                            workinfo.state.failed -> println("failed")\n                            workinfo.state.succeeded -> println("succeeded")\n                            else -> println("else status ${this[0]}")\n                        }\n                    }\n\n                })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 注意如采用这种方式获取 workinfo ,在执行 worker 的时候与之前不一样,需要采用 workmanager.enqueueuniquework(string, existingworkpolicy, onetimeworkrequest) 或 workmanager.enqueueuniqueperiodicwork(string, existingperiodicworkpolicy, periodicworkrequest) 来执行\n\n//全部代码如下\n\n\n//创建约束条件\nval triggercontentmaxdelay =\n                constraints.builder().setrequirednetworktype(networktype.connected)\n//                    .setrequiresdeviceidle(false)\n                    .setrequiresbatterynotlow(true)\n                    .setrequiresstoragenotlow(true)\n                    .setrequirescharging(true)\n                    .settriggercontentmaxdelay(1000 * 1, timeunit.milliseconds)\n                    .build()\n\n// 创建workrequest\n            val uploadpicwork =\n                onetimeworkrequestbuilder<uploadpicwork>()\n                    .setinputdata(workdataof("params_tag" to "params"))\n                    .setconstraints(triggercontentmaxdelay)\n                    .build()\n\n    //注意!!!,此处区别与之前的 workmanager.getinstance(this).enqueue(uploadpicwork)\n    \n    // "uploadpicwork" 需要与下面代码 getworkinfosforuniqueworklivedata("uploadpicwork") 中字符串对应\n    // existingworkpolicy.append 一个枚举值,worker 执行的策略,想要了解的同学,可以看下面的链接\n    workmanager.getinstance(this).enqueueuniquework("uploadpicwork",existingworkpolicy.append,uploadpicwork)\n\n            workmanager.getinstance(this)\n                .getworkinfosforuniqueworklivedata("uploadpicwork")\n                .observe(this, observer {\n\n                    it?.apply {\n                        when (this[0].state) {\n                            workinfo.state.blocked -> println("blocked")\n                            workinfo.state.cancelled -> println("cancelled")\n                            workinfo.state.running -> println("running")\n                            workinfo.state.enqueued -> println("enqueued")\n                            workinfo.state.failed -> println("failed")\n                            workinfo.state.succeeded -> println("succeeded")\n                            else -> println("else status ${this[0]}")\n                        }\n                    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# workmanager\n\n主要管理任务请求和任务队列，将workrequest加入任务队列。 通过workmanager来调度任务，以分散系统资源的负载。\n\n\n# workstatus\n\n当 workmanager 把任务加入队列后，会为每个workrequest对象提供一个 livedata， livedata 持有 workstatus，包含有任务的状态和任务的信息。\n\npublic enum state {\n\n    enqueued,\n\n    running,\n\n    succeeded,\n\n    failed,\n\n    blocked,\n\n    cancelled;\n\n    public boolean isfinished() {\n        return (this == succeeded || this == failed || this == cancelled);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 基本用法\n\n基本用法分为3步：\n\n 1. 定义后台任务，并实现相关逻辑\n 2. 配置该后台任务的运行条件和约束条件\n 3. 构建后台任务请求\n\n定义后台任务，并实现相关逻辑 定义自己的worker类继承自worker类并重写dowork方法\n\ndowork方法指定worker类如何执行操作，但是不能出现任何关于任务何时运行的信息\n\n\nclass myworker(context: context, params: workerparameters) : worker(context, params){\n    override fun dowork() : result{\n        //执行操作\n        return result.success()\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n配置该后台任务的运行条件和约束条件 在mainactivity中根据myworker类创建onetimeworkrequest对象\n\nval myconstraints = constraints.builder().build()\nval myrequest = onetimeworkrequest.builder(myworker::class.java)\n                                  .setconstraints(mycontraints)\n                                  .build()\n\n\n1\n2\n3\n4\n\n\nonetimeworkrequest.builder用于构建单次运行的后台任务请求\n\nperiodicworkrequest.builder用于构建周期运行的后台任务请求，且运行间隔不能短于15 mins\n\n在创建constraints和创建workrequest时可以配置各种各样的运行条件和约束条件\n\n构建后台任务请求 在mainactivity中将该后台任务请求传入workmanager的enqueue方法。\n\nworkmanager.getinstance(this).enqueue(myrequest)\n\n\n1\n\n\n检查任务状态方法：\n\n workmanager.getinstance(this).getworkinfobyidlivedata(myrequest.id)\n                              .observe(this){ workinfo ->\n \tif (workinfo.state == workinfo.state.succeeded){\n                //利用workinfo对结果进行判断\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n取消任务方法：\n\nworkmanager.getinstance(this).cancelbyworkid(myrequest.id)\n\n\n1\n\n\n\n# 含参worker类\n\n使用键值对和data对象进行参数的输入和结果的返回。\n\n在主函数中通过观察任务的workstatus获取输出\n\ntestworker类\n\nclass testworker(context: context, params: workerparameters) : worker(context, params) {\n    companion object{\n        const val key_int_arg = "int"\n        const val key_str_arg = "str"\n        const val key_list_arg = "list"\n        const val key_class_arg = "class"\n        const val key_result = "result"\n    }\n    @suppresslint("restrictedapi")\n    override fun dowork(): result {\n    //获取参数\n    val int = inputdata.getint(key_int_arg, 0)\n    println("int:$int.tostring()")\n    val str = inputdata.getstring(key_str_arg)\n    /**\n     * 仅传递基础数据类型和其构成的数组\n     * 对于类和类组成的数组，需要使用gson转换成json字符串\n     * gson依赖：implementation \'com.google.code.gson:gson:2.8.6\'\n     */\n    val list: arraylist<testclass> = gson().fromjson(\n        inputdata.getstring(key_list_arg),\n        object : typetoken<arraylist<testclass>>() {}.type\n    )\n    val cls: testclass = gson().fromjson(\n        inputdata.getstring(key_class_arg),\n        object : typetoken<testclass>() {}.type\n    )\n\n    //对参数进行操作\n    println("testworker:")\n    println("int:$int.tostring()")\n    println("str:$str")\n    for (item in list){\n        println("list:${item.text}")\n    }\n    println("class:${cls.text}")\n\n    //返回值\n    val liststring = gson().tojson(list)\n    val result = data.builder().putstring(key_result, liststring).build()\n    return result.success(result)\n}\n}\n\n\n主函数\n\nclass mainactivity : appcompatactivity() {\n    @suppresslint("enqueuework")\n    override fun oncreate(savedinstancestate: bundle?) {\n        super.oncreate(savedinstancestate)\n        setcontentview(r.layout.activity_main)\n        //非基本类型参数转换成string\n        val cls = testclass("testclass")\n        val clsstring = gson().tojson(cls)\n        val list = arraylist<testclass>()\n        list.add(testclass("testclass1"))\n        list.add(testclass("testclass2"))\n        list.add(testclass("testclass3"))\n        val liststring = gson().tojson(list)\n        //创建参数\n        val mydata = data.builder().putint(testworker.key_int_arg, 999)\n                                   .putstring(testworker.key_str_arg, "string")\n                                   .putstring(testworker.key_class_arg, clsstring)\n                                   .putstring(testworker.key_list_arg, liststring)\n                                   .build()\n        //构建后台\n        val work = onetimeworkrequest.builder(testworker::class.java)\n                                     .setinputdata(mydata)\n                                     .build()\n        workmanager.getinstance(this).enqueue(work)\n        //获得返回值\n        workmanager.getinstance(this).getworkinfobyidlivedata(work.id)\n                                     .observe(this){workinfo ->\n            val str = workinfo.outputdata.getstring(testworker.key_result)\n            if (str != null){\n                val result: arraylist<testclass> = gson().fromjson(str, object : typetoken<arraylist<testclass>>() {}.type)\n                for (item in result){\n                    println("result:${item.text}")\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n链式任务 workmanager允许我们创建和排队多个任务的工作序列，以及它们按照什么顺序运行。\n\n任何一个任务返回work.workresult.failure，整个序列结束\n\nworkmanager.getinstance(this).beginwith(worka)\n                             .then(workb)\n                             .then(workc)\n                             .enqueue()\n\n\n1\n2\n3\n4\n\n\n允许多个对象传递给begin()和then()\n\nworkmanager并行运行同一次方法传进的任务\n\nworkmanager.getinstance(this).beginwith(listof(workera1, workera2, workera3))\n                             .then(listof(workerb1, workerb2))\n                             .then(workerc)\n                             .enqueue()\n\n\n1\n2\n3\n4\n\n\n允许使用workcontinuation.combine方法连接多个链\n\nworkmanager根据连接链的顺序依次运行。\n\n链内任务按顺序执行\n\n链间任务可能重叠导致任务顺序的改变。\n\nval chain1 = workmanager.getinstance(this)\n                         .beginwith(workera1)\n                         .then(workerb1)\nval chain2 = workmanager.getinstance(this)\n                        .beginwith(workera2)\n                        .then(workerb2)\nworkcontinuation.combine(listof(chain1, chain2))\n                .then(workerc)\n                .enqueue()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ipc\n\n为啥要在这里突然提起ipc呢？ 因为服务在我们日常的开发中，它还有一个重要的使用场景：作为一个子进程！！！，既然有多个进程，肯定会涉及到进程间通信的问题。那 进程间通信 就是 ipc 了\n\nipc (inter processcommunication) 就是指的是不同进程之间的数据交换。也被叫做进程间通信。那么，在安卓中，我们怎么去测试多进程的内容。这个就首先涉及到了安卓应用开启多进程的方式。我们只需要在四大组件的xml属性中加上\n\nandroid:precess = "xxx"\n\n\n1\n\n\n就可以了。\n\n既然分了多个进程，肯定会出现数据不同步的问题，大佬们总结了一下，有一下几个：\n\n * 静态成员和单例完全失效\n * 线程同步机制完全失效\n * sharedpreferences的可靠性下降\n * apllication会多次创建\n\n这个问题总的来说，就是因为不在同一个进程，没有共享内存，那么生成的字节码相互之间访问不了，地址都不同，肯定是会出问题的。这就涉及到了跨进程通信的使用了。\n\n这里，我们就在服务里面使用\n\nandroid:precess = "xxx"\n\n\n1\n\n\n属性将其变为子进程。再看看之前的绑定交换数据的操作能不能成功。\n\nemmmmm , 一运行就出问题了\n\n    java.lang.classcastexception: android.os.binderproxy cannot be cast to cc.fastcv.codelab.services.basebinder\n\n\n1\n\n\n它告诉我无法强转？ 我就是返回的 basebinder 对象呀，为啥无法强转呢？\n\n因为我们返回的是这个对象的引用，但是在不同的进程里面，都不在同一块内存了，引用根本无法访问，更别说强转了。那该怎么办呢？\n\n无法访问对象引用，那只能将数据完完整整的传递过去了。常见的ipc方式有：\n\n\n# 跨进程通信的方式\n\n\n# 广播\n\n广播的话，是最容易理解的，就比如系统广播一样，可以携带一些数据给其他应用。这个可以去看广播的章节。\n\n\n# 内容提供者\n\n这个也是一样的，提供一个uri给外部应用区访问内部应用的数据库数据。这个可以去看内容提供者的章节。\n\n\n# socket\n\n这个也可以理解，直接以网络的形式进行数据传输。\n\n\n# messenger\n\nmessenger可以翻译为信使，顾名思义，通过它可以在不同进程传递message对象，在message中放入我们需要传递的数据，就可以轻松的实现数据的进程间传递了。messenger是一种轻量级的ipc方案，就像上面说的，它的底层实现时aidl。\n\n# 服务端\n\n我们首先实现一个服务端：\n\nclass baseservice : service() {\n    companion object {\n        private const val tag = "baseservice"\n    }\n\n    private val messengerhandler = object : handler(looper.getmainlooper()) {\n        override fun handlemessage(msg: message) {\n            log.d(tag, "receive msg from client: " + msg.data.getstring("msg"))\n        }\n    }\n\n    private val messenger = messenger(messengerhandler)\n\n    override fun oncreate() {\n        super.oncreate()\n        log.d(tag, "oncreate: ${thread.currentthread().name}")\n    }\n\n    override fun onbind(intent: intent?): ibinder? {\n        return messenger.binder\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注册为单个进程\n\n    <service android:name="xxx"\n            android:process=":remote"/>\n\n\n1\n2\n\n\n# 客户端\n\n再实现客户端：\n\n    private var messenger: messenger? = null\n\n    private val serviceconnection = object : serviceconnection {\n        override fun onserviceconnected(name: componentname?, service: ibinder?) {\n            log.d(tag, "onserviceconnected: ")\n            messenger = messenger(service)\n        }\n\n        override fun onservicedisconnected(name: componentname?) {\n            log.d(tag, "onservicedisconnected: ")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 消息\n\n发送消息：\n\n    val message = message.obtain()\n    val bundle = bundle()\n    bundle.putstring("msg","hello i\'m client")\n    message.data = bundle\n    messenger?.send(message)\n\n\n1\n2\n3\n4\n5\n\n\n# 结果\n\n结果：\n\n2022-10-24 17:30:30.080 16283-16283/cc.fastcv.codelab d/mainactivity: oncreate: \n2022-10-24 17:30:33.282 16458-16458/cc.fastcv.codelab d/baseservice: oncreate: main\n2022-10-24 17:30:33.282 16458-16458/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 17:30:33.284 16283-16283/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 17:30:35.763 16458-16458/cc.fastcv.codelab d/baseservice: receive msg from client: hello i\'m client\n2022-10-24 17:30:36.924 16458-16458/cc.fastcv.codelab d/baseservice: receive msg from client: hello i\'m client\n2022-10-24 17:30:39.025 16458-16458/cc.fastcv.codelab d/baseservice: unbindservice: \n2022-10-24 17:30:39.026 16458-16458/cc.fastcv.codelab d/baseservice: ondestroy: \n2022-10-24 17:30:40.699 16458-16458/cc.fastcv.codelab d/baseservice: receive msg from client: hello i\'m client\n2022-10-24 17:30:41.532 16458-16458/cc.fastcv.codelab d/baseservice: receive msg from client: hello i\'m client\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从结果上看，我们明明已经停止服务了。为啥还可以继续发送消息呢？\n\n这是因为，我们的 binder 服务已经跑起来了，相互建立连接后，依赖的是 binder 服务在通信，和service无关了。\n\n# 异常处理\n\n如果我们的远程服务进程死掉了，那么我们再发送消息的时候就会出现一个异常：\n\n     caused by: android.os.deadobjectexception\n        at android.os.binderproxy.transactnative(native method)\n        at android.os.binderproxy.transact(binderproxy.java:510)\n        at android.os.imessenger$stub$proxy.send(imessenger.java:123)\n        at android.os.messenger.send(messenger.java:57)\n        at com.example.pipixia.mainactivity.send(mainactivity.kt:68)\n\n\n1\n2\n3\n4\n5\n6\n\n\n所以，我们在发送消息时，需要做异常处理。\n\n    fun send(view: view?) {\n        val message = message.obtain()\n        val bundle = bundle()\n        bundle.putstring("msg","hello i\'m client")\n        message.data = bundle\n\n        try {\n            messenger?.send(message)\n        } catch (e: remoteexception) {\n            log.d(tag, "send: messenger 消息发送失败")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 双向通信\n\n其实，实现双向通信的诀窍在 message 的 replyto 字段上，我们可以把我们客户端加一个 messenger 当成一个 服务端来使用。只要将客户端服务器的 binder 地址发送给服务端即可。\n\n客户端\n\n    //新增服务\n    private val messengerhandler = object : handler(looper.getmainlooper()) {\n        override fun handlemessage(msg: message) {\n            log.d(tag, "receive msg from server: " + msg.data.getstring("msg"))\n        }\n    }\n\n    private val messengerserver = messenger(messengerhandler)\n    \n    //发送消息时 带上服务地址\n    val message = message.obtain()\n    val bundle = bundle()\n    bundle.putstring("msg","hello i\'m client")\n    message.data = bundle\n    message.replyto = messengerserver\n    messenger?.send(message)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n服务端：\n\n    //收到消息 回复\n    val message = message.obtain()\n    val bundle = bundle()\n    bundle.putstring("msg","hello i\'m server")\n    message.data = bundle\n    msg.replyto.send(message)\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果：\n\n2022-10-24 17:47:32.433 17222-17222/cc.fastcv.codelab d/mainactivity: oncreate: \n2022-10-24 17:47:39.798 17280-17280/cc.fastcv.codelab d/baseservice: oncreate: main\n2022-10-24 17:47:39.799 17280-17280/cc.fastcv.codelab d/baseservice: onbind: \n2022-10-24 17:47:39.801 17222-17222/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-24 17:47:43.332 17280-17280/cc.fastcv.codelab d/baseservice: receive msg from client: hello i\'m client\n2022-10-24 17:47:43.333 17222-17222/cc.fastcv.codelab d/mainactivity: receive msg from server: hello i\'m server\n\n\n1\n2\n3\n4\n5\n6\n\n\n总结\n\n * 优点：使用简单，上手很快\n * 缺点：执行方法时串行的，只能一个一个的执行，不能进行大量的并发处理。这个时候还是得用aidl。\n\n\n# aidl\n\naidl是android中ipc（inter-process communication）方式中的一种，aidl是android interface definition language的缩写，对于小白来说，aidl的作用是让你可以在自己的app里绑定一个其他app的service，这样你的app可以和其他app交互。\n\n# 单向读写数据\n\n通过as我们在我们的包下新建一个aidl文件，我们项目目录就会出现一个aidl文件夹，里面有我们刚才新建的那个aidl文件，查看文件可以看到，如\n\ninterface imyaidlinterface {\n    void basictypes(int anint, long along, boolean aboolean, float afloat,\n            double adouble, string astring);\n}\n\n\n1\n2\n3\n4\n\n\n序列化\n\n前面说过，如果要把数据跨进程传输，需要把数据序列化之后才行，所以，这里我们举个例子，将book类实现序列化接口：\n\ndata class book(var bookid: int, var bookname: string?) : parcelable {\n    constructor(parcel: parcel) : this(parcel.readint(), parcel.readstring()) {}\n\n    override fun writetoparcel(parcel: parcel, flags: int) {\n        parcel.writeint(bookid)\n        parcel.writestring (bookname)\n    }\n\n    override fun describecontents(): int {\n        return 0\n    }\n\n    companion object creator : parcelable.creator<book> {\n        override fun createfromparcel(parcel: parcel): book {\n            return book(parcel)\n        }\n\n        override fun newarray(size: int): array<book?> {\n            return arrayofnulls(size)\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n实现aidl文件\n\nimport cc.fastcv.codelab.book;\n\ninterface ibookmanagerinterface {\n\n    //得到所有的书籍\n    list<book> getbooklist();\n\n    //新增书籍\n    void addbook(in book book);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n构建module自动生成类文件\n\n我们build下我们的项目模块，然后可以在\n\nbuild/generated/aidl_source_output_dir/[debug|release]/out/<packagename>/xxx/xxxx.java\n\n\n1\n\n\n我们可以点开看一下：(这里我们把它拆解一下)\n\npublic interface ibookmanagerinterface extends android.os.iinterface\n{\n  public static class default implements cc.fastcv.codelab.ibookmanagerinterface\n  { ... }\n\n  public static abstract class stub extends android.os.binder implements cc.fastcv.codelab.ibookmanagerinterface\n  {\n    ...\n    \n    private static class proxy implements cc.fastcv.codelab.ibookmanagerinterface\n    {\n     ...\n    }\n  }\n  //得到所有的书籍\n\n  public java.util.list<cc.fastcv.codelab.book> getbooklist() throws android.os.remoteexception;\n  //新增书籍\n\n  public void addbook(cc.fastcv.codelab.book book) throws android.os.remoteexception;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这样子，整体结构就比较清晰了，首先是一个大的接口类：ibookmanagerinterface，然后在内部有一个静态的默认实现类default实现了ibookmanagerinterface接口。还有一个抽象代理类stub也实现了ibookmanagerinterface并且继承自 android.os.binder，如果你仔细看这个stub类的内容，你会发现很多很奇怪的内容，如：\n\n        case transaction_getbooklist:\n        {\n          data.enforceinterface(descriptor);\n          java.util.list<cc.fastcv.codelab.book> _result = this.getbooklist();\n          reply.writenoexception();\n          reply.writetypedlist(_result);\n          return true;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n还有就是它本身没有实现ibookmanagerinterface接口的方法，它只是定义了一些常量和相应常量的底层处理逻辑。那谁实现了ibookmanagerinterface接口？\n\n没错就是最后一个类 proxy 实现的这个接口，从它的内容来看，它并不关心底层的逻辑是怎么样处理的，它只用实现 ibookmanagerinterface 的方法，然后通过 android.os.ibinder mremote 来实现底层逻辑，如：\n\n            @override\n            public java.util.list<cc.fastcv.codelab.book> getbooklist() throws android.os.remoteexception {\n                android.os.parcel _data = android.os.parcel.obtain();\n                android.os.parcel _reply = android.os.parcel.obtain();\n                java.util.list<cc.fastcv.codelab.book> _result;\n                try {\n                    _data.writeinterfacetoken(descriptor);\n                    boolean _status = mremote.transact(stub.transaction_getbooklist, _data, _reply, 0);\n                    if (!_status && getdefaultimpl() != null) {\n                        return getdefaultimpl().getbooklist();\n                    }\n                    _reply.readexception();\n                    _result = _reply.createtypedarraylist(cc.fastcv.codelab.book.creator);\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n服务端\n\nclass bookservice : service() {\n    companion object {\n        val tag = "serverservice"\n    }\n\n    val manager = object : ibookmanagerinterface.stub() {\n        override fun getbooklist(): mutablelist<book> {\n            log.d(tag, "getbooklist:  pid = ${mypid()}")\n            return books\n        }\n\n        override fun addbook(book: book?) {\n            log.d(tag, "addbook: $book  pid = ${mypid()}")\n            books.add(book!!)\n        }\n    }\n\n    val books = arraylist<book>()\n\n    override fun onbind(intent: intent?): ibinder? {\n        log.d(tag, "onbind: ")\n        return manager\n    }\n\n    override fun onunbind(intent: intent?): boolean {\n        log.d(tag, "onunbind: ")\n        return super.onunbind(intent)\n    }\n\n    override fun ondestroy() {\n        super.ondestroy()\n        log.d(tag, "ondestroy: ")\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n记得在清单文件加上\n\n        <service android:name=".services.bookservice"\n            android:process=":remote"/>\n\n\n1\n2\n\n\n客户端\n\n    var stub:ibookmanagerinterface? = null\n\n    private val serviceconnection = object : serviceconnection {\n        override fun onserviceconnected(name: componentname?, service: ibinder?) {\n            log.d(tag, "onserviceconnected: ")\n            stub = ibookmanagerinterface.stub.asinterface(service)\n        }\n\n        override fun onservicedisconnected(name: componentname?) {\n            log.d(tag, "onservicedisconnected: ")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n新增\n\n       stub?.addbook(book(index++,"c语言$index 册"))\n\n\n1\n\n\n查询\n\n        stub?.booklist?.let {\n            for (book in it) {\n                log.d(tag, "书籍信息: $book")\n            }\n        }\n\n\n1\n2\n3\n4\n5\n\n\n结果：\n\n2022-10-25 14:10:12.960 13642-13656/cc.fastcv.codelab d/serverservice: getbooklist:  pid = 13642\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=1, bookname=c语言2 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=2, bookname=c语言3 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=3, bookname=c语言4 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=4, bookname=c语言5 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=5, bookname=c语言6 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=6, bookname=c语言7 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=7, bookname=c语言8 册)\n2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=8, bookname=c语言9 册)\n2022-10-25 14:10:26.973 13642-13656/cc.fastcv.codelab d/serverservice: addbook: book(bookid=9, bookname=c语言10 册)  pid = 13642\n2022-10-25 14:10:31.545 13642-13656/cc.fastcv.codelab d/serverservice: getbooklist:  pid = 13642\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=1, bookname=c语言2 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=2, bookname=c语言3 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=3, bookname=c语言4 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=4, bookname=c语言5 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=5, bookname=c语言6 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=6, bookname=c语言7 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=7, bookname=c语言8 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=8, bookname=c语言9 册)\n2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab d/mainactivity: 书籍信息: book(bookid=9, bookname=c语言10 册)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 双向读写数据\n\n在实现双向读写数据时，我们先记住一些常识，如aidl支持的数据类型有哪些\n\n * 基本数据类型（int、long、char、boolean、double等）\n * string 和 charsequence\n * list：只支持arraylist，里面的每个元素都必须能够被aidl支持\n * map：只支持hashmap，里面的每个元素都必须能够被aidl支持，包括key和value\n * parcelable：所有实现了parcelable接口的对象\n * aidl ：所有的aidl接口本身也可以在aidl文件中使用\n\n但是，其中自定义的parcelable对象和aidl对象必须显示import进来，不管它们是否和当前的aidl文件位于同一个包内。就像我们的book\n\nimport cc.fastcv.codelab.book;\n\n\n1\n\n\n接下来，我们想象一下，怎么样实现双向读写数据。从上面的代码，我们可以看到，客户端向服务器读写数据时，是拿到了服务器的一个binder对象然后进行数据读写的，那么我们可不可以逆向思维，把客户端也当成一个服务器，实现一个binder接口。因为上面说了，可以把aidl接口本身进行传递，我们来试一下\n\n首先实现客户端接收消息的aidl\n\ninterface iservernotyfyinterface {\n    void nofity(int limit);\n}\n\n\n1\n2\n3\n\n\n然后，修改之前服务端实现的接口，需要把我们客户端的接口注册过去，还得取消注册\n\nimport cc.fastcv.codelab.book;\nimport cc.fastcv.codelab.iservernotyfyinterface;\n\ninterface ibookmanagerinterface {\n\n    //得到所有的书籍\n    list<book> getbooklist();\n\n    //新增书籍\n    void addbook(in book book);\n\n    //传入我们的binder\n    void register(iservernotyfyinterface listener);\n\n    //取消监听\n    void unregister(iservernotyfyinterface listener);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n实现客户端接收消息\n\n    val listener = object : iservernotyfyinterface.stub() {\n        override fun nofity(limit: int) {\n            log.d(tag, "nofity: limit = $limit")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n\n\n    //注册监听\n    stub?.register(listener)\n    //注销监听\n    stub?.register(listener)\n\n\n1\n2\n3\n4\n\n\n服务端接收客户端的binder注册和反注册\n\n    var notify:iservernotyfyinterface? = null\n\n    val manager = object : ibookmanagerinterface.stub() {\n        override fun getbooklist(): mutablelist<book> {\n            log.d(tag, "getbooklist:  pid = ${mypid()}")\n            return books\n        }\n\n        override fun addbook(book: book?) {\n            log.d(tag, "addbook: $book  pid = ${mypid()}")\n            if (notify != null && notify!!.asbinder().isbinderalive && books.size%5 == 0) {\n                notify!!.nofity(books.size)\n            }\n            books.add(book!!)\n        }\n\n        override fun register(listener: iservernotyfyinterface?) {\n            log.d(tag, "register: ${listener.hashcode()}")\n            notify = listener\n        }\n\n        override fun unregister(listener: iservernotyfyinterface?) {\n            log.d(tag, "register: ${listener.hashcode()}")\n            notify = null\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在代码中可以看到，我们添加书籍的数量达到5的倍数后就会提醒客户端一次。\n\n2022-10-25 15:22:37.921 23575-23575/cc.fastcv.codelab d/serverservice: onbind: \n2022-10-25 15:22:37.922 23521-23521/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-25 15:22:37.923 23575-23588/cc.fastcv.codelab d/serverservice: register: 107797164\n2022-10-25 15:22:44.897 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=1, bookname=c语言2 册)  pid = 23575\n2022-10-25 15:22:44.898 23521-23521/cc.fastcv.codelab d/mainactivity: nofity: limit = 0\n2022-10-25 15:22:47.277 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=2, bookname=c语言3 册)  pid = 23575\n2022-10-25 15:22:49.655 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=3, bookname=c语言4 册)  pid = 23575\n2022-10-25 15:22:51.132 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=4, bookname=c语言5 册)  pid = 23575\n2022-10-25 15:22:52.287 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=5, bookname=c语言6 册)  pid = 23575\n2022-10-25 15:22:53.610 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=6, bookname=c语言7 册)  pid = 23575\n2022-10-25 15:22:53.611 23521-23521/cc.fastcv.codelab d/mainactivity: nofity: limit = 5\n2022-10-25 15:22:55.674 23521-23533/cc.fastcv.codelab w/system: a resource failed to call close. \n2022-10-25 15:22:55.726 23575-23588/cc.fastcv.codelab d/serverservice: addbook: book(bookid=7, bookname=c语言8 册)  pid = 23575\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样子，我们就实现了双向读写操作了。\n\n这里还存在一个问题\n\n我们看，我们注册的listener的hashcode和 取消注册的hashcode 的值\n\n2022-10-25 15:28:54.154 23929-23929/cc.fastcv.codelab d/serverservice: onbind: \n2022-10-25 15:28:54.155 23881-23881/cc.fastcv.codelab d/mainactivity: onserviceconnected: \n2022-10-25 15:28:54.157 23929-23946/cc.fastcv.codelab d/serverservice: register: 107797164\n2022-10-25 15:28:56.525 23929-23946/cc.fastcv.codelab d/serverservice: register: 67220341\n2022-10-25 15:28:56.527 23929-23929/cc.fastcv.codelab d/serverservice: onunbind: \n2022-10-25 15:28:56.527 23929-23929/cc.fastcv.codelab d/serverservice: ondestroy:\n\n\n1\n2\n3\n4\n5\n6\n\n\n两个值不一样，那么，如果存在多个listener组成一个集合，如：\n\n    val nofitys = arraylist<iservernotyfyinterface>()\n\n\n1\n\n\n那么，在取消监听的时候，就会出现一个问题，我们无法从集合中remove掉这个对象，那这种情况怎么处理呢？我们可以使用：\n\n    val nofitys = remotecallbacklist<iservernotyfyinterface>()   \n    \n    nofitys.register(listener)   \n    \n    nofitys.unregister(listener)\n\n\n1\n2\n3\n4\n5\n\n\n# 简析源码\n\n我们前面简单看过 aidl文件生成的 接口文件的组成\n\n * 真正的接口文件\n * stub binder的继承者，接口的实现者，实现底层数据处理逻辑，是个抽象类\n * proxy 接口的代理类，具体接口方法的实现类\n\n然后，看看我们服务端的具体实现\n\n    val manager = object : ibookmanagerinterface.stub() {\n        override fun getbooklist(): mutablelist<book> {\n            log.d(tag, "getbooklist:  pid = ${mypid()}")\n            return books\n        }\n\n        override fun addbook(book: book?) {\n            log.d(tag, "addbook: $book  pid = ${mypid()}")\n            if (notify != null && notify!!.asbinder().isbinderalive && books.size%5 == 0) {\n                notify!!.nofity(books.size)\n            }\n            books.add(book!!)\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可以看到，这里用匿名类的方法实现了ibookmanagerinterface.stub 这个抽象类，并且处理真正的数据。那当我们新增书籍的时候到底做了哪些事情呢？我们看看。\n\n首先在客户端，我们拿到binder对象的方式为：\n\n    var stub:ibookmanagerinterface? = null\n    stub = ibookmanagerinterface.stub.asinterface(service)\n\n\n1\n2\n\n\n这里用到了asinterface方法：\n\n    public static cc.fastcv.codelab.ibookmanagerinterface asinterface(android.os.ibinder obj)\n    {\n      if ((obj==null)) {\n        return null;\n      }\n      android.os.iinterface iin = obj.querylocalinterface(descriptor);\n      if (((iin!=null)&&(iin instanceof cc.fastcv.codelab.ibookmanagerinterface))) {\n        return ((cc.fastcv.codelab.ibookmanagerinterface)iin);\n      }\n      return new cc.fastcv.codelab.ibookmanagerinterface.stub.proxy(obj);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n将binder本身传入，然后通过stub.proxy代理的方式，获取到代理类。\n\n    private static class proxy implements cc.fastcv.codelab.ibookmanagerinterface\n    {\n      private android.os.ibinder mremote;\n      \n      proxy(android.os.ibinder remote)\n      {\n        mremote = remote;\n      }\n      \n      @override public android.os.ibinder asbinder()\n      {\n        return mremote;\n      }\n      \n      public java.lang.string getinterfacedescriptor()\n      {\n        return descriptor;\n      }\n      \n      //得到所有的书籍\n      @override public java.util.list<cc.fastcv.codelab.book> getbooklist() throws android.os.remoteexception\n      {\n        ...\n      }\n      \n      //新增书籍\n\n      @override public void addbook(cc.fastcv.codelab.book book) throws android.os.remoteexception\n      {\n        ...\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n可以看到，stub.proxy本身与binder无关，只是引用外部传入的mremote做的操作，并且实现了ibookmanagerinterface接口的相关方法。\n\n那也就是说，调用新增书籍的方法是从这里进入的。\n\n      //新增书籍\n      @override public void addbook(cc.fastcv.codelab.book book) throws android.os.remoteexception\n      {\n        //分配数据载体对象\n        android.os.parcel _data = android.os.parcel.obtain();\n        //分配数据返回对象\n        android.os.parcel _reply = android.os.parcel.obtain();\n        try {\n          //写入标识\n          _data.writeinterfacetoken(descriptor);\n          if ((book!=null)) {\n            _data.writeint(1);\n            //写入序列化数据\n            book.writetoparcel(_data, 0);\n          }\n          else {\n            _data.writeint(0);\n          }\n          //获取数据传输结果\n          boolean _status = mremote.transact(stub.transaction_addbook, _data, _reply, 0);\n          ...\n          //读取返回是否有异常信息\n          _reply.readexception();\n        }\n        finally {\n          //回收资源\n          _reply.recycle();\n          _data.recycle();\n        }\n      }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这里逻辑比较简单，我们继续看 mremote.transact(stub.transaction_addbook, _data, _reply, 0); 是怎么样的处理逻辑\n\n这里的mremote，有印象的人会知道它是 ibookmanagerinterface.stub 的实现类，也就是我们在服务端实现的 匿名类，它本身实现的ontransact为：\n\n    @override public boolean ontransact(int code, android.os.parcel data, android.os.parcel reply, int flags) throws android.os.remoteexception\n    {\n      java.lang.string descriptor = descriptor;\n      //code 方法标识\n      switch (code)\n      {\n        ...\n        case transaction_addbook:\n        {\n          //校验标识 如果存在错误的接口类型，则会引发 securityexception。\n          data.enforceinterface(descriptor);\n          cc.fastcv.codelab.book _arg0;\n          //检验是否有写入值 如果有则反序列化\n          if ((0!=data.readint())) {\n            _arg0 = cc.fastcv.codelab.book.creator.createfromparcel(data);\n          }\n          else {\n            _arg0 = null;\n          }\n          this.addbook(_arg0);\n          reply.writenoexception();\n          return true;\n        }\n        ...\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n可以看到，这里最终调用了this.addbook(_arg0); ，也就是最终调用到了我们实现的匿名类中。\n\n新增是客户端往服务端写，那读取列表是怎么实现的呢？\n\n      @override public java.util.list<cc.fastcv.codelab.book> getbooklist() throws android.os.remoteexception\n      {\n        android.os.parcel _data = android.os.parcel.obtain();\n        android.os.parcel _reply = android.os.parcel.obtain();\n        java.util.list<cc.fastcv.codelab.book> _result;\n        try {\n          _data.writeinterfacetoken(descriptor);\n          boolean _status = mremote.transact(stub.transaction_getbooklist, _data, _reply, 0);\n          if (!_status && getdefaultimpl() != null) {\n            return getdefaultimpl().getbooklist();\n          }\n          _reply.readexception();\n          //如果没有出现异常，则读取数据\n          _result = _reply.createtypedarraylist(cc.fastcv.codelab.book.creator);\n        }\n        finally {\n          _reply.recycle();\n          _data.recycle();\n        }\n        return _result;\n      }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n    @override public boolean ontransact(int code, android.os.parcel data, android.os.parcel reply, int flags) throws android.os.remoteexception\n    {\n      java.lang.string descriptor = descriptor;\n      switch (code)\n      {\n        ...\n        case transaction_getbooklist:\n        {\n          data.enforceinterface(descriptor);\n          java.util.list<cc.fastcv.codelab.book> _result = this.getbooklist();\n          reply.writenoexception();\n          reply.writetypedlist(_result);\n          return true;\n        }\n        ...\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到，最后就是通过 reply 写入返回值。\n\n总结\n\n客户端总的来说：（带返回值的）\n\n * 首先创建一个parcel _data用于传值\n * 再创建一个parcel _reply用于收值\n * 最后创建个我们要接收的类型，之后开始写入 如果没有就不写\n * 首先_data写入我们的标识， _data.writeinterfacetoken(descriptor);\n * 如果有值要传入，就写_data.writestrongbinder((((listener!=null))?(listener.asbinder()):(null))); 否则不写\n * 最后发起请求ibinder.transact(stub.transaction_getbooklist, _data, _reply, 0)\n * 再_reply.readexception();\n * 最后从_reply 取值 _result = _reply.createtypedarraylist(com.example.pipixia.ipc.aidl.book.creator); 如果没有值取就不写\n * 然后回收 parcel\n\n服务端：\n\n * data.enforceinterface(descriptor); 必须写\n * 如果有返回值 则拿值 java.util.list<com.example.pipixia.ipc.aidl.book> _result = this.getbooklist(); ， 没有则不写\n * 如果有传入的值，则拿值 arg0 = com.example.pipixia.ipc.aidl.book.creator.createfromparcel(data);; ， 没有则不写\n * eply.writenoexception();\n * 如果有返回值就写这行 reply.writetypedlist(_result); 否则不写\n * return true;\n\n这里我们虽然能猜到ontransact方法大概是干嘛的，但是它最后一个参数还是要讲一下：\n\n其中四个参数的意义是：\n\n字段      作用\ncode    是一个整形的唯一标识，用于区分执行哪个方法，客户端会传递此参数，告诉服务端执行哪个方法\ndata    客户端传递过来的参数\nreply   服务器返回回去的值\nflags   标明是否有返回值，0为有（双向），1为没有（单向）\n\n\n# binder\n\n说了这么久的binder，那binder到底是什么？\n\nibinder是远程对象的基本接口，是为了高性能而设计的轻量级远程调用机制的核心部分。但它不仅用于远程调用，也用于进程内调用。该接口定义了与远程对象间交互的协议。但不要直接实现 这个接口，而是继承(extends)binder。\n\nibinder主要的api是transact()，与之对应的api是binder.ontransact()。通过前者，你能 想远程ibinder对象发送发出调用，后者使你的远程对象能够响应接收到的调用。ibinder的api都是 syncronous(同步)执行的，比如transact()直到对方的binder.ontransact()方法调用玩 后才返回。 调用发生在进程内时无疑是这样的，而在进程间时，在ipc的帮助下，也是同样的效果。\n\n通过transact()发送的数据是parcel，parcel是一种一般的缓冲区，除了有数据外还带有 一些描述它内容的元数据。元数据用于管理ibinder对象的引用，这样就能在缓冲区从一个进程移动 到另一个进程时保存这些引用。这样就保证了当一个ibinder被写入到parcel并发送到另一个进程中， 如果另一个进程把同一个ibinder的引用回发到原来的进程，那么这个原来的进程就能接收到发出的 那个ibinder的引用。这种机制使ibinder和binder像唯一标志符那样在进程间管理。\n\n系统为每个进程维护一个存放交互线程的线程池。这些交互线程用于派送所有从另外进程发来的ipc 调用。例如：当一个ipc从进程ａ发到进程ｂ，ａ中那个发出调用的线程(这个应该不在线程池中)就阻塞 在transact()中了。进程ｂ中的交互线程池中的一个线程接收了这个调用，它调用 binder.ontransact()，完成后用一个parcel来做为结果返回。然后进程ａ中的那个等待的线程在 收到返回的parcel后得以继续执行。实际上，另一个进程看起来就像是当前进程的一个线程， 但不是当前进程创建的。\n\nbinder机制还支持进程间的递归调用。例如，进程ａ执行自己的ibinder的transact()调用进程ｂ 的binder，而进程ｂ在其binder.ontransact()中又用transact()向进程ａ发起调用，那么进程ａ 在等待它发出的调用返回的同时，还会用binder.ontransact()响应进程ｂ的transact()。 总之binder造成的结果就是让我们感觉到跨进程的调用与进程内的调用没什么区别。\n\n直观来说，binder是android中的一个类，它实现了ibinder接口。从ipc角度来说，binder是android中的一种跨进程通信方式，binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从android framework角度来说，binder是servicemanager连接各种manager(am，wm，等等)和相应managerservice的桥梁；从android应用层来说，binder是客户端和服务端进行通信的媒介，当bindservice的时候，服务端就会返回一个包含了服务端业务调用的binder对象，通过这个binder对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通服务和基于aidl的服务。\n\nbinder能干什么？binder可以提供系统中任何程序都可以访问的全局服务。这个功能当然是任何系统都应该提供的，下面我们简单看一下android的binder的框架\n\nandroid binder框架分为服务器接口、binder驱动、以及客户端接口；简单想一下，需要提供一个全局服务，那么全局服务那端即是服务器接口，任何程序即客户端接口，它们之间通过一个binder驱动访问。\n\n服务器端接口：实际上是binder类的对象，该对象一旦创建，内部则会启动一个隐藏线程，会接收binder驱动发送的消息，收到消息后，会执行binder对象中的ontransact()函数，并按照该函数的参数执行不同的服务器端代码。\n\nbinder驱动：该对象也为binder类的实例，客户端通过该对象访问远程服务。\n\n客户端接口：获得binder驱动，调用其transact()发送消息至服务器\n\nbinder在运行过程中，可能由于某些原因导致异常终止了，这个时候我们到服务端的binder连接断裂（称之为binder死亡），会导致我们的远程调用失败。更为关键的是，如果我们不知道binder连接已经断裂，那么客户端的功能就会收到影响。为了解决这个问题，binder中提供了两个配对的方法linktodeath和unlinktodeath，通过linktodeath我们可以给binder设置一个死亡代理，当binder死亡时，我们就会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接。\n\n    val deathrecipient = ibinder.deathrecipient {\n        log.d(tag, ": binderdied")\n    }\n\n    private val serviceconnection = object : serviceconnection {\n        override fun onserviceconnected(name: componentname?, service: ibinder?) {\n            log.d(tag, "onserviceconnected: ")\n            service?.linktodeath(deathrecipient,0)\n            stub = ibookmanagerinterface.stub.asinterface(service)\n        }\n\n        override fun onservicedisconnected(name: componentname?) {\n            log.d(tag, "onservicedisconnected: ")\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n默认情况下，我们的远程服务任何人都可以连接，但这不应该是我们愿意看到的。所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务中的方法。这里有两种方式：\n\n声明权限\n\n    <permission android:name="com.example.pipixia.ipc.permission" />\n\n\n1\n\n\n在需要判断的地方加上这个\n\n            val check = checkcallingorselfpermission("com.example.pipixia.ipc.permission")            \n            if (check == packagemanager.permission_denied) {\n                return false\n            }\n\n\n1\n2\n3\n4\n\n\n申请权限\n\n    <uses-permission android:name="com.example.pipixia.ipc.permission" />\n\n\n1\n\n\n\n# android 8.0\n\n * 在 android 8.0 （api26）之前，创建前台服务的方式通常是先创建一个后台服务，然后将该服务推到前台。\n\n * android 8.0 （api26）有一项复杂功能；系统不允许后台应用创建后台服务。 因此，android 8.0 引入了一种全新的方法，即 context.startforegroundservice()，以在前台启动新服务。\n\n * 在系统创建服务后，应用有五秒的时间来调用该服务的 startforeground() 方法以显示新服务的用户可见通知。\n\n * 如果应用在此时间限制内未调用 startforeground()，则系统将停止服务并声明此应用为 anr。\n\nandroid.app.remoteserviceexception: context.startforegroundservice() did not then call service.startforeground()\nat android.app.activitythread$h.handlemessage(activitythread.java:1768)\nat android.os.handler.dispatchmessage(handler.java:106)\nat android.os.looper.loop(looper.java:164)\nat android.app.activitythread.main(activitythread.java:6494)\nat java.lang.reflect.method.invoke(native method)\nat com.android.internal.os.runtimeinit$methodandargscaller.run(runtimeinit.java:438)\nat com.android.internal.os.zygoteinit.main(zygoteinit.java:807)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 解决方法\n\n将 调用 startservice启动service 改为调用 startforegroundservice\n\npublic static void start() {\n        intent intent = new intent(appcontext.me(), scorerefreshserver.class);\n        if (build.version.sdk_int >= build.version_codes.o) {\n            appcontext.me().startforegroundservice(intent);\n        } else {\n            appcontext.me().startservice(intent);\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n并且，在service的oncreate方法中调用startforeground()\n\n    if (build.version.sdk_int >= build.version_codes.o) {   \n          ...\n          notification.builder builder = new notification.builder(getapplicationcontext(), appenv.umeng_channel)\n                    .setcontenttitle("正在后台运行")\n                    .setsmallicon(r.mipmap.logo);\n          startforeground(1, builder.build());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到startforeground 方法需要传入一个通知，也就是，我们需要给用户一个直观的表现，我们有个应用在后台运行。通知的知识我们会有单独的章节总结。\n\n或者按照官方的推荐，我们使用 jobintentservice。\n\n\n# android 9.0\n\n在 android 9.0 中，应用在使用前台服务之前必须先申请 foreground_service 权限，否则就会抛出 securityexception 异常。\n\n此外，由于 foreground_service 权限只是普通权限，因此开发者只需在 androidmanifest.xml 中注册此权限即可，系统会自动对此权限进行授权：\n\n\n# android 13.0\n\n这里对通知的改动比较大，所以需要提一下，注意下通知的变化。',charsets:{cjk:!0},lastUpdated:"10/26/2022",lastUpdatedTimestamp:1666778411e3},{title:"Intent-filter",frontmatter:{title:"Intent-filter",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/3e5b1b/",categories:["Android","四大组件"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/05.Intent-filter.html",relativePath:"02.Android/00.四大组件/05.Intent-filter.md",key:"v-da2a9fc6",path:"/pages/3e5b1b/",headers:[{level:2,title:"Intent的类型",slug:"intent的类型",normalizedTitle:"intent的类型",charIndex:721},{level:2,title:"构建Intent",slug:"构建intent",normalizedTitle:"构建intent",charIndex:1310},{level:2,title:"隐式Intent安全校验",slug:"隐式intent安全校验",normalizedTitle:"隐式intent安全校验",charIndex:3660},{level:2,title:"强制使用应用选择器",slug:"强制使用应用选择器",normalizedTitle:"强制使用应用选择器",charIndex:4221},{level:2,title:"接收隐式Intent",slug:"接收隐式intent",normalizedTitle:"接收隐式intent",charIndex:4752},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:295},{level:3,title:"android:icon",slug:"android-icon",normalizedTitle:"android:icon",charIndex:5480},{level:3,title:"android:label",slug:"android-label",normalizedTitle:"android:label",charIndex:5528},{level:3,title:"android:priority",slug:"android-priority",normalizedTitle:"android:priority",charIndex:5575},{level:3,title:"android:order",slug:"android-order",normalizedTitle:"android:order",charIndex:6602},{level:3,title:"android:autoVerify",slug:"android-autoverify",normalizedTitle:"android:autoverify",charIndex:6805},{level:2,title:"Android12",slug:"android12",normalizedTitle:"android12",charIndex:11331},{level:2,title:"Android13",slug:"android13",normalizedTitle:"android13",charIndex:11400},{level:3,title:"Intent filters block non-matching intents",slug:"intent-filters-block-non-matching-intents",normalizedTitle:"intent filters block non-matching intents",charIndex:11782},{level:4,title:"具体变更",slug:"具体变更",normalizedTitle:"具体变更",charIndex:12114},{level:4,title:"豁免",slug:"豁免",normalizedTitle:"豁免",charIndex:13657},{level:4,title:"适配办法",slug:"适配办法",normalizedTitle:"适配办法",charIndex:13837},{level:4,title:"残留",slug:"残留",normalizedTitle:"残留",charIndex:14302},{level:3,title:"Safer exporting of context-registered receivers",slug:"safer-exporting-of-context-registered-receivers",normalizedTitle:"safer exporting of context-registered receivers",charIndex:14453},{level:4,title:"具体变更",slug:"具体变更-2",normalizedTitle:"具体变更",charIndex:12114},{level:4,title:"豁免",slug:"豁免-2",normalizedTitle:"豁免",charIndex:13657},{level:4,title:"适配办法",slug:"适配办法-2",normalizedTitle:"适配办法",charIndex:13837}],headersStr:"Intent的类型 构建Intent 隐式Intent安全校验 强制使用应用选择器 接收隐式Intent 属性 android:icon android:label android:priority android:order android:autoVerify Android12 Android13 Intent filters block non-matching intents 具体变更 豁免 适配办法 残留 Safer exporting of context-registered receivers 具体变更 豁免 适配办法",content:'# 写在前面\n\n如果你是按照顺序来阅读的，你就会对 Intent-filter 有点印象，比如在隐式Intent启动Activity时，我们就提到了，通过Intent-filter的Action,Category或data来实现 这个是通过Intent的 intent-filter来实现的\n\n再说，我们前面提到了 四大组件 都是依赖的 Intent来启动的，而这个名字 Intent过滤器，也能很直观的告诉我们，它的作用是用来过滤Intent的，那怎么一个过滤法呢？或者说，它依赖什么去过滤，过滤的规则是什么？\n\n没错，答案就在第一句话，它过滤依赖的有以下三个部分：\n\n * action属性\n * category属性\n * data属性\n\n比如：\n\n        <activity...>\n            <intent-filter>\n                <action android:name="android.intent.action.MAIN" />\n\n                <category android:name="android.intent.category.LAUNCHER" />\n            </intent-filter>\n        </activity>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在分别介绍它们之前，我们先来仔细聊下Intent启动的内容。\n\n\n# Intent\n\nIntent是一个消息传递对象，可以用来从其他应用组件请求操作。基本用例主要包括以下三个：\n\n * 启动Activity\n * 启动Service\n * 传递广播\n\n\n# Intent的类型\n\n * 显式Intent\n\n> 通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理Intent的应用。\n\n * 隐式Intent\n\n> 不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，需要在地图上向用户显示位置等。\n\n使用隐式Intent，Android系统通过将Intent的内容与设备上其他应用的清单文件中声明的Intent过滤器进行比较，从而找到要启动的相应组件。如果只有一个，那么直接启动；如果有多个，那么会显示一个对话框，支持用户选取要使用的应用。\n\nIntent过滤器，是应用清单文件中的一个表达式，用于指定该组件要接收的Intent类型。例如，通过为Activity声明Intent过滤器，可以使其他应用能够直接使用某一特定类型的Intent启动该Activity；如果未给Activity声明任何Intent过滤器，那么该Activity只能显示Intent启动。\n\n需要注意的是：\n\n> 启动Service时，应始终使用显示Intent，且不要为服务声明Intent过滤器。使用隐式Intent启动服务存在安全隐患，因为无法确定哪些服务将响应Intent，且用户也无法看到哪些服务已启动。从Android5.0开始，如果使用隐式Intent调用bindService，系统会抛出异常。\n\n\n# 构建Intent\n\nIntent对象携带Android系统用来确定要启动哪个组件的信息，以及收件人组件为了正确执行操作而使用的信息。也就是说主要分为两个方面：\n\n * ComponentName\n\n要启动的组件名称，为可选项。如果没有那么则为隐式Intent。\n\n对应这一属性的字段是ComponentName，可以通过方法setComponent()、setClass()、setClassName()，或Intent构造函数设置组件名称。\n\n * action\n\n指定要执行的通用操作的字符串。\n\n对于广播Intent，这是指已发生且正在报告的操作。操作会在很大程度上决定其余Intent的构成，特别是数据和extra中包含的内容。\n\n可以指定自己的操作，共应用内使用。也可以使用Intent中既定好的操作如：\n\nACTION_VIEW：通过一些Activity展示某些特定的信息，例如照片或地图\n\nACTION_SEND：也称为共享Intent。一些用户可通过其他应用共享的数据，如邮件或社交共享应用等。\n\n可以使用setAction()或Intent构造函数指定操作。\n\n * data\n\n引用待操作数据和/或该数据MIME类型的URI。\n\n创建Intent时，除了指定URI外，指定数据类型即MIME类型往往也很重要，这有助于Android系统找到接收Intent的最佳组件。当URI为content：xxx 类型时，表明数据位于设备中，且由ContentProvider控制，系统可以通过URI获知数据类型。\n\n仅设置数据通过setData()，如果要设置MIME类型则用setType（）。需要注意的是，不能既调setData又调setType，因为这两个方法会互相清除对方的设置。同时指定时应使用setDataAndType()。\n\n * category\n\n一个包含应处理Intent组件类型的附加信息的字符串。可以将任意数量的类别描述放入一个Intent中，但多数Intent均不需要类别。\n\n常见类别：\n\nCATEGORY_BROWSABLE：目标Activity允许本身通过网络浏览器启动，以显示连接引用的数据。\n\nCATEGORY_LAUNCHER：该Activity是任务的初始Activity，在系统的应用启动器中列出。\n\n指定类别通过方法addCategory()。\n\n * Extra\n\n携带完成请求操作所需的附加信息的键值对。通过Bundle保存键值对信息。\n\n在发给另一个应用接收的Intent时，不要使用Parcelable或Serializable数据，如果某个应用尝试访问Bundle对象中的数据，但没有对打包或序列化的访问权限，系统会触发RuntimeException。\n\n对应方法是putExtra()。\n\n * flag\n\n可以指示Android系统如何启动Activity，以及启动之后如何处理。\n\n对应方法是setFlags()。\n\n常用Intent Flags：\n\n * Intent.FLAG_ACTIVITY_NEW_TASK：这个是最常用的，但是往往会被误解，在程序根Activity的Task栈里加此标识开启新Activity都不会创建新的Task，只有当另一程序（进程）启动带有改标识的Activity时，才会创建新的Task。如果配合FLAG_ACTIVITY_NEW_MULTI_TASK，则无论什么情况都会创建新的Task，就成了类似 singleInstance 的情况了（singleInstance中的Activity独占一个栈）。如果配合 FLAG_ACTIVITY_CLEAR_TASK，则会先清空该栈，然后向栈中添加目标Activity，栈ID不变。\n * Intent.FLAG_ACTIVITY_CLEAR_TOP：有些文章中直接把该Flag说成作用和singleTask 相同，这是大错特错的。如果在ABCD的堆栈状态下，以该标识启动B，则会销毁CD，且B也是重新创建的（与singleTask有区别），如果配合FLAG_ACTIVITY_SINGLE_TOP，则就会成为 singleTask 的模式.\n * Intent.FLAG_ACTIVITY_SINGLE_TOP：同singleTop启动模式.\n * Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个Flag主要用来改变Task堆栈顺序，如果在ABCD的状态下，以该标识启动B，则会成为ACDB，且B不会重新创建\n * Intent.FLAG_ACTIVITY_REORDER_TO_FRONT：这个Flag主要用来改变Task堆栈顺序，如果在ABCD的状态下，以该标识启动B，则会成为ACDB，且B不会重新创建。\n * Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED：这个标识主要用于创建一个还原点，再次启动该Task时会将还原点之上包括其本身都销毁掉，如果在一个程序中以该标识启动了另外一个程序的功能，如一个用于看图的软件，当退出桌面，再点击这个程序，看图软件会消失。\n * Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：有此标识的 Activity 不会出现在历时列表里.\n * Intent.FLAG_ACTIVITY_FORWARD_RESULT：如果设置，并且该intent会启动一个新的Activity，则返回消息的目标会从当前Activity转移到新的Activity中。（在这个案例中，返回消息的目标最开始为B）\n\n\n# 隐式Intent安全校验\n\n通过隐式Intent可以将指定动作交由可处理的应用执行。但这其中也可能存在用户设备上没有任何应用能够处理此隐式Intent，或者由于配置文件限制或管理员执行了设置，导致该隐式Intent最终执行失败，一旦发生了这种情况，调用失败，发起此行为的应用也会崩溃。\n\n解决此种情况了方式也很简单，就是对Intent对象调用resolveActivity进行安全校验，如果有返回结果，那么至少有一个应用能够处理该Intent，这时使用隐式Intent是安全的。如果结果为空，那么该隐式Intent则不可用。\n\n// 创建一个隐式Intent\nval sendIntent = Intent().apply {\n    action = Intent.ACTION_SEND\n    putExtra(Intent.EXTRA_TEXT, textMessage)\n    type = "text/plain"\n}\n\n// 安全校验后，再使用该隐式Intent\nif (sendIntent.resolveActivity(packageManager) != null) {\n    startActivity(sendIntent)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 强制使用应用选择器\n\n通过隐式Intent发送目标意图时，可能存在多个应用均能处理此行为的情况，这时系统会弹出选择框，让用户选择一个应用处理此行为。同时，默认情况下，用户还可以将某款应用设置为此行为的默认处理应用，那么在下次触发时，则不会再显示选择框，直接交由之前用户选择的应用处理。\n\n当然，Android系统也提供了特定的API，可以使发起的隐式Intent每次都弹出应用选择框，用户则无法为该操作选择默认应用。\n\nval sendIntent = Intent(Intent.ACTION_SEND)\n...\nval title: String = resources.getString(R.string.chooser_title)\n// 创建显示应用选择框的隐式Intent\nval chooser: Intent = Intent.createChooser(sendIntent, title)\n// 安全验证后发起操作\nif (sendIntent.resolveActivity(packageManager) != null) {\n    startActivity(chooser)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 接收隐式Intent\n\n通过在清单文件中使用<intent-filter>元素，可以为每个应用组件声明一个或多个Intent过滤器。每个Intent过滤器均根据Intent的操作、数据和类别指定自身接受的Intent类型。仅当隐式Intent可以通过Intent过滤器之一传递时，系统才会将该Intent传递给应用组件。\n\n在<intent-filer>标签内部，可以使用以下三种元素中的一个或多个指定要接受的Intent类型：\n\n * <action>\n\n> 在name属性中，声明接受的Intent操作。值必须是操作的文本字符串值，而不是类常量。\n\n * <data>\n\n> 使用一个或多个指定数据URI（scheme、host、prot、path）各个方面和MIME类型的属性，声明接受的数据类型。\n\n * <category>\n\n> 在name属性中，声明接受的Intent类别。值必须是操作的文本字符串值，而不是类常量。\n> \n> 需要特别注意的一点是，如果要接受隐式Intent，必须将CATEGORY_DEFAULT类别包括在过滤器中。方法startActivity()和startActivityForResult()将按照其声明CATEGORY_DEFAULT类别的方式处理所有Intent。如果未在Intent过滤器中声明此类别，则隐式Intent不会解析为此Activity。\n\nActivity组件的Intent过滤器必须在清单文件中声明，但是广播的过滤器可以通过调用registerReceiver()动态注册。Service则应始终通过显式Intent开启。\n\n\n# Intent-filter\n\n<intent-filter android:icon="drawable resource"\n               android:label="string resource"\n               android:priority="integer" >\n    . . .\n</intent-filter>\n\n\n1\n2\n3\n4\n5\n\n\n**必须包含：**action属性\n\n\n# 属性\n\n\n# android:icon\n\n一个表示父 Activity、服务或广播接收器的图标，在将该组件以具备过滤器所描述功能的形式呈现给用户时显示。\n\n此属性必须设置为对包含图片定义的可绘制资源的引用。默认值为父组件的 icon 属性设置的图标。如果父组件未指定图标，则默认值为 <application> 元素设置的图标。\n\n\n# android:label\n\n父组件的用户可读标签。将相应组件以具备过滤器所描述功能的形式呈现给用户时，将使用此标签（而不是父组件设置的标签）。\n\n此标签应设置为对字符串资源的引用，以便可以像界面中的其他字符串一样进行本地化。不过，为了方便您开发应用，也可以将其设为原始字符串。\n\n默认值为父组件设置的标签。如果父组件未指定标签，则默认值为 <application> 元素的 label 属性设置的标签。\n\n\n# android:priority\n\n就处理过滤器所描述类型的 intent 而言，应该为父组件指定的优先级。此属性对 Activity 和广播接收器都有意义：\n\n * 它说明了某个 Activity 对与过滤器匹配的 Intent 的响应能力，这是相对于也可以响应该 Intent 的其他 Activity 的响应能力。当 Intent 可由优先级不同的多个 Activity 处理时，Android 只会将优先级值较高的 Activity 视为 Intent 的潜在目标。\n * 它控制按什么顺序执行广播接收器以接收广播消息。优先级值越高，调用顺序越靠前。（该顺序仅适用于同步消息；对于异步消息，系统会忽略该顺序。）\n\n只有在您确实需要对接收广播施加特定顺序或想要强制 Android 优先选用某个 Activity 时，才能使用此属性。\n\n值必须是一个整数，如“100”。数值越高，优先级也就越高。默认值为 0。\n\n在某些情况下，系统会忽略请求的优先级，并将值限定为 0。此类情况发生在：\n\n * 非特权应用请求任何大于 0 的优先级时\n * 特权应用为 ACTION_VIEW、ACTION_SEND、ACTION_SENDTO 或 ACTION_SEND_MULTIPLE 请求大于 0 的优先级时\n\n\n# android:order\n\n当多个过滤器匹配时应按什么顺序处理过滤器。\n\norder 与 priority 的不同之处在于，priority 在多个应用间应用，而 order 可消除单个应用中多个匹配的过滤器的歧义。\n\n当多个过滤器可以匹配时，请改用定向 Intent。\n\n值必须是一个整数，如“100”。数值越高，匹配顺序越靠前。 默认值为 0。\n\n此属性是在 API 级别 28 中引入的。\n\n\n# android:autoVerify\n\nAndroid 是否应验证指定主机中的 Digital Asset Links JSON 文件与此应用的匹配情况。\n\n请参阅：验证 Android App Links\n\n默认值为 false。\n\n此属性是在 API 级别 23 中引入的。\n\n\n# action\n\naction是一个字符串，如果Intent指明定了action，则目标组件的IntentFilter的action列表中就必须包含有这个action，否则不能匹配。一个Intent Filter中可声明多个action，Intent中的action与其中的任一个action在字符串形式上完全相同（注意，区分大小写，大小写不同但字符串内容相同也会造成匹配失败），action方面就匹配成功。可通过setAction方法为Intent设置action，也可在构造Intent时传入action。需要注意的是，隐式Intent必须指定action。比如我们在Manifest文件中为MyActivity定义了如下Intent Filter：\n\n<intent-filter>\n    <action android:name="android.intent.action.SEND"/>\n    <action android:name="android.intent.action.SEND_TO"/>\n</intent-filter>\n\n\n1\n2\n3\n4\n\n\n那么只要Intent的action为“SEND”或“SEND_TO”，那么这个Intent在action方面就能和上面那个Activity匹配成功。比如我们的Intent定义如下：\n\nIntent intent = new Intent("android.intent.action.SEND") ;\nstartActivity(intent);\n\n\n1\n2\n\n\n那么我们的Intent在action方面就与MyActivity匹配了。\n\nAndroid系统预定义了许多action，这些action代表了一些常见的操作。常见action如下（Intent类中的常量）：\n\nIntent.ACTION_VIEW\nIntent.ACTION_DIAL\nIntent.ACTION_SENDTO\nIntent.ACTION_SEND\nIntent.ACTION_WEB_SEARCH\n\n\n1\n2\n3\n4\n5\n\n\n\n# category\n\ncategory也是一个字符串，但是它与action的过滤规则不同，它要求Intent中个如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。也就是说，Intent中如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中的定义了的category。当然，Intent中也可以没有category（若Intent中未指定category，系统会自动为它带上“android.intent.category.DEFAULT”），如果没有，仍然可以匹配成功。category和action的区别在于，action要求Intent中必须有一个action且必须和过滤规则中的某几个action相同，而category要求Intent可以没有category，但是一旦发现存在category，不论你有多少，每个都要能够和过滤规则中的任何一个category相同。我们可以通过addCategory方法为Intent添加category。\n\n特别说明：\n\n<intent-filter>\n    <action android:name="android.intent.action.MAIN" />\n    <category android:name="android.intent.category.LAUNCHER" />\n</intent-filter>\n\n\n1\n2\n3\n4\n\n\n这二者共同出现，标明该Activity是一个入口Activity，并且会出现在系统应用列表中，二者缺一不可。\n\n\n# data\n\n如果Intent没有提供type，系统将从data中得到数据类型。和action一样，同action类似，只要Intent的data只要与Intent Filter中的任一个data声明完全相同，data方面就完全匹配成功。\n\ndata由两部分组成：\n\nmimeType和URI\n\n\n1\n\n\n\n\nMineType指的是媒体类型：\n\n例如imgage/jpeg，auto/mpeg4和viedo/*等，可以表示图片、文本、视频等不同的媒体格式\n\n\n1\n\n\nuri则由scheme、host、port、path | pathPattern | pathPrefix这4部分组成\n\n<scheme>://<host>:<port>/[<path>|<pathPrefix>|<pathPattern >]\n\n\n1\n\n\n例如： content://com.wooyun.org:200/folder/etc http://www.wooyun.org:80/search/info\n\nIntent的uri可通过setData方法设置，mimetype可通过setType方法设置。\n\n\n\n需要注意的是：若Intent Filter的data声明部分未指定uri，则缺省uri为content或file，Intent中的uri的scheme部分需为content或file才能匹配；若要为Intent指定完整的data，必须用setDataAndType方法，究其原因在，setData和setType方法的源码中我们发现：\n\npublic Intent setData(Uri data) {\n    mData = data;\n    mType = null;\n    return this;\n}\n\n\n1\n2\n3\n4\n5\n\n\npublic Intent setType(String type) {\n    mData = null;\n    mType = type;\n    return this;\n}\n\n\n1\n2\n3\n4\n5\n\n\n这两个方法会彼此互相清除对方的值（这个比较逗），即setData会把mimeType置为null，setType会把uri置为null。\n\n下面我们来举例说明一下data的匹配。首先我们先来看一下Intent Filter中指定data的语法：\n\n<data android:scheme="String.“ \n          android:host="String"\n          android:port="String"\n          android:path="String"\n          android:pathPattern="String"\n          android:pathPrefix="String"\n          android:mimeType="String"/>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n其中scheme、host等各个部分无需全部指定。\n\n使用案例：\n\n（1）如果我们想要匹配 http 以 “.pdf” 结尾的路径，使得别的程序想要打开网络 pdf 时，用户能够可以选择我们的程序进行下载查看。 我们可以将 scheme 设置为 “http”，pathPattern 设置为 “.*//.pdf”，整个 intent-filter 设置为：\n\n<intent-filter>  \n    <action android:name="android.intent.action.VIEW"></action>  \n    <category android:name="android.intent.category.DEFAULT"></category>  \n    <data android:scheme="http" android:pathPattern=".*//.pdf"></data>  \n</intent-filter>  \n\n\n1\n2\n3\n4\n5\n\n\n如果你只想处理某个站点的 pdf，那么在 data 标签里增加 android:host=”yoursite.com” 则只会匹配 http://yoursite.com/xxx/xxx.pdf，但这不会匹配 www.yoursite.com，如果你也想匹配这个站点的话，你就需要再添加一个 data 标签，除了 android:host 改为 “www.yoursite.com” 其他都一样。\n\n（2）如果我们做的是一个IM应用，或是其他类似于微博之类的应用，如何让别人通过 Intent 进行调用出现在选择框里呢？我们只用注册 android.intent.action.SEND 与 mimeType 为 “text/plain” 或 “/” 就可以了，整个 intent-filter 设置为：\n\n<intent-filter>  \n    <action android:name="android.intent.action.SEND" />  \n    <category android:name="android.intent.category.DEFAULT" />  \n    <data mimeType="*/*" />  \n</intent-filter> \n\n\n1\n2\n3\n4\n5\n\n\n这里设置 category 的原因是，创建的 Intent 的实例默认 category 就包含了 Intent.CATEGORY_DEFAULT ，google 这样做的原因是为了让这个 Intent 始终有一个 category。\n\n（3）如果我们做的是一个音乐播放软件，当文件浏览器打开某音乐文件的时候，使我们的应用能够出现在选择框里？这类似于文件关联了，其实做起来跟上面一样，也很简单，我们只用注册 android.intent.action.VIEW 与 mimeType 为 “audio/*” 就可以了，整个 intent-filter 设置为：\n\n<intent-filter>  \n     <action android:name="android.intent.action.VIEW" />  \n     <category android:name="android.intent.category.DEFAULT" />  \n     <data android:mimeType="audio/*" />  \n</intent-filter>  \n\n\n1\n2\n3\n4\n5\n\n\n\n# 版本适配\n\n\n# Android12\n\n安卓12需要把添加了 intent-filter 的四大组件的 export 属性加上，否则无法编译安装。\n\n\n# Android13\n\nAndroid 12 的一个安全性变更， 即声明了 <intent-filter> 的Activity、BroadcastReceiver、Service 必须声明 android:exported， 否则将会无法被启动。\n\nAndroid 12 的这个变更是为了防止开发者在不知情的情况下，声明了一个 intent-filter 就会使得这些组件对外公开，一定程度下强化了安全性。\n\n但是却漏掉了显式 Intent 启动和 Broadcast Receiver 动态注册两种情况，便在 13 中分别推出了两项变更来进行加强。\n\n 1. Intent filters block non- -matching intents\n 2. Safer exporting of context- -registered receivers\n\n\n# Intent filters block non-matching intents\n\nAndroid 13 开始 Intent 过滤器会屏蔽不匹配的 intent，即便是指定了 Component 的显式启动。\n\n在 13 以前：\n\n 1. 开发者想给 Component 添加 支持\n 2. 这个 需要公开给外部 App 使用，便设定了 Component exported 为 true\n 3. 这时候该 Component 就出现了一个安全漏洞：外部 App 使用不同于 中声明的 Action，甚至 mimeType 都不匹配均可以启动它\n\n也许你觉得这并没有什么，但是如果 App 只针对 过来的 Route 做了安全校验，就造成了校验上的疏漏。\n\n# 具体变更\n\n假如我们提供了的 Activity 像如下一样声明：\n\n<activity\n    android:name=".MainActivity"\n    android:exported="true">\n    <intent-filter>\n        <action android:name="android.intent.action.MAIN" />\n        <category android:name="android.intent.category.LAUNCHER" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name="android.intent.action.TEST" />\n        <data android:mimeType="vnd.android.cursor.dir/event"/>\n    </intent-filter>\n</activity>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 13 之前，其他 App 采用了显式启动，即便是错误的 ACTION 是可以正常启动我们的 Activity。\n\nprivate fun testIntentFilters() {\n    Intent().setComponent(\n        ComponentName("com.example.demoapplication",\n            "com.example.demoapplication.MainActivity")\n    ).apply {\n        action = "android.intent.action.TEST_A"\n        startActivity(this)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n而运行在 13 上的话，将无法启动并会发生如下错误：\n\nPackageManager: Intent does not match component\'s intent filter: Intent { act=android.intent.action.TEST_A cmp=com.example.demoapplication/.MainActivity }\n\nPackageManager: Access blocked: ComponentInfo{com.example.demoapplication/com.example.demoapplication.MainActivity}\n\n\n1\n2\n3\n\n\n除了 ACTION 修改正确以外，data 也要满足即 Intent-filter 完全符合才可以启动。\n\nprivate fun testIntentFilters() {\n    Intent().setComponent(\n        ComponentName("com.example.demoapplication",\n            "com.example.demoapplication.MainActivity")\n    ).apply {\n        action = "android.intent.action.TEST"\n        data = CalendarContract.Events.CONTENT_URI\n        startActivity(this)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 豁免\n\n如下的几种场景下的 Intent 并不在本次变更的影响范围内：\n\n 1. 目标 Component 没有声明 <intent-filter>\n 2. 同一个 App 内部发出的 Intent\n 3. 系统发出的 Intent，包括 SystemServer、采用 System UID 的系统 App\n 4. Root 进程发出的 Intent\n\n# 适配办法\n\n如果目标运行的版本基于 Android 13，并且不是上述豁免对象的话，需要做些检查和必要的修改。\n\n按照启动方和目标方两种情况进行适配办法的探讨：\n\n 1. 作为启动方：\n    * 是否存在采用显式 Intent 方式启动其他 App 或发送广播的情况\n      * startActivity()\n      * startActivityForResult()\n      * sendBroadcast()\n    * 该 Component 是否声明了 <intent-filter>\n    * 防止其 Target 升级到了 Android 13 无法正常启动，需要注意 Intent 的 action、data 等信息是否准确\n 2. 作为目标方：\n    * Target 是否需要升级到 Android 13\n    * 是否对外提供了 Component 并声明了 <intent-filter>\n    * 防止无法被正常启动，需要告知启动方 <intent-filter> 的信息\n\n# 残留\n\n13 上实测发现 Service 组件在显式启动下，即便是错误的 ACTION，仍能被正常启动。这是有意为之还是 Beta 版漏洞，源码尚未公开，原因未知。\n\n * startService()\n * startForegroundService()\n * bindService()\n\n\n# Safer exporting of context-registered receivers\n\n为了帮助提高运行时接收器的安全性，Android 13 允许您指定您应用中的特定广播接收器是否应被导出以及是否对设备上的其他应用可见。\n\n如果导出广播接收器，其他应用将可以向您的应用发送不受保护的广播。此导出配置在以 Android 13 或更高版本为目标平台的应用中可用，有助于防止一个主要的应用漏洞来源。\n\n# 具体变更\n\nTargetSDK 升级到 Android13 的 App 在动态注册 Receiver 的时候不指明该 flag，那么会收到如下的 crash：\n\njava.lang.SecurityException: com.example.demoapplication: One of RECEIVER_EXPORTED or RECEIVER_NOT_EXPORTED should be specified when a receiver isn\'t being registered exclusively for system broadcasts\n\n\n1\n\n\n目前上述限制不是默认生效的，需要开启如下兼容性变更：\n\n * 开发者选项 -> App Compatibility Changes -> Your App -> DYNAMIC_RECEIVER_EXPLICIT_EXPORT_REQUIRED\n\n另外，当你的 Receiver 声明了 RECEIVER_NOT_EXPORTED 的话，其他 App 向其发送广播会失败，并打印如下日志提醒你的 Receiver 需要公开：\n\nBroadcastQueue: Exported Denial: sending Intent { act=com.example.demoapplication.RECEIVER flg=0x10 }, action: com.example.demoapplication.RECEIVER from com.example.tiramisu_demo (uid=10161)\n\ndue to receiver ProcessRecord{8e5f11c 16942:com.example.demoapplication/u0a158} (uid 10158) not specifying RECEIVER_EXPORTED\n\n\n1\n2\n3\n\n\n# 豁免\n\n需要留意的是，系统级广播是受保护的，普通 App 没有权限发送。\n\n所以只是监听系统广播的话，动态注册的 Receiver 无需指定上述 flag。即便指定了 RECEIVER_NOT_EXPORTED，和静态注册方式一致也能正常接收、不受影响。\n\n# 适配办法\n\n找到所有动态注册 Broadcast Receiver 的代码。如果监听的包含非系统广播，请根据是否公开给其他 App 的需要使用来添加 flag 的声明。\n\n * RECEIVER_EXPORTED\n * RECEIVER_NOT_EXPORTED\n\ncontext.registerReceiver(sharedBroadcastReceiver, intentFilter,\n    RECEIVER_EXPORTED)\n\ncontext.registerReceiver(privateBroadcastReceiver, intentFilter,\n    RECEIVER_NOT_EXPORTED)\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# 写在前面\n\n如果你是按照顺序来阅读的，你就会对 intent-filter 有点印象，比如在隐式intent启动activity时，我们就提到了，通过intent-filter的action,category或data来实现 这个是通过intent的 intent-filter来实现的\n\n再说，我们前面提到了 四大组件 都是依赖的 intent来启动的，而这个名字 intent过滤器，也能很直观的告诉我们，它的作用是用来过滤intent的，那怎么一个过滤法呢？或者说，它依赖什么去过滤，过滤的规则是什么？\n\n没错，答案就在第一句话，它过滤依赖的有以下三个部分：\n\n * action属性\n * category属性\n * data属性\n\n比如：\n\n        <activity...>\n            <intent-filter>\n                <action android:name="android.intent.action.main" />\n\n                <category android:name="android.intent.category.launcher" />\n            </intent-filter>\n        </activity>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在分别介绍它们之前，我们先来仔细聊下intent启动的内容。\n\n\n# intent\n\nintent是一个消息传递对象，可以用来从其他应用组件请求操作。基本用例主要包括以下三个：\n\n * 启动activity\n * 启动service\n * 传递广播\n\n\n# intent的类型\n\n * 显式intent\n\n> 通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理intent的应用。\n\n * 隐式intent\n\n> 不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，需要在地图上向用户显示位置等。\n\n使用隐式intent，android系统通过将intent的内容与设备上其他应用的清单文件中声明的intent过滤器进行比较，从而找到要启动的相应组件。如果只有一个，那么直接启动；如果有多个，那么会显示一个对话框，支持用户选取要使用的应用。\n\nintent过滤器，是应用清单文件中的一个表达式，用于指定该组件要接收的intent类型。例如，通过为activity声明intent过滤器，可以使其他应用能够直接使用某一特定类型的intent启动该activity；如果未给activity声明任何intent过滤器，那么该activity只能显示intent启动。\n\n需要注意的是：\n\n> 启动service时，应始终使用显示intent，且不要为服务声明intent过滤器。使用隐式intent启动服务存在安全隐患，因为无法确定哪些服务将响应intent，且用户也无法看到哪些服务已启动。从android5.0开始，如果使用隐式intent调用bindservice，系统会抛出异常。\n\n\n# 构建intent\n\nintent对象携带android系统用来确定要启动哪个组件的信息，以及收件人组件为了正确执行操作而使用的信息。也就是说主要分为两个方面：\n\n * componentname\n\n要启动的组件名称，为可选项。如果没有那么则为隐式intent。\n\n对应这一属性的字段是componentname，可以通过方法setcomponent()、setclass()、setclassname()，或intent构造函数设置组件名称。\n\n * action\n\n指定要执行的通用操作的字符串。\n\n对于广播intent，这是指已发生且正在报告的操作。操作会在很大程度上决定其余intent的构成，特别是数据和extra中包含的内容。\n\n可以指定自己的操作，共应用内使用。也可以使用intent中既定好的操作如：\n\naction_view：通过一些activity展示某些特定的信息，例如照片或地图\n\naction_send：也称为共享intent。一些用户可通过其他应用共享的数据，如邮件或社交共享应用等。\n\n可以使用setaction()或intent构造函数指定操作。\n\n * data\n\n引用待操作数据和/或该数据mime类型的uri。\n\n创建intent时，除了指定uri外，指定数据类型即mime类型往往也很重要，这有助于android系统找到接收intent的最佳组件。当uri为content：xxx 类型时，表明数据位于设备中，且由contentprovider控制，系统可以通过uri获知数据类型。\n\n仅设置数据通过setdata()，如果要设置mime类型则用settype（）。需要注意的是，不能既调setdata又调settype，因为这两个方法会互相清除对方的设置。同时指定时应使用setdataandtype()。\n\n * category\n\n一个包含应处理intent组件类型的附加信息的字符串。可以将任意数量的类别描述放入一个intent中，但多数intent均不需要类别。\n\n常见类别：\n\ncategory_browsable：目标activity允许本身通过网络浏览器启动，以显示连接引用的数据。\n\ncategory_launcher：该activity是任务的初始activity，在系统的应用启动器中列出。\n\n指定类别通过方法addcategory()。\n\n * extra\n\n携带完成请求操作所需的附加信息的键值对。通过bundle保存键值对信息。\n\n在发给另一个应用接收的intent时，不要使用parcelable或serializable数据，如果某个应用尝试访问bundle对象中的数据，但没有对打包或序列化的访问权限，系统会触发runtimeexception。\n\n对应方法是putextra()。\n\n * flag\n\n可以指示android系统如何启动activity，以及启动之后如何处理。\n\n对应方法是setflags()。\n\n常用intent flags：\n\n * intent.flag_activity_new_task：这个是最常用的，但是往往会被误解，在程序根activity的task栈里加此标识开启新activity都不会创建新的task，只有当另一程序（进程）启动带有改标识的activity时，才会创建新的task。如果配合flag_activity_new_multi_task，则无论什么情况都会创建新的task，就成了类似 singleinstance 的情况了（singleinstance中的activity独占一个栈）。如果配合 flag_activity_clear_task，则会先清空该栈，然后向栈中添加目标activity，栈id不变。\n * intent.flag_activity_clear_top：有些文章中直接把该flag说成作用和singletask 相同，这是大错特错的。如果在abcd的堆栈状态下，以该标识启动b，则会销毁cd，且b也是重新创建的（与singletask有区别），如果配合flag_activity_single_top，则就会成为 singletask 的模式.\n * intent.flag_activity_single_top：同singletop启动模式.\n * intent.flag_activity_brought_to_front：这个flag主要用来改变task堆栈顺序，如果在abcd的状态下，以该标识启动b，则会成为acdb，且b不会重新创建\n * intent.flag_activity_reorder_to_front：这个flag主要用来改变task堆栈顺序，如果在abcd的状态下，以该标识启动b，则会成为acdb，且b不会重新创建。\n * intent.flag_activity_reset_task_if_needed：这个标识主要用于创建一个还原点，再次启动该task时会将还原点之上包括其本身都销毁掉，如果在一个程序中以该标识启动了另外一个程序的功能，如一个用于看图的软件，当退出桌面，再点击这个程序，看图软件会消失。\n * intent.flag_activity_exclude_from_recents：有此标识的 activity 不会出现在历时列表里.\n * intent.flag_activity_forward_result：如果设置，并且该intent会启动一个新的activity，则返回消息的目标会从当前activity转移到新的activity中。（在这个案例中，返回消息的目标最开始为b）\n\n\n# 隐式intent安全校验\n\n通过隐式intent可以将指定动作交由可处理的应用执行。但这其中也可能存在用户设备上没有任何应用能够处理此隐式intent，或者由于配置文件限制或管理员执行了设置，导致该隐式intent最终执行失败，一旦发生了这种情况，调用失败，发起此行为的应用也会崩溃。\n\n解决此种情况了方式也很简单，就是对intent对象调用resolveactivity进行安全校验，如果有返回结果，那么至少有一个应用能够处理该intent，这时使用隐式intent是安全的。如果结果为空，那么该隐式intent则不可用。\n\n// 创建一个隐式intent\nval sendintent = intent().apply {\n    action = intent.action_send\n    putextra(intent.extra_text, textmessage)\n    type = "text/plain"\n}\n\n// 安全校验后，再使用该隐式intent\nif (sendintent.resolveactivity(packagemanager) != null) {\n    startactivity(sendintent)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 强制使用应用选择器\n\n通过隐式intent发送目标意图时，可能存在多个应用均能处理此行为的情况，这时系统会弹出选择框，让用户选择一个应用处理此行为。同时，默认情况下，用户还可以将某款应用设置为此行为的默认处理应用，那么在下次触发时，则不会再显示选择框，直接交由之前用户选择的应用处理。\n\n当然，android系统也提供了特定的api，可以使发起的隐式intent每次都弹出应用选择框，用户则无法为该操作选择默认应用。\n\nval sendintent = intent(intent.action_send)\n...\nval title: string = resources.getstring(r.string.chooser_title)\n// 创建显示应用选择框的隐式intent\nval chooser: intent = intent.createchooser(sendintent, title)\n// 安全验证后发起操作\nif (sendintent.resolveactivity(packagemanager) != null) {\n    startactivity(chooser)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 接收隐式intent\n\n通过在清单文件中使用<intent-filter>元素，可以为每个应用组件声明一个或多个intent过滤器。每个intent过滤器均根据intent的操作、数据和类别指定自身接受的intent类型。仅当隐式intent可以通过intent过滤器之一传递时，系统才会将该intent传递给应用组件。\n\n在<intent-filer>标签内部，可以使用以下三种元素中的一个或多个指定要接受的intent类型：\n\n * <action>\n\n> 在name属性中，声明接受的intent操作。值必须是操作的文本字符串值，而不是类常量。\n\n * <data>\n\n> 使用一个或多个指定数据uri（scheme、host、prot、path）各个方面和mime类型的属性，声明接受的数据类型。\n\n * <category>\n\n> 在name属性中，声明接受的intent类别。值必须是操作的文本字符串值，而不是类常量。\n> \n> 需要特别注意的一点是，如果要接受隐式intent，必须将category_default类别包括在过滤器中。方法startactivity()和startactivityforresult()将按照其声明category_default类别的方式处理所有intent。如果未在intent过滤器中声明此类别，则隐式intent不会解析为此activity。\n\nactivity组件的intent过滤器必须在清单文件中声明，但是广播的过滤器可以通过调用registerreceiver()动态注册。service则应始终通过显式intent开启。\n\n\n# intent-filter\n\n<intent-filter android:icon="drawable resource"\n               android:label="string resource"\n               android:priority="integer" >\n    . . .\n</intent-filter>\n\n\n1\n2\n3\n4\n5\n\n\n**必须包含：**action属性\n\n\n# 属性\n\n\n# android:icon\n\n一个表示父 activity、服务或广播接收器的图标，在将该组件以具备过滤器所描述功能的形式呈现给用户时显示。\n\n此属性必须设置为对包含图片定义的可绘制资源的引用。默认值为父组件的 icon 属性设置的图标。如果父组件未指定图标，则默认值为 <application> 元素设置的图标。\n\n\n# android:label\n\n父组件的用户可读标签。将相应组件以具备过滤器所描述功能的形式呈现给用户时，将使用此标签（而不是父组件设置的标签）。\n\n此标签应设置为对字符串资源的引用，以便可以像界面中的其他字符串一样进行本地化。不过，为了方便您开发应用，也可以将其设为原始字符串。\n\n默认值为父组件设置的标签。如果父组件未指定标签，则默认值为 <application> 元素的 label 属性设置的标签。\n\n\n# android:priority\n\n就处理过滤器所描述类型的 intent 而言，应该为父组件指定的优先级。此属性对 activity 和广播接收器都有意义：\n\n * 它说明了某个 activity 对与过滤器匹配的 intent 的响应能力，这是相对于也可以响应该 intent 的其他 activity 的响应能力。当 intent 可由优先级不同的多个 activity 处理时，android 只会将优先级值较高的 activity 视为 intent 的潜在目标。\n * 它控制按什么顺序执行广播接收器以接收广播消息。优先级值越高，调用顺序越靠前。（该顺序仅适用于同步消息；对于异步消息，系统会忽略该顺序。）\n\n只有在您确实需要对接收广播施加特定顺序或想要强制 android 优先选用某个 activity 时，才能使用此属性。\n\n值必须是一个整数，如“100”。数值越高，优先级也就越高。默认值为 0。\n\n在某些情况下，系统会忽略请求的优先级，并将值限定为 0。此类情况发生在：\n\n * 非特权应用请求任何大于 0 的优先级时\n * 特权应用为 action_view、action_send、action_sendto 或 action_send_multiple 请求大于 0 的优先级时\n\n\n# android:order\n\n当多个过滤器匹配时应按什么顺序处理过滤器。\n\norder 与 priority 的不同之处在于，priority 在多个应用间应用，而 order 可消除单个应用中多个匹配的过滤器的歧义。\n\n当多个过滤器可以匹配时，请改用定向 intent。\n\n值必须是一个整数，如“100”。数值越高，匹配顺序越靠前。 默认值为 0。\n\n此属性是在 api 级别 28 中引入的。\n\n\n# android:autoverify\n\nandroid 是否应验证指定主机中的 digital asset links json 文件与此应用的匹配情况。\n\n请参阅：验证 android app links\n\n默认值为 false。\n\n此属性是在 api 级别 23 中引入的。\n\n\n# action\n\naction是一个字符串，如果intent指明定了action，则目标组件的intentfilter的action列表中就必须包含有这个action，否则不能匹配。一个intent filter中可声明多个action，intent中的action与其中的任一个action在字符串形式上完全相同（注意，区分大小写，大小写不同但字符串内容相同也会造成匹配失败），action方面就匹配成功。可通过setaction方法为intent设置action，也可在构造intent时传入action。需要注意的是，隐式intent必须指定action。比如我们在manifest文件中为myactivity定义了如下intent filter：\n\n<intent-filter>\n    <action android:name="android.intent.action.send"/>\n    <action android:name="android.intent.action.send_to"/>\n</intent-filter>\n\n\n1\n2\n3\n4\n\n\n那么只要intent的action为“send”或“send_to”，那么这个intent在action方面就能和上面那个activity匹配成功。比如我们的intent定义如下：\n\nintent intent = new intent("android.intent.action.send") ;\nstartactivity(intent);\n\n\n1\n2\n\n\n那么我们的intent在action方面就与myactivity匹配了。\n\nandroid系统预定义了许多action，这些action代表了一些常见的操作。常见action如下（intent类中的常量）：\n\nintent.action_view\nintent.action_dial\nintent.action_sendto\nintent.action_send\nintent.action_web_search\n\n\n1\n2\n3\n4\n5\n\n\n\n# category\n\ncategory也是一个字符串，但是它与action的过滤规则不同，它要求intent中个如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。也就是说，intent中如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中的定义了的category。当然，intent中也可以没有category（若intent中未指定category，系统会自动为它带上“android.intent.category.default”），如果没有，仍然可以匹配成功。category和action的区别在于，action要求intent中必须有一个action且必须和过滤规则中的某几个action相同，而category要求intent可以没有category，但是一旦发现存在category，不论你有多少，每个都要能够和过滤规则中的任何一个category相同。我们可以通过addcategory方法为intent添加category。\n\n特别说明：\n\n<intent-filter>\n    <action android:name="android.intent.action.main" />\n    <category android:name="android.intent.category.launcher" />\n</intent-filter>\n\n\n1\n2\n3\n4\n\n\n这二者共同出现，标明该activity是一个入口activity，并且会出现在系统应用列表中，二者缺一不可。\n\n\n# data\n\n如果intent没有提供type，系统将从data中得到数据类型。和action一样，同action类似，只要intent的data只要与intent filter中的任一个data声明完全相同，data方面就完全匹配成功。\n\ndata由两部分组成：\n\nmimetype和uri\n\n\n1\n\n\n\n\nminetype指的是媒体类型：\n\n例如imgage/jpeg，auto/mpeg4和viedo/*等，可以表示图片、文本、视频等不同的媒体格式\n\n\n1\n\n\nuri则由scheme、host、port、path | pathpattern | pathprefix这4部分组成\n\n<scheme>://<host>:<port>/[<path>|<pathprefix>|<pathpattern >]\n\n\n1\n\n\n例如： content://com.wooyun.org:200/folder/etc http://www.wooyun.org:80/search/info\n\nintent的uri可通过setdata方法设置，mimetype可通过settype方法设置。\n\n\n\n需要注意的是：若intent filter的data声明部分未指定uri，则缺省uri为content或file，intent中的uri的scheme部分需为content或file才能匹配；若要为intent指定完整的data，必须用setdataandtype方法，究其原因在，setdata和settype方法的源码中我们发现：\n\npublic intent setdata(uri data) {\n    mdata = data;\n    mtype = null;\n    return this;\n}\n\n\n1\n2\n3\n4\n5\n\n\npublic intent settype(string type) {\n    mdata = null;\n    mtype = type;\n    return this;\n}\n\n\n1\n2\n3\n4\n5\n\n\n这两个方法会彼此互相清除对方的值（这个比较逗），即setdata会把mimetype置为null，settype会把uri置为null。\n\n下面我们来举例说明一下data的匹配。首先我们先来看一下intent filter中指定data的语法：\n\n<data android:scheme="string.“ \n          android:host="string"\n          android:port="string"\n          android:path="string"\n          android:pathpattern="string"\n          android:pathprefix="string"\n          android:mimetype="string"/>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n其中scheme、host等各个部分无需全部指定。\n\n使用案例：\n\n（1）如果我们想要匹配 http 以 “.pdf” 结尾的路径，使得别的程序想要打开网络 pdf 时，用户能够可以选择我们的程序进行下载查看。 我们可以将 scheme 设置为 “http”，pathpattern 设置为 “.*//.pdf”，整个 intent-filter 设置为：\n\n<intent-filter>  \n    <action android:name="android.intent.action.view"></action>  \n    <category android:name="android.intent.category.default"></category>  \n    <data android:scheme="http" android:pathpattern=".*//.pdf"></data>  \n</intent-filter>  \n\n\n1\n2\n3\n4\n5\n\n\n如果你只想处理某个站点的 pdf，那么在 data 标签里增加 android:host=”yoursite.com” 则只会匹配 http://yoursite.com/xxx/xxx.pdf，但这不会匹配 www.yoursite.com，如果你也想匹配这个站点的话，你就需要再添加一个 data 标签，除了 android:host 改为 “www.yoursite.com” 其他都一样。\n\n（2）如果我们做的是一个im应用，或是其他类似于微博之类的应用，如何让别人通过 intent 进行调用出现在选择框里呢？我们只用注册 android.intent.action.send 与 mimetype 为 “text/plain” 或 “/” 就可以了，整个 intent-filter 设置为：\n\n<intent-filter>  \n    <action android:name="android.intent.action.send" />  \n    <category android:name="android.intent.category.default" />  \n    <data mimetype="*/*" />  \n</intent-filter> \n\n\n1\n2\n3\n4\n5\n\n\n这里设置 category 的原因是，创建的 intent 的实例默认 category 就包含了 intent.category_default ，google 这样做的原因是为了让这个 intent 始终有一个 category。\n\n（3）如果我们做的是一个音乐播放软件，当文件浏览器打开某音乐文件的时候，使我们的应用能够出现在选择框里？这类似于文件关联了，其实做起来跟上面一样，也很简单，我们只用注册 android.intent.action.view 与 mimetype 为 “audio/*” 就可以了，整个 intent-filter 设置为：\n\n<intent-filter>  \n     <action android:name="android.intent.action.view" />  \n     <category android:name="android.intent.category.default" />  \n     <data android:mimetype="audio/*" />  \n</intent-filter>  \n\n\n1\n2\n3\n4\n5\n\n\n\n# 版本适配\n\n\n# android12\n\n安卓12需要把添加了 intent-filter 的四大组件的 export 属性加上，否则无法编译安装。\n\n\n# android13\n\nandroid 12 的一个安全性变更， 即声明了 <intent-filter> 的activity、broadcastreceiver、service 必须声明 android:exported， 否则将会无法被启动。\n\nandroid 12 的这个变更是为了防止开发者在不知情的情况下，声明了一个 intent-filter 就会使得这些组件对外公开，一定程度下强化了安全性。\n\n但是却漏掉了显式 intent 启动和 broadcast receiver 动态注册两种情况，便在 13 中分别推出了两项变更来进行加强。\n\n 1. intent filters block non- -matching intents\n 2. safer exporting of context- -registered receivers\n\n\n# intent filters block non-matching intents\n\nandroid 13 开始 intent 过滤器会屏蔽不匹配的 intent，即便是指定了 component 的显式启动。\n\n在 13 以前：\n\n 1. 开发者想给 component 添加 支持\n 2. 这个 需要公开给外部 app 使用，便设定了 component exported 为 true\n 3. 这时候该 component 就出现了一个安全漏洞：外部 app 使用不同于 中声明的 action，甚至 mimetype 都不匹配均可以启动它\n\n也许你觉得这并没有什么，但是如果 app 只针对 过来的 route 做了安全校验，就造成了校验上的疏漏。\n\n# 具体变更\n\n假如我们提供了的 activity 像如下一样声明：\n\n<activity\n    android:name=".mainactivity"\n    android:exported="true">\n    <intent-filter>\n        <action android:name="android.intent.action.main" />\n        <category android:name="android.intent.category.launcher" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name="android.intent.action.test" />\n        <data android:mimetype="vnd.android.cursor.dir/event"/>\n    </intent-filter>\n</activity>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 13 之前，其他 app 采用了显式启动，即便是错误的 action 是可以正常启动我们的 activity。\n\nprivate fun testintentfilters() {\n    intent().setcomponent(\n        componentname("com.example.demoapplication",\n            "com.example.demoapplication.mainactivity")\n    ).apply {\n        action = "android.intent.action.test_a"\n        startactivity(this)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n而运行在 13 上的话，将无法启动并会发生如下错误：\n\npackagemanager: intent does not match component\'s intent filter: intent { act=android.intent.action.test_a cmp=com.example.demoapplication/.mainactivity }\n\npackagemanager: access blocked: componentinfo{com.example.demoapplication/com.example.demoapplication.mainactivity}\n\n\n1\n2\n3\n\n\n除了 action 修改正确以外，data 也要满足即 intent-filter 完全符合才可以启动。\n\nprivate fun testintentfilters() {\n    intent().setcomponent(\n        componentname("com.example.demoapplication",\n            "com.example.demoapplication.mainactivity")\n    ).apply {\n        action = "android.intent.action.test"\n        data = calendarcontract.events.content_uri\n        startactivity(this)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 豁免\n\n如下的几种场景下的 intent 并不在本次变更的影响范围内：\n\n 1. 目标 component 没有声明 <intent-filter>\n 2. 同一个 app 内部发出的 intent\n 3. 系统发出的 intent，包括 systemserver、采用 system uid 的系统 app\n 4. root 进程发出的 intent\n\n# 适配办法\n\n如果目标运行的版本基于 android 13，并且不是上述豁免对象的话，需要做些检查和必要的修改。\n\n按照启动方和目标方两种情况进行适配办法的探讨：\n\n 1. 作为启动方：\n    * 是否存在采用显式 intent 方式启动其他 app 或发送广播的情况\n      * startactivity()\n      * startactivityforresult()\n      * sendbroadcast()\n    * 该 component 是否声明了 <intent-filter>\n    * 防止其 target 升级到了 android 13 无法正常启动，需要注意 intent 的 action、data 等信息是否准确\n 2. 作为目标方：\n    * target 是否需要升级到 android 13\n    * 是否对外提供了 component 并声明了 <intent-filter>\n    * 防止无法被正常启动，需要告知启动方 <intent-filter> 的信息\n\n# 残留\n\n13 上实测发现 service 组件在显式启动下，即便是错误的 action，仍能被正常启动。这是有意为之还是 beta 版漏洞，源码尚未公开，原因未知。\n\n * startservice()\n * startforegroundservice()\n * bindservice()\n\n\n# safer exporting of context-registered receivers\n\n为了帮助提高运行时接收器的安全性，android 13 允许您指定您应用中的特定广播接收器是否应被导出以及是否对设备上的其他应用可见。\n\n如果导出广播接收器，其他应用将可以向您的应用发送不受保护的广播。此导出配置在以 android 13 或更高版本为目标平台的应用中可用，有助于防止一个主要的应用漏洞来源。\n\n# 具体变更\n\ntargetsdk 升级到 android13 的 app 在动态注册 receiver 的时候不指明该 flag，那么会收到如下的 crash：\n\njava.lang.securityexception: com.example.demoapplication: one of receiver_exported or receiver_not_exported should be specified when a receiver isn\'t being registered exclusively for system broadcasts\n\n\n1\n\n\n目前上述限制不是默认生效的，需要开启如下兼容性变更：\n\n * 开发者选项 -> app compatibility changes -> your app -> dynamic_receiver_explicit_export_required\n\n另外，当你的 receiver 声明了 receiver_not_exported 的话，其他 app 向其发送广播会失败，并打印如下日志提醒你的 receiver 需要公开：\n\nbroadcastqueue: exported denial: sending intent { act=com.example.demoapplication.receiver flg=0x10 }, action: com.example.demoapplication.receiver from com.example.tiramisu_demo (uid=10161)\n\ndue to receiver processrecord{8e5f11c 16942:com.example.demoapplication/u0a158} (uid 10158) not specifying receiver_exported\n\n\n1\n2\n3\n\n\n# 豁免\n\n需要留意的是，系统级广播是受保护的，普通 app 没有权限发送。\n\n所以只是监听系统广播的话，动态注册的 receiver 无需指定上述 flag。即便指定了 receiver_not_exported，和静态注册方式一致也能正常接收、不受影响。\n\n# 适配办法\n\n找到所有动态注册 broadcast receiver 的代码。如果监听的包含非系统广播，请根据是否公开给其他 app 的需要使用来添加 flag 的声明。\n\n * receiver_exported\n * receiver_not_exported\n\ncontext.registerreceiver(sharedbroadcastreceiver, intentfilter,\n    receiver_exported)\n\ncontext.registerreceiver(privatebroadcastreceiver, intentfilter,\n    receiver_not_exported)\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"10/15/2022",lastUpdatedTimestamp:1665831563e3},{title:"URL与URI基础",frontmatter:{title:"URL与URI基础",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/f7396a/",categories:["Android","四大组件"],tags:[null],readingShow:"top"},regularPath:"/02.Android/00.%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/06.URL%E4%B8%8EURI%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/00.四大组件/06.URL与URI基础.md",key:"v-2054c408",path:"/pages/f7396a/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/29/2022",lastUpdatedTimestamp:166704324e4},{title:"Fragment基础",frontmatter:{title:"Fragment基础",date:"2022-10-10T14:28:42.000Z",permalink:"/pages/208508/",categories:["Android","Fragment"],tags:[null],readingShow:"top"},regularPath:"/02.Android/01.Fragment/00.Fragment%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/01.Fragment/00.Fragment基础.md",key:"v-09bc8f71",path:"/pages/208508/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"RelativeLayout",frontmatter:{title:"RelativeLayout",date:"2022-10-10T14:40:39.000Z",permalink:"/pages/095150/",categories:["Android","UI控件","基础布局"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/00.%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/00.RelativeLayout.html",relativePath:"02.Android/02.UI控件/00.基础布局/00.RelativeLayout.md",key:"v-77fac728",path:"/pages/095150/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"TextView",frontmatter:{title:"TextView",date:"2022-10-10T14:41:23.000Z",permalink:"/pages/868569/",categories:["Android","UI控件","基础控件"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/01.%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/00.TextView.html",relativePath:"02.Android/02.UI控件/01.基础控件/00.TextView.md",key:"v-79c90a7b",path:"/pages/868569/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"ListView基础",frontmatter:{title:"ListView基础",date:"2022-10-10T14:42:26.000Z",permalink:"/pages/8c2382/",categories:["Android","UI控件","ListView"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/02.ListView/00.ListView%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/02.UI控件/02.ListView/00.ListView基础.md",key:"v-71574ded",path:"/pages/8c2382/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"RecycleView基础",frontmatter:{title:"RecycleView基础",date:"2022-10-10T14:42:39.000Z",permalink:"/pages/65d2a2/",categories:["Android","UI控件","RecycleView"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/03.RecycleView/00.RecycleView%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/02.UI控件/03.RecycleView/00.RecycleView基础.md",key:"v-30bf3c37",path:"/pages/65d2a2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"基础常识",frontmatter:{title:"基础常识",date:"2022-10-10T10:28:23.000Z",permalink:"/pages/442ac8/",categories:["系统平台","Android","UI控件","自定义控件"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/03.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/00.%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86.html",relativePath:"02.Android/02.UI控件/03.自定义控件/00.基础常识.md",key:"v-c0c40344",path:"/pages/442ac8/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"ViewPager基础",frontmatter:{title:"ViewPager基础",date:"2022-10-10T14:42:58.000Z",permalink:"/pages/da7733/",categories:["Android","UI控件","ViewPager"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/04.ViewPager/00.ViewPager%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/02.UI控件/04.ViewPager/00.ViewPager基础.md",key:"v-7a275079",path:"/pages/da7733/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Dialog",frontmatter:{title:"Dialog",date:"2022-10-10T10:28:37.000Z",permalink:"/pages/14a2f5/",categories:["系统平台","Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/04.%E5%BC%B9%E7%AA%97/00.Dialog.html",relativePath:"02.Android/02.UI控件/04.弹窗/00.Dialog.md",key:"v-4a5cfa03",path:"/pages/14a2f5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"Notification",frontmatter:{title:"Notification",date:"2022-10-10T10:30:10.000Z",permalink:"/pages/4f989a/",categories:["系统平台","Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/04.%E5%BC%B9%E7%AA%97/01.Notification.html",relativePath:"02.Android/02.UI控件/04.弹窗/01.Notification.md",key:"v-4c534fbf",path:"/pages/4f989a/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"PopupWindow",frontmatter:{title:"PopupWindow",date:"2022-10-10T10:29:48.000Z",permalink:"/pages/5a9638/",categories:["系统平台","Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/04.%E5%BC%B9%E7%AA%97/02.PopupWindow.html",relativePath:"02.Android/02.UI控件/04.弹窗/02.PopupWindow.md",key:"v-69f10f6e",path:"/pages/5a9638/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"Toast",frontmatter:{title:"Toast",date:"2022-10-10T10:28:51.000Z",permalink:"/pages/1e4f68/",categories:["系统平台","Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/04.%E5%BC%B9%E7%AA%97/03.Toast.html",relativePath:"02.Android/02.UI控件/04.弹窗/03.Toast.md",key:"v-3c10a1ee",path:"/pages/1e4f68/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665372021e3},{title:"WebView基础",frontmatter:{title:"WebView基础",date:"2022-10-10T14:43:06.000Z",permalink:"/pages/6e1c4a/",categories:["Android","UI控件","WebView"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/05.WebView/00.WebView%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/02.UI控件/05.WebView/00.WebView基础.md",key:"v-8f64580a",path:"/pages/6e1c4a/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"基础常识",frontmatter:{title:"基础常识",date:"2022-10-10T14:44:10.000Z",permalink:"/pages/60a9ae/",categories:["Android","UI控件","自定义控件"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/06.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/00.%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86.html",relativePath:"02.Android/02.UI控件/06.自定义控件/00.基础常识.md",key:"v-49b9a1be",path:"/pages/60a9ae/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Dialog",frontmatter:{title:"Dialog",date:"2022-10-10T14:44:19.000Z",permalink:"/pages/914d16/",categories:["Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/07.%E5%BC%B9%E7%AA%97/00.Dialog.html",relativePath:"02.Android/02.UI控件/07.弹窗/00.Dialog.md",key:"v-39fe8849",path:"/pages/914d16/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Notification",frontmatter:{title:"Notification",date:"2022-10-10T14:44:19.000Z",permalink:"/pages/1ed6d5/",categories:["Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/07.%E5%BC%B9%E7%AA%97/01.Notification.html",relativePath:"02.Android/02.UI控件/07.弹窗/01.Notification.md",key:"v-05549976",path:"/pages/1ed6d5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"PopupWindow",frontmatter:{title:"PopupWindow",date:"2022-10-10T14:44:19.000Z",permalink:"/pages/808803/",categories:["Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/07.%E5%BC%B9%E7%AA%97/02.PopupWindow.html",relativePath:"02.Android/02.UI控件/07.弹窗/02.PopupWindow.md",key:"v-2c8ff229",path:"/pages/808803/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Toast",frontmatter:{title:"Toast",date:"2022-10-10T14:44:19.000Z",permalink:"/pages/ee3e32/",categories:["Android","UI控件","弹窗"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/07.%E5%BC%B9%E7%AA%97/03.Toast.html",relativePath:"02.Android/02.UI控件/07.弹窗/03.Toast.md",key:"v-3627a1ae",path:"/pages/ee3e32/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"View动画",frontmatter:{title:"View动画",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/f616c6/",categories:["Android","UI控件","动画"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/08.%E5%8A%A8%E7%94%BB/00.View%E5%8A%A8%E7%94%BB.html",relativePath:"02.Android/02.UI控件/08.动画/00.View动画.md",key:"v-6943f57e",path:"/pages/f616c6/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/15/2022",lastUpdatedTimestamp:1665816068e3},{title:"属性动画",frontmatter:{title:"属性动画",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/d4d3f1/",categories:["Android","UI控件","动画"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/08.%E5%8A%A8%E7%94%BB/01.%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB.html",relativePath:"02.Android/02.UI控件/08.动画/01.属性动画.md",key:"v-20c332bc",path:"/pages/d4d3f1/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/15/2022",lastUpdatedTimestamp:1665816068e3},{title:"转场动画",frontmatter:{title:"转场动画",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/0cffc9/",categories:["Android","UI控件","动画"],tags:[null],readingShow:"top"},regularPath:"/02.Android/02.UI%E6%8E%A7%E4%BB%B6/08.%E5%8A%A8%E7%94%BB/02.%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.html",relativePath:"02.Android/02.UI控件/08.动画/02.转场动画.md",key:"v-8c83b362",path:"/pages/0cffc9/",headersStr:null,content:'转场动画 待补充...\n\n#问题收集 #1、切换效果无效 先写第一个，也是让我最懵逼的一个，搞了好几天都无果，直到我新弄了一个测试demo一个个排查才发现问题所在，原始的内容如下：\n\n<style name="horizontal_slide" parent="Theme.AppCompat.NoActionBar">\n    <item name="android:windowAnimationStyle">@style/slide</item>\n    <item name="android:windowIsTranslucent">true</item>\n    <item name="android:windowNoTitle">true</item>\n    <item name="android:windowBackground">@android:color/transparent</item>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n\n\n原因就是当自定义的style中有\n\nandroid:windowIsTranslucent\n\n\n1\n\n\n这一项的时候，其中自定义的动画切换效果\n\n@style/slide\n\n\n1\n\n\n必须继承自 Animation.Translucent，否则会无效！\n\n修改如下：\n\n<style name="slide" parent="@android:style/Animation.Translucent">\n    <item name="android:activityOpenEnterAnimation">@anim/in_from_right</item>\n    <item name="android:activityOpenExitAnimation">@anim/out_to_left</item>\n    <item name="android:activityCloseEnterAnimation">@anim/in_from_left</item>\n    <item name="android:activityCloseExitAnimation">@anim/out_to_right2</item>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'转场动画 待补充...\n\n#问题收集 #1、切换效果无效 先写第一个，也是让我最懵逼的一个，搞了好几天都无果，直到我新弄了一个测试demo一个个排查才发现问题所在，原始的内容如下：\n\n<style name="horizontal_slide" parent="theme.appcompat.noactionbar">\n    <item name="android:windowanimationstyle">@style/slide</item>\n    <item name="android:windowistranslucent">true</item>\n    <item name="android:windownotitle">true</item>\n    <item name="android:windowbackground">@android:color/transparent</item>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n\n\n原因就是当自定义的style中有\n\nandroid:windowistranslucent\n\n\n1\n\n\n这一项的时候，其中自定义的动画切换效果\n\n@style/slide\n\n\n1\n\n\n必须继承自 animation.translucent，否则会无效！\n\n修改如下：\n\n<style name="slide" parent="@android:style/animation.translucent">\n    <item name="android:activityopenenteranimation">@anim/in_from_right</item>\n    <item name="android:activityopenexitanimation">@anim/out_to_left</item>\n    <item name="android:activitycloseenteranimation">@anim/in_from_left</item>\n    <item name="android:activitycloseexitanimation">@anim/out_to_right2</item>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"10/15/2022",lastUpdatedTimestamp:1665816068e3},{title:"安卓文件基础",frontmatter:{title:"安卓文件基础",date:"2022-10-10T14:45:05.000Z",permalink:"/pages/61d3af/",categories:["Android","数据持久化","文件"],tags:[null],readingShow:"top"},regularPath:"/02.Android/03.%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/00.%E6%96%87%E4%BB%B6/00.%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/03.数据持久化/00.文件/00.安卓文件基础.md",key:"v-f171761e",path:"/pages/61d3af/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"SQLite基础",frontmatter:{title:"SQLite基础",date:"2022-10-10T14:45:05.000Z",permalink:"/pages/fc8ccf/",categories:["Android","数据持久化","数据库"],tags:[null],readingShow:"top"},regularPath:"/02.Android/03.%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/01.%E6%95%B0%E6%8D%AE%E5%BA%93/00.SQLite%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/03.数据持久化/01.数据库/00.SQLite基础.md",key:"v-30c1718e",path:"/pages/fc8ccf/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"SharedPreferences基础",frontmatter:{title:"SharedPreferences基础",date:"2022-10-10T14:45:05.000Z",permalink:"/pages/42bd30/",categories:["Android","数据持久化","SharedPreferences"],tags:[null],readingShow:"top"},regularPath:"/02.Android/03.%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/02.SharedPreferences/00.SharedPreferences%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/03.数据持久化/02.SharedPreferences/00.SharedPreferences基础.md",key:"v-52ed6d9a",path:"/pages/42bd30/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"传感器基础介绍",frontmatter:{title:"传感器基础介绍",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/9f8db9/",categories:["Android","传感器及连接性","传感器"],tags:[null],readingShow:"top"},regularPath:"/02.Android/04.%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8F%8A%E8%BF%9E%E6%8E%A5%E6%80%A7/00.%E4%BC%A0%E6%84%9F%E5%99%A8/00.%E4%BC%A0%E6%84%9F%E5%99%A8%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D.html",relativePath:"02.Android/04.传感器及连接性/00.传感器/00.传感器基础介绍.md",key:"v-86deda42",path:"/pages/9f8db9/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"蓝牙",frontmatter:{title:"蓝牙",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/f75c98/",categories:["Android","传感器及连接性","连接性"],tags:[null],readingShow:"top"},regularPath:"/02.Android/04.%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8F%8A%E8%BF%9E%E6%8E%A5%E6%80%A7/01.%E8%BF%9E%E6%8E%A5%E6%80%A7/00.%E8%93%9D%E7%89%99.html",relativePath:"02.Android/04.传感器及连接性/01.连接性/00.蓝牙.md",key:"v-45233dfe",path:"/pages/f75c98/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"NFC",frontmatter:{title:"NFC",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/f8d0da/",categories:["Android","传感器及连接性","连接性"],tags:[null],readingShow:"top"},regularPath:"/02.Android/04.%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8F%8A%E8%BF%9E%E6%8E%A5%E6%80%A7/01.%E8%BF%9E%E6%8E%A5%E6%80%A7/01.NFC.html",relativePath:"02.Android/04.传感器及连接性/01.连接性/01.NFC.md",key:"v-3b3f506b",path:"/pages/f8d0da/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"低功耗蓝牙",frontmatter:{title:"低功耗蓝牙",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/4db516/",categories:["Android","传感器及连接性","连接性"],tags:[null],readingShow:"top"},regularPath:"/02.Android/04.%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8F%8A%E8%BF%9E%E6%8E%A5%E6%80%A7/01.%E8%BF%9E%E6%8E%A5%E6%80%A7/02.%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99.html",relativePath:"02.Android/04.传感器及连接性/01.连接性/02.低功耗蓝牙.md",key:"v-3845c3dc",path:"/pages/4db516/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"OkHttp基础",frontmatter:{title:"OkHttp基础",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/e006e9/",categories:["Android","三方框架","OkHttp"],tags:[null],readingShow:"top"},regularPath:"/02.Android/05.%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/00.OkHttp/00.OkHttp%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/05.三方框架/00.OkHttp/00.OkHttp基础.md",key:"v-7b951ec0",path:"/pages/e006e9/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Retrofit基础",frontmatter:{title:"Retrofit基础",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/0886e5/",categories:["Android","三方框架","Retrofit"],tags:[null],readingShow:"top"},regularPath:"/02.Android/05.%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/01.Retrofit/00.Retrofit%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/05.三方框架/01.Retrofit/00.Retrofit基础.md",key:"v-5437b4e6",path:"/pages/0886e5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Glide基础",frontmatter:{title:"Glide基础",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/16acab/",categories:["Android","三方框架","Glide"],tags:[null],readingShow:"top"},regularPath:"/02.Android/05.%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/02.Glide/00.Glide%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/05.三方框架/02.Glide/00.Glide基础.md",key:"v-20657ba0",path:"/pages/16acab/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Koin基础",frontmatter:{title:"Koin基础",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/a69c33/",categories:["Android","三方框架","koin"],tags:[null],readingShow:"top"},regularPath:"/02.Android/05.%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/05.koin/00.Koin%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/05.三方框架/05.koin/00.Koin基础.md",key:"v-e799e854",path:"/pages/a69c33/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/29/2022",lastUpdatedTimestamp:166704324e4},{title:"MVC简介",frontmatter:{title:"MVC简介",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/d2011c/",categories:["Android","项目架构","MVC"],tags:[null],readingShow:"top"},regularPath:"/02.Android/06.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/00.MVC/00.MVC%E7%AE%80%E4%BB%8B.html",relativePath:"02.Android/06.项目架构/00.MVC/00.MVC简介.md",key:"v-028118fc",path:"/pages/d2011c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"MVP简介",frontmatter:{title:"MVP简介",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/62a8b5/",categories:["Android","项目架构","MVP"],tags:[null],readingShow:"top"},regularPath:"/02.Android/06.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/01.MVP/00.MVP%E7%AE%80%E4%BB%8B.html",relativePath:"02.Android/06.项目架构/01.MVP/00.MVP简介.md",key:"v-5b1d5cfe",path:"/pages/62a8b5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"MVVM简介",frontmatter:{title:"MVVM简介",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/682f56/",categories:["Android","项目架构","MVVM"],tags:[null],readingShow:"top"},regularPath:"/02.Android/06.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/02.MVVM/00.MVVM%E7%AE%80%E4%BB%8B.html",relativePath:"02.Android/06.项目架构/02.MVVM/00.MVVM简介.md",key:"v-c2aabbf8",path:"/pages/682f56/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"MVI简介",frontmatter:{title:"MVI简介",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/4a6933/",categories:["Android","项目架构","MVI"],tags:[null],readingShow:"top"},regularPath:"/02.Android/06.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/03.MVI/00.MVI%E7%AE%80%E4%BB%8B.html",relativePath:"02.Android/06.项目架构/03.MVI/00.MVI简介.md",key:"v-c835727c",path:"/pages/4a6933/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"性能优化简介",frontmatter:{title:"性能优化简介",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/4c3f68/",categories:["Android","性能优化"],tags:[null],readingShow:"top"},regularPath:"/02.Android/07.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/00.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B.html",relativePath:"02.Android/07.性能优化/00.性能优化简介.md",key:"v-92baed56",path:"/pages/4c3f68/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Gradle简介",frontmatter:{title:"Gradle简介",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/e4244a/",categories:["Android","编码工具","Gradle"],tags:[null],readingShow:"top"},regularPath:"/02.Android/08.%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7/00.Gradle/00.Gradle%E7%AE%80%E4%BB%8B.html",relativePath:"02.Android/08.编码工具/00.Gradle/00.Gradle简介.md",key:"v-5eeceb01",path:"/pages/e4244a/",headersStr:null,content:"# Gradle基础",normalizedContent:"# gradle基础",charsets:{cjk:!0},lastUpdated:"10/29/2022",lastUpdatedTimestamp:166704324e4},{title:"AndroidStudio技巧",frontmatter:{title:"AndroidStudio技巧",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/be5e92/",categories:["Android","编码工具","AndroidStudio"],tags:[null],readingShow:"top"},regularPath:"/02.Android/08.%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7/01.AndroidStudio/00.AndroidStudio%E6%8A%80%E5%B7%A7.html",relativePath:"02.Android/08.编码工具/01.AndroidStudio/00.AndroidStudio技巧.md",key:"v-5adcfe41",path:"/pages/be5e92/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"Handler基础",frontmatter:{title:"Handler基础",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/30e044/",categories:["Android","必会原理","消息机制"],tags:[null],readingShow:"top"},regularPath:"/02.Android/09.%E5%BF%85%E4%BC%9A%E5%8E%9F%E7%90%86/00.%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/00.Handler%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/09.必会原理/00.消息机制/00.Handler基础.md",key:"v-e55e3eb4",path:"/pages/30e044/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"IPC基础",frontmatter:{title:"IPC基础",date:"2022-10-10T14:45:25.000Z",permalink:"/pages/c2a627/",categories:["Android","必会原理","IPC"],tags:[null],readingShow:"top"},regularPath:"/02.Android/09.%E5%BF%85%E4%BC%9A%E5%8E%9F%E7%90%86/01.IPC/00.IPC%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/09.必会原理/01.IPC/00.IPC基础.md",key:"v-a44de862",path:"/pages/c2a627/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"屏幕适配基础",frontmatter:{title:"屏幕适配基础",date:"2022-10-10T15:41:22.000Z",permalink:"/pages/e0cd61/",categories:["Android","必会原理","屏幕适配"],tags:[null],readingShow:"top"},regularPath:"/02.Android/09.%E5%BF%85%E4%BC%9A%E5%8E%9F%E7%90%86/02.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/00.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E5%9F%BA%E7%A1%80.html",relativePath:"02.Android/09.必会原理/02.屏幕适配/00.屏幕适配基础.md",key:"v-71a9328d",path:"/pages/e0cd61/",headersStr:null,content:"# 屏幕适配",normalizedContent:"# 屏幕适配",charsets:{cjk:!0},lastUpdated:"10/10/2022",lastUpdatedTimestamp:1665387784e3},{title:"编码规范",frontmatter:{title:"编码规范",date:"2022-12-26T13:43:48.000Z",permalink:"/pages/f80d6c/",categories:["Android","编码规范与技巧"],tags:[null],readingShow:"top"},regularPath:"/02.Android/10.%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%8E%E6%8A%80%E5%B7%A7/00.%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.html",relativePath:"02.Android/10.编码规范与技巧/00.编码规范.md",key:"v-bae276c8",path:"/pages/f80d6c/",headers:[{level:3,title:"AS 规范",slug:"as-规范",normalizedTitle:"as 规范",charIndex:116},{level:3,title:"命名规范",slug:"命名规范",normalizedTitle:"命名规范",charIndex:415},{level:4,title:"包名规范",slug:"包名规范",normalizedTitle:"包名规范",charIndex:556},{level:4,title:"类名规范",slug:"类名规范",normalizedTitle:"类名规范",charIndex:770},{level:4,title:"方法名规范",slug:"方法名规范",normalizedTitle:"方法名规范",charIndex:1966},{level:4,title:"常量名规范",slug:"常量名规范",normalizedTitle:"常量名规范",charIndex:2582},{level:4,title:"非常量字段名规范",slug:"非常量字段名规范",normalizedTitle:"非常量字段名规范",charIndex:3455},{level:5,title:"scope（范围）",slug:"scope-范围",normalizedTitle:"scope（范围）",charIndex:3683},{level:5,title:"Type0（控件类型）",slug:"type0-控件类型",normalizedTitle:"type0（控件类型）",charIndex:4051},{level:5,title:"VariableName（变量名）",slug:"variablename-变量名",normalizedTitle:"variablename（变量名）",charIndex:4597},{level:5,title:"Type1（数据类型）",slug:"type1-数据类型",normalizedTitle:"type1（数据类型）",charIndex:4799},{level:4,title:"参数名规范",slug:"参数名规范",normalizedTitle:"参数名规范",charIndex:4992},{level:4,title:"局部变量名规范",slug:"局部变量名规范",normalizedTitle:"局部变量名规范",charIndex:5042},{level:4,title:"临时变量规范",slug:"临时变量规范",normalizedTitle:"临时变量规范",charIndex:5193},{level:3,title:"代码样式规范",slug:"代码样式规范",normalizedTitle:"代码样式规范",charIndex:5296},{level:4,title:"使用标准大括号样式",slug:"使用标准大括号样式",normalizedTitle:"使用标准大括号样式",charIndex:5306},{level:4,title:"编写简短方法",slug:"编写简短方法",normalizedTitle:"编写简短方法",charIndex:5774},{level:4,title:"类成员的顺序",slug:"类成员的顺序",normalizedTitle:"类成员的顺序",charIndex:5886},{level:4,title:"函数参数的排序",slug:"函数参数的排序",normalizedTitle:"函数参数的排序",charIndex:6970},{level:4,title:"字符串常量的命名和值",slug:"字符串常量的命名和值",normalizedTitle:"字符串常量的命名和值",charIndex:7294},{level:4,title:"Activities 和 Fragments 的传参",slug:"activities-和-fragments-的传参",normalizedTitle:"activities 和 fragments 的传参",charIndex:8106},{level:4,title:"行长限制",slug:"行长限制",normalizedTitle:"行长限制",charIndex:9091},{level:4,title:"换行策略",slug:"换行策略",normalizedTitle:"换行策略",charIndex:9364},{level:5,title:"操作符的换行",slug:"操作符的换行",normalizedTitle:"操作符的换行",charIndex:9427},{level:5,title:"函数链的换行",slug:"函数链的换行",normalizedTitle:"函数链的换行",charIndex:9709},{level:5,title:"多参数的换行",slug:"多参数的换行",normalizedTitle:"多参数的换行",charIndex:9902},{level:5,title:"RxJava 链式的换行",slug:"rxjava-链式的换行",normalizedTitle:"rxjava 链式的换行",charIndex:10088},{level:3,title:"资源文件规范",slug:"资源文件规范",normalizedTitle:"资源文件规范",charIndex:10910},{level:4,title:"动画资源文件（anim/ 和 animator/）",slug:"动画资源文件-anim-和-animator",normalizedTitle:"动画资源文件（anim/ 和 animator/）",charIndex:11239},{level:4,title:"颜色资源文件（color/）",slug:"颜色资源文件-color",normalizedTitle:"颜色资源文件（color/）",charIndex:11765},{level:4,title:"图片资源文件（drawable/ 和 mipmap/）",slug:"图片资源文件-drawable-和-mipmap",normalizedTitle:"图片资源文件（drawable/ 和 mipmap/）",charIndex:11906},{level:4,title:"布局资源文件（layout/）",slug:"布局资源文件-layout",normalizedTitle:"布局资源文件（layout/）",charIndex:13528},{level:4,title:"菜单资源文件（menu/）",slug:"菜单资源文件-menu",normalizedTitle:"菜单资源文件（menu/）",charIndex:13945},{level:4,title:"values 资源文件（values/）",slug:"values-资源文件-values",normalizedTitle:"values 资源文件（values/）",charIndex:14049},{level:5,title:"colors.xml",slug:"colors-xml",normalizedTitle:"colors.xml",charIndex:14107},{level:5,title:"dimens.xml",slug:"dimens-xml",normalizedTitle:"dimens.xml",charIndex:14118},{level:5,title:"strings.xml",slug:"strings-xml",normalizedTitle:"strings.xml",charIndex:null},{level:5,title:"styles.xml",slug:"styles-xml",normalizedTitle:"styles.xml",charIndex:null},{level:4,title:"id 命名",slug:"id-命名",normalizedTitle:"id 命名",charIndex:null},{level:3,title:"版本统一规范",slug:"版本统一规范",normalizedTitle:"版本统一规范",charIndex:null},{level:3,title:"注释规范",slug:"注释规范",normalizedTitle:"注释规范",charIndex:null},{level:4,title:"类注释",slug:"类注释",normalizedTitle:"类注释",charIndex:null},{level:4,title:"方法注释",slug:"方法注释",normalizedTitle:"方法注释",charIndex:null},{level:4,title:"块注释",slug:"块注释",normalizedTitle:"块注释",charIndex:null},{level:4,title:"其他一些注释",slug:"其他一些注释",normalizedTitle:"其他一些注释",charIndex:null}],headersStr:"AS 规范 命名规范 包名规范 类名规范 方法名规范 常量名规范 非常量字段名规范 scope（范围） Type0（控件类型） VariableName（变量名） Type1（数据类型） 参数名规范 局部变量名规范 临时变量规范 代码样式规范 使用标准大括号样式 编写简短方法 类成员的顺序 函数参数的排序 字符串常量的命名和值 Activities 和 Fragments 的传参 行长限制 换行策略 操作符的换行 函数链的换行 多参数的换行 RxJava 链式的换行 资源文件规范 动画资源文件（anim/ 和 animator/） 颜色资源文件（color/） 图片资源文件（drawable/ 和 mipmap/） 布局资源文件（layout/） 菜单资源文件（menu/） values 资源文件（values/） colors.xml dimens.xml strings.xml styles.xml id 命名 版本统一规范 注释规范 类注释 方法注释 块注释 其他一些注释",content:'在维护公司项目时发现，在多人协作的环境中，各式各样的代码风格让人很难下手，无法快速的定位问题位置。结合之前的看法，所以找到比较完善的代码规范，借鉴下来，让自己形成自己的代码规范，日积月累形成习惯。这样子的代码才能拿得出手。\n\n\n# AS 规范\n\n作为安卓开发最常用的开发工具，我们还是需要对它限制一下规范的，但是只是建议\n\n * 尽量使用最新的稳定版的 IDE 进行开发（可以低几个版本，但是不能太老）\n * 编码格式统一为 UTF-8，如果使用其他的编码方式会导致项目出现乱码，很不好看\n * 编辑完 .java、.xml 等文件后一定要 格式化，格式化，格式化（如果团队有公共的样式包，那就遵循它，否则统一使用 AS 默认模板即可）\n * 删除多余的 import，减少警告出现，可利用 AS 的 Optimize Imports（Settings -> Keymap -> Optimize Imports）快捷键\n\n\n# 命名规范\n\n代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解，避免歧义。\n\n> 注意：即使纯拼音命名方式也要避免采用。但 alibaba、taobao、youku、hangzhou 等国际通用的名称，可视同英文。\n\n# 包名规范\n\n包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。另外，分包推荐使用按功能分包 Package By Feature，不太建议按层分包 Package By Layer。\n\n> 按层拆分包就像按专业拆分同事，而不是将他们拆分为组织团队。 想象一下这种荒谬的情况：经理公司、程序员公司、人力资源公司和营销公司，其中程序员公司只有程序员，没有经理、营销人员或人力资源\n\n# 类名规范\n\n类名都以 UpperCamelCase 风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如 HTML、URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。\n\n类                           描述                    例如\nActivity类                   Activity为后缀标识         欢迎页面类 WelcomeActivity\nAdapter类                    Adapter为后缀标识          新闻详情适配器 NewsDetailAdapter\n解析类                         Parser为后缀标识           首页解析类 HomePosterParser\n工具方法类                       Utils或 Manager为后缀标识   线程池管理类：ThreadPoolManager\n日志工具类：LogUtils``Logger也可）                         \n打印工具类：PrinterUtils                                \n数据库类                        以 DBHelper后缀标识        新闻数据库：NewsDBHelper\nService类                    以 Service为后缀标识        时间服务 TimeService\nBroadcastReceiver类          以 Receiver为后缀标识       推送接收 JPushReceiver\nContentProvider类            以 Provider为后缀标识       ShareProvider\n自定义的共享基础类                   以 Base开头              BaseActivity, BaseFragment\n\n测试类的命名以它要测试的类的名称开始，以 Test 结束。例如：HashTest 或 HashIntegrationTest。\n\n接口（interface）：命名规则与类一样采用大驼峰命名法，多以 able 或 ible 结尾，如 interface Runnable、interface Accessible。\n\n> 注意：如果项目采用 MVP，所有 Model、View、Presenter 的接口都以 I 为前缀，不加后缀，其他的接口采用上述命名规则。\n\n# 方法名规范\n\n方法名都以 lowerCamelCase 风格编写。 方法名通常是动词或动词短语。\n\n方法                        说明\ninitXX()                  初始化相关方法，使用 init 为前缀标识，如初始化布局 initView()\nisXX(), checkXX()         方法返回值为 boolean 型的请使用 is/check 为前缀标识\ngetXX()                   返回某个值的方法，使用 get 为前缀标识\nsetXX()                   设置某个属性值\nhandleXX(), processXX()   对数据进行处理的方法\ndisplayXX(), showXX()     弹出提示框和提示信息，使用 display/show 为前缀标识\nupdateXX()                更新数据\nsaveXX(), insertXX()      保存或插入数据\nresetXX()                 重置数据\nclearXX()                 清除数据\nremoveXX(), deleteXX()    移除数据或者视图等，如 removeView()\ndrawXX()                  绘制数据或效果相关的，使用 draw 前缀标识\n\n# 常量名规范\n\n常量名命名模式为 CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量？ 每个常量都是一个 static final 字段，但不是所有 static final 字段都是常量。在决定一个字段是否是一个常量时，得考虑它是否真的感觉像是一个常量。例如，如果观测任何一个该实例的状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变的对象一般是不够的，它要真的一直不变才能将它示为常量。\n\n// Constants\nstatic final int NUMBER = 5;\nstatic final ImmutableListNAMES = ImmutableList.of("Ed", "Ann");\nstatic final Joiner COMMA_JOINER = Joiner.on(\',\'); // because Joiner is immutable\nstatic final SomeMutableType[] EMPTY_ARRAY = {};\nenum SomeEnum { ENUM_CONSTANT }\n\n// Not constants\nstatic String nonFinal = "non-final";\nfinal String nonStatic = "non-static";\nstatic final SetmutableCollection = new HashSet();\nstatic final ImmutableSetmutableElements = ImmutableSet.of(mutable);\nstatic final Logger logger = Logger.getLogger(MyClass.getName());\nstatic final String[] nonEmptyArray = {"these", "can", "change"};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 非常量字段名规范\n\n非常量字段名以 lowerCamelCase 风格的基础上改造为如下风格：基本结构为 scope{Type0}VariableName{Type1}、type0VariableName{Type1}、variableName{Type1}。\n\n说明：{} 中的内容为可选。\n\n> 注意：所有的 VO（值对象）统一采用标准的 lowerCamelCase 风格编写，所有的 DTO（数据传输对象）就按照接口文档中定义的字段名编写。\n\n# scope（范围）\n\n * 非公有，非静态字段命名以 m 开头。\n * 非公有，静态字段命名以 s 开头。\n * 其他字段以小写字母开头。\n\n例如：\n\npublic class MyClass {\n    public int publicField;\n    private static MyClass sSingleton;\n    int mPackagePrivate;\n    private int mPrivate;\n    protected int mProtected;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用 1 个字符前缀来表示作用范围，1 个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。\n\n# Type0（控件类型）\n\n考虑到 Android 众多的 UI 控件，为避免控件和普通成员变量混淆以及更好地表达意思，所有用来表示控件的成员变量统一加上控件缩写作为前缀。 例如：mIvAvatar、rvBooks、flContainer。\n\n名称               缩写\nButton           btn\nCheckBox         cb\nEditText         et\nFrameLayout      fl\nGridView         gv\nImageButton      ib\nImageView        iv\nLinearLayout     ll\nListView         lv\nProgressBar      pb\nRadioButtion     rb\nRecyclerView     rv\nRelativeLayout   rl\nScrollView       sv\nSeekBar          sb\nSpinner          spn\nTextView         tv\nToggleButton     tb\nVideoView        vv\nWebView          wv\n\n# VariableName（变量名）\n\n变量名中可能会出现量词，我们需要创建统一的量词，它们更容易理解，也更容易搜索。 例如：mFirstBook、mPreBook、curBook。\n\n量词列表    量词后缀说明\nFirst   一组变量中的第一个\nLast    一组变量中的最后一个\nNext    一组变量中的下一个\nPre     一组变量中的上一个\nCur     一组变量中的当前变量\n\n# Type1（数据类型）\n\n对于表示集合或者数组的非常量字段名，我们可以添加后缀来增强字段的可读性，比如\n\n * 集合添加如下后缀：List、Map、Set。\n * 数组添加如下后缀：Arr。\n\n例如：mIvAvatarList、userArr、firstNameSet。\n\n> 注意：如果数据类型不确定的话，比如表示的是很多书，那么使用其复数形式来表示也可，例如 mBooks。\n\n# 参数名规范\n\n参数名以 lowerCamelCase 风格编写，参数应该避免用单个字符命名。\n\n# 局部变量名规范\n\n局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。\n\n# 临时变量规范\n\n临时变量通常被取名为 i、j、k、m 和 n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：\n\nfor (int i = 0; i < len; i++) {}\n\n\n1\n\n\n\n# 代码样式规范\n\n# 使用标准大括号样式\n\n左大括号不单独占一行，与其前面的代码位于同一行：\n\nclass MyClass {\n    int func() {\n        if (something) {\n            // ...\n        } else if (somethingElse) {\n            // ...\n        } else {\n            // ...\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们需要在条件语句周围添加大括号。例外情况：如果整个条件语句（条件和主体）适合放在同一行，那么您可以（但不是必须）将其全部放在一行上。例如，我们接受以下样式：\n\nif (condition) {\n    body();\n}\n\n\n1\n2\n3\n\n\n同样也接受以下样式：\n\nif (condition) body();\n\n\n1\n\n\n但不接受以下样式：\n\nif (condition)    body();  // bad!\n\n\n1\n\n\n# 编写简短方法\n\n在可行的情况下，尽量编写短小精炼的方法。我们了解，有些情况下较长的方法是恰当的，因此对方法的代码长度没有做出硬性限制。如果某个方法的代码超出 40 行，请考虑是否可以在不破坏程序结构的前提下对其拆解。\n\n# 类成员的顺序\n\n这并没有唯一的正确解决方案，但如果都使用一致的顺序将会提高代码的可读性，推荐使用如下排序：\n\n * 常量\n * 字段\n * 构造函数\n * 重写函数和回调\n * 公有函数\n * 私有函数\n * 内部类或接口\n\n例如：\n\npublic class MainActivity extends Activity {\n    private static final String TAG = MainActivity.class.getSimpleName();\n    private String mTitle;\n    private TextView mTextViewTitle;\n\n    @Override\n    public void onCreate() {        \n        ...\n    }\n\n    public void setTitle(String title) {\n        mTitle = title;\n    }\n\n    private void setUpView() {       \n        ...\n    }\n\n    static class AnInnerClass {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果类继承于 Android 组件（例如 Activity 或 Fragment），那么把重写函数按照他们的生命周期进行排序是一个非常好的习惯，例如，Activity 实现了 onCreate()、onDestroy()、onPause()、onResume()，它的正确排序如下所示：\n\npublic class MainActivity extends Activity {\n    //Order matches Activity lifecycle    \n    @Override\n    public void onCreate() {\n    }\n\n    @Override\n    public void onResume() {\n    }\n\n    @Override\n    public void onPause() {\n    }\n\n    @Override\n    public void onDestroy() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 函数参数的排序\n\n在 Android 开发过程中，Context 在函数参数中是再常见不过的了，我们最好把 Context 作为其第一个参数。 正相反，我们把回调接口应该作为其最后一个参数。例如：\n\n    // Context always goes first\n    public User loadUser(Context context, int userId);\n    \n    // Callbacks always go last\n    public void loadUserAsync(Context context, int userId, UserCallback callback);\n\n\n1\n2\n3\n4\n5\n\n\n# 字符串常量的命名和值\n\nAndroid SDK 中的很多类都用到了键值对函数，比如SharedPreferences、Bundle、Intent，所以，即便是一个小应用，我们最终也不得不编写大量的字符串常量。 当时用到这些类的时候，我们 必须 将它们的键定义为 static final 字段，并遵循以下指示作为前缀。\n\n类                    字段名前缀\nSharedPreferences    PREF_\nBundle               BUNDLE_\nFragment Arguments   ARGUMENT_\nIntent Extra         EXTRA_\nIntent Action        ACTION_\n\n说明：虽然 Fragment.getArguments() 得到的也是 Bundle ，但因为这是 Bundle 的常用用法，所以特意为此定义一个不同的前缀。 例如：\n\n    // 注意：字段的值与名称相同以避免重复问题\n    static final String PREF_EMAIL = "PREF_EMAIL";\n    static final String BUNDLE_AGE = "BUNDLE_AGE";\n    static final String ARGUMENT_USER_ID = "ARGUMENT_USER_ID";\n    // 与意图相关的项使用完整的包名作为值的前缀\n    static final String EXTRA_SURNAME = "com.myapp.extras.EXTRA_SURNAME";\n    static final String ACTION_OPEN_USER = "com.myapp.action.ACTION_OPEN_USER";\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# Activities 和 Fragments 的传参\n\n当 Activity 或 Fragment 传递数据通过 Intent 或 Bundle 时，不同值的键须遵循上一条所提及到的。 当 Activity 或 Fragment 启动需要传递参数时，那么它需要提供一个 public static 的函数来帮助启动或创建它。 这方面，AS 已帮你写好了相关的 Live Templates，启动相关 Activity 的只需要在其内部输入 starter 即可生成它的启动器，如下所示：\n\n    public static void start(Context context, User user) {\n        Intent starter = new Intent(context, MainActivity.class);\n        starter.putParcelableExtra(EXTRA_USER, user);\n        context.startActivity(starter);\n    }\n\n\n1\n2\n3\n4\n5\n\n\n同理，启动相关 Fragment 在其内部输入 newInstance 即可，如下所示：\n\n    public static MainFragment newInstance(User user) {\n        Bundle args = new Bundle();\n        args.putParcelable(ARGUMENT_USER, user);\n        MainFragment fragment = new MainFragment();\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在kotlin中没有快捷指令，需要我们自己去新建一个 Live Templates。具体的实现方式在这里就不细说了，有心可以去自己学习下。\n\n> 注意：这些函数需要放在 onCreate() 之前的类的顶部；如果我们使用了这种方式，那么 extras 和 arguments 的键应该是 private 的，因为它们不再需要暴露给其他类来使用。\n\n# 行长限制\n\n代码中每一行文本的长度都应该不超过 100 个字符。虽然关于此规则存在很多争论，但最终决定仍是以 100 个字符为上限，如果行长超过了 100（AS 窗口右侧的竖线就是设置的行宽末尾 ），我们通常有两种方法来缩减行长\n\n * 提取一个局部变量或方法（最好）。\n * 使用换行符将一行换成多行。\n\n不过存在以下例外情况：\n\n * 如果备注行包含长度超过 100 个字符的示例命令或文字网址，那么为了便于剪切和粘贴，该行可以超过 100 个字符。\n * 导入语句行可以超出此限制，因为用户很少会看到它们（这也简化了工具编写流程）。\n\n# 换行策略\n\n这没有一个准确的解决方案来决定如何换行，通常不同的解决方案都是有效的，但是有一些规则可以应用于常见的情况。\n\n# 操作符的换行\n\n除赋值操作符之外，我们把换行符放在操作符之前，例如：\n\nint longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne\n        + theFinalOne;\n\n\n1\n2\n\n\n赋值操作符的换行我们放在其后，例如：\n\nint longName =\n        anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne;\n\n\n1\n2\n\n\n# 函数链的换行\n\n当同一行中调用多个函数时（比如使用构建器时），对每个函数的调用应该在新的一行中，我们把换行符插入在 . 之前。例如：\n\n    Picasso.with(context)\n            .load("https://blankj.com/images/avatar.jpg")\n            .into(ivAvatar);\n\n\n1\n2\n3\n\n\n# 多参数的换行\n\n当一个方法有很多参数或者参数很长的时候，我们应该在每个 , 后面进行换行。比如：\n\n    loadPicture(context,"https://blankj.com/images/avatar.jpg",ivAvatar,\n                "Avatar of the user",clickListener);\n\n\n1\n2\n\n\n# RxJava 链式的换行\n\nRxJava 的每个操作符都需要换新行，并且把换行符插入在 . 之前。例如：\n\n    public Observable<Location> syncLocations() {\n        return mDatabaseHelper\n                .getAllLocations()\n                .concatMap(new Func1<Location, Observable<? extends Location>>() {\n                    @Override\n                    public Observable<? extends Location> call(Location location) {\n                        return mRetrofitService.getLocation(location.id);\n                    }\n                })\n                .retry(new Func2<Integer, Throwable, Boolean>() {\n                    @Override\n                    public Boolean call(Integer numRetries, Throwable throwable) {\n                        return throwable instanceof RetrofitError;\n                    }\n                });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 资源文件规范\n\n资源文件命名为全部小写，采用下划线命名法。 如果想对资源文件进行分包可以参考下面的方法 方法很简单，配置我们的app文件夹下的 build.gradle 文件，比如我的\n\nandroid {    \n        ...\n            sourceSets {\n            main {\n                res.srcDirs(\'src/main/res\', \'src/main/res_core\', \'src/main/res_sub\')\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n配置完之后，sync project 一下就成功了。\n\n# 动画资源文件（anim/ 和 animator/）\n\n安卓主要包含属性动画和视图动画，其视图动画包括补间动画和逐帧动画。属性动画文件需要放在 res/animator/ 目录下，视图动画文件需放在 res/anim/ 目录下。\n\n命名规则：{模块名_}逻辑名称。 说明：{} 中的内容为可选，逻辑名称 可由多个单词加下划线组成。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。\n\n如果是普通的补间动画或者属性动画，可采用：动画类型_方向 的命名方式。例如：\n\n名称                  说明\nfade_in             淡入\nfade_out            淡出\npush_down_in        从下方推入\npush_down_out       从下方推出\npush_left           推向左方\nslide_in_from_top   从头部滑动进入\nzoom_enter          变形进入\nslide_in            滑动进入\nshrink_to_middle    中间缩小\n\n# 颜色资源文件（color/）\n\n专门存放颜色相关的资源文件。\n\n**命名规则：**类型_逻辑名称。 例如：sel_btn_font.xml。\n\n颜色资源也可以放于 res/drawable/ 目录，引用时则用 @drawable 来引用，但不推荐这么做，最好还是把两者分开。\n\n# 图片资源文件（drawable/ 和 mipmap/）\n\nres/drawable/ 目录下放的是位图文件（.png、.9.png、.jpg、.gif）或编译为可绘制对象资源子类型的 XML 文件，而 res/mipmap/ 目录下放的是不同密度的启动图标，所以 res/mipmap/ 只用于存放启动图标，其余图片资源文件都应该放到 res/drawable/ 目录下。\n\n命名规则：类型{_模块名}_逻辑名称、类型{_模块名}_颜色。 说明：{} 中的内容为可选；类型 可以是可绘制对象资源类型，也可以是控件类型（命令规范>非常量字段名规范>Type0）；最后可加后缀 _small 表示小图，_big 表示大图。 例如：\n\n名称                        说明\nbtn_main_about.png        主页关于按键 类型_模块名_逻辑名称\nbtn_back.png              返回按键 类型_逻辑名称\ndivider_maket_white.png   商城白色分割线 类型_模块名_颜色\nic_edit.png               编辑图标 类型_逻辑名称\nbg_main.png               主页背景 类型_逻辑名称\nbtn_red.png               红色按键 类型_颜色\nbtn_red_big.png           红色大按键 类型_颜色\nic_head_small.png         小头像图标 类型_逻辑名称\nbg_input.png              输入框背景 类型_逻辑名称\ndivider_white.png         白色分割线 类型_颜色\nbg_main_head.png          主页头部背景 类型_模块名_逻辑名称\ndef_search_cell.png       搜索页面默认单元图片 类型_模块名_逻辑名称\nic_more_help.png          更多帮助图标 类型_逻辑名称\ndivider_list_line.png     列表分割线 类型_逻辑名称\nsel_search_ok.xml         搜索界面确认选择器 类型_模块名_逻辑名称\nshape_music_ring.xml      音乐界面环形形状 类型_模块名_逻辑名称\n\n如果有多种形态，如按钮选择器：sel_btn_xx.xml，采用如下命名：\n\n名称                      说明\nsel_btn_xx              作用在 btn_xx上的 selector\nbtn_xx_normal           默认状态效果\nbtn_xx_pressed          state_pressed点击效果\nbtn_xx_focused          state_focused聚焦效果\nbtn_xx_disabled         state_enabled不可用效果\nbtn_xx_checked          state_checked选中效果\nbtn_xx_selected         state_selected选中效果\nbtn_xx_hovered          state_hovered悬停效果\nbtn_xx_checkable        state_checkable可选效果\nbtn_xx_activated        state_activated激活效果\nbtn_xx_window_focused   state_window_focused窗口聚焦效果\n\n> 注意：使用 Android Studio 的插件 SelectorChapek 可以快速生成 selector，前提是命名要规范。\n\n# 布局资源文件（layout/）\n\n命名规则：类型_模块名、类型{_模块名}_逻辑名称。 说明：{} 中的内容为可选。\n\n例如：\n\n名称                          说明\nactivity_main.xml           主窗体 类型_模块名\nactivity_main_head.xml      主窗体头部 类型_模块名_逻辑名称\nfragment_music.xml          音乐片段 类型_模块名\nfragment_music_player.xml   音乐片段的播放器 类型_模块名_逻辑名称\ndialog_loading.xml          加载对话框 类型_逻辑名称\nppw_info.xml                信息弹窗（PopupWindow） 类型_逻辑名称\nitem_main_song.xml          主页歌曲列表项 类型_模块名_逻辑名称\n\n# 菜单资源文件（menu/）\n\n菜单相关的资源文件应放在该目录下。\n\n命名规则：{模块名_}逻辑名称 说明：{} 中的内容为可选。\n\n例如：main_drawer.xml、navigation.xml。\n\n# values 资源文件（values/）\n\nvalues/ 资源文件下的文件都以 s 结尾，如 attrs.xml、colors.xml、dimens.xml。 起作用的不是文件名称，而是 标签下的各种标签。 比如',normalizedContent:'在维护公司项目时发现，在多人协作的环境中，各式各样的代码风格让人很难下手，无法快速的定位问题位置。结合之前的看法，所以找到比较完善的代码规范，借鉴下来，让自己形成自己的代码规范，日积月累形成习惯。这样子的代码才能拿得出手。\n\n\n# as 规范\n\n作为安卓开发最常用的开发工具，我们还是需要对它限制一下规范的，但是只是建议\n\n * 尽量使用最新的稳定版的 ide 进行开发（可以低几个版本，但是不能太老）\n * 编码格式统一为 utf-8，如果使用其他的编码方式会导致项目出现乱码，很不好看\n * 编辑完 .java、.xml 等文件后一定要 格式化，格式化，格式化（如果团队有公共的样式包，那就遵循它，否则统一使用 as 默认模板即可）\n * 删除多余的 import，减少警告出现，可利用 as 的 optimize imports（settings -> keymap -> optimize imports）快捷键\n\n\n# 命名规范\n\n代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解，避免歧义。\n\n> 注意：即使纯拼音命名方式也要避免采用。但 alibaba、taobao、youku、hangzhou 等国际通用的名称，可视同英文。\n\n# 包名规范\n\n包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。另外，分包推荐使用按功能分包 package by feature，不太建议按层分包 package by layer。\n\n> 按层拆分包就像按专业拆分同事，而不是将他们拆分为组织团队。 想象一下这种荒谬的情况：经理公司、程序员公司、人力资源公司和营销公司，其中程序员公司只有程序员，没有经理、营销人员或人力资源\n\n# 类名规范\n\n类名都以 uppercamelcase 风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如 html、url，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。\n\n类                           描述                    例如\nactivity类                   activity为后缀标识         欢迎页面类 welcomeactivity\nadapter类                    adapter为后缀标识          新闻详情适配器 newsdetailadapter\n解析类                         parser为后缀标识           首页解析类 homeposterparser\n工具方法类                       utils或 manager为后缀标识   线程池管理类：threadpoolmanager\n日志工具类：logutils``logger也可）                         \n打印工具类：printerutils                                \n数据库类                        以 dbhelper后缀标识        新闻数据库：newsdbhelper\nservice类                    以 service为后缀标识        时间服务 timeservice\nbroadcastreceiver类          以 receiver为后缀标识       推送接收 jpushreceiver\ncontentprovider类            以 provider为后缀标识       shareprovider\n自定义的共享基础类                   以 base开头              baseactivity, basefragment\n\n测试类的命名以它要测试的类的名称开始，以 test 结束。例如：hashtest 或 hashintegrationtest。\n\n接口（interface）：命名规则与类一样采用大驼峰命名法，多以 able 或 ible 结尾，如 interface runnable、interface accessible。\n\n> 注意：如果项目采用 mvp，所有 model、view、presenter 的接口都以 i 为前缀，不加后缀，其他的接口采用上述命名规则。\n\n# 方法名规范\n\n方法名都以 lowercamelcase 风格编写。 方法名通常是动词或动词短语。\n\n方法                        说明\ninitxx()                  初始化相关方法，使用 init 为前缀标识，如初始化布局 initview()\nisxx(), checkxx()         方法返回值为 boolean 型的请使用 is/check 为前缀标识\ngetxx()                   返回某个值的方法，使用 get 为前缀标识\nsetxx()                   设置某个属性值\nhandlexx(), processxx()   对数据进行处理的方法\ndisplayxx(), showxx()     弹出提示框和提示信息，使用 display/show 为前缀标识\nupdatexx()                更新数据\nsavexx(), insertxx()      保存或插入数据\nresetxx()                 重置数据\nclearxx()                 清除数据\nremovexx(), deletexx()    移除数据或者视图等，如 removeview()\ndrawxx()                  绘制数据或效果相关的，使用 draw 前缀标识\n\n# 常量名规范\n\n常量名命名模式为 constant_case，全部字母大写，用下划线分隔单词。那到底什么算是一个常量？ 每个常量都是一个 static final 字段，但不是所有 static final 字段都是常量。在决定一个字段是否是一个常量时，得考虑它是否真的感觉像是一个常量。例如，如果观测任何一个该实例的状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变的对象一般是不够的，它要真的一直不变才能将它示为常量。\n\n// constants\nstatic final int number = 5;\nstatic final immutablelistnames = immutablelist.of("ed", "ann");\nstatic final joiner comma_joiner = joiner.on(\',\'); // because joiner is immutable\nstatic final somemutabletype[] empty_array = {};\nenum someenum { enum_constant }\n\n// not constants\nstatic string nonfinal = "non-final";\nfinal string nonstatic = "non-static";\nstatic final setmutablecollection = new hashset();\nstatic final immutablesetmutableelements = immutableset.of(mutable);\nstatic final logger logger = logger.getlogger(myclass.getname());\nstatic final string[] nonemptyarray = {"these", "can", "change"};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 非常量字段名规范\n\n非常量字段名以 lowercamelcase 风格的基础上改造为如下风格：基本结构为 scope{type0}variablename{type1}、type0variablename{type1}、variablename{type1}。\n\n说明：{} 中的内容为可选。\n\n> 注意：所有的 vo（值对象）统一采用标准的 lowercamelcase 风格编写，所有的 dto（数据传输对象）就按照接口文档中定义的字段名编写。\n\n# scope（范围）\n\n * 非公有，非静态字段命名以 m 开头。\n * 非公有，静态字段命名以 s 开头。\n * 其他字段以小写字母开头。\n\n例如：\n\npublic class myclass {\n    public int publicfield;\n    private static myclass ssingleton;\n    int mpackageprivate;\n    private int mprivate;\n    protected int mprotected;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用 1 个字符前缀来表示作用范围，1 个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。\n\n# type0（控件类型）\n\n考虑到 android 众多的 ui 控件，为避免控件和普通成员变量混淆以及更好地表达意思，所有用来表示控件的成员变量统一加上控件缩写作为前缀。 例如：mivavatar、rvbooks、flcontainer。\n\n名称               缩写\nbutton           btn\ncheckbox         cb\nedittext         et\nframelayout      fl\ngridview         gv\nimagebutton      ib\nimageview        iv\nlinearlayout     ll\nlistview         lv\nprogressbar      pb\nradiobuttion     rb\nrecyclerview     rv\nrelativelayout   rl\nscrollview       sv\nseekbar          sb\nspinner          spn\ntextview         tv\ntogglebutton     tb\nvideoview        vv\nwebview          wv\n\n# variablename（变量名）\n\n变量名中可能会出现量词，我们需要创建统一的量词，它们更容易理解，也更容易搜索。 例如：mfirstbook、mprebook、curbook。\n\n量词列表    量词后缀说明\nfirst   一组变量中的第一个\nlast    一组变量中的最后一个\nnext    一组变量中的下一个\npre     一组变量中的上一个\ncur     一组变量中的当前变量\n\n# type1（数据类型）\n\n对于表示集合或者数组的非常量字段名，我们可以添加后缀来增强字段的可读性，比如\n\n * 集合添加如下后缀：list、map、set。\n * 数组添加如下后缀：arr。\n\n例如：mivavatarlist、userarr、firstnameset。\n\n> 注意：如果数据类型不确定的话，比如表示的是很多书，那么使用其复数形式来表示也可，例如 mbooks。\n\n# 参数名规范\n\n参数名以 lowercamelcase 风格编写，参数应该避免用单个字符命名。\n\n# 局部变量名规范\n\n局部变量名以 lowercamelcase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。\n\n# 临时变量规范\n\n临时变量通常被取名为 i、j、k、m 和 n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：\n\nfor (int i = 0; i < len; i++) {}\n\n\n1\n\n\n\n# 代码样式规范\n\n# 使用标准大括号样式\n\n左大括号不单独占一行，与其前面的代码位于同一行：\n\nclass myclass {\n    int func() {\n        if (something) {\n            // ...\n        } else if (somethingelse) {\n            // ...\n        } else {\n            // ...\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们需要在条件语句周围添加大括号。例外情况：如果整个条件语句（条件和主体）适合放在同一行，那么您可以（但不是必须）将其全部放在一行上。例如，我们接受以下样式：\n\nif (condition) {\n    body();\n}\n\n\n1\n2\n3\n\n\n同样也接受以下样式：\n\nif (condition) body();\n\n\n1\n\n\n但不接受以下样式：\n\nif (condition)    body();  // bad!\n\n\n1\n\n\n# 编写简短方法\n\n在可行的情况下，尽量编写短小精炼的方法。我们了解，有些情况下较长的方法是恰当的，因此对方法的代码长度没有做出硬性限制。如果某个方法的代码超出 40 行，请考虑是否可以在不破坏程序结构的前提下对其拆解。\n\n# 类成员的顺序\n\n这并没有唯一的正确解决方案，但如果都使用一致的顺序将会提高代码的可读性，推荐使用如下排序：\n\n * 常量\n * 字段\n * 构造函数\n * 重写函数和回调\n * 公有函数\n * 私有函数\n * 内部类或接口\n\n例如：\n\npublic class mainactivity extends activity {\n    private static final string tag = mainactivity.class.getsimplename();\n    private string mtitle;\n    private textview mtextviewtitle;\n\n    @override\n    public void oncreate() {        \n        ...\n    }\n\n    public void settitle(string title) {\n        mtitle = title;\n    }\n\n    private void setupview() {       \n        ...\n    }\n\n    static class aninnerclass {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果类继承于 android 组件（例如 activity 或 fragment），那么把重写函数按照他们的生命周期进行排序是一个非常好的习惯，例如，activity 实现了 oncreate()、ondestroy()、onpause()、onresume()，它的正确排序如下所示：\n\npublic class mainactivity extends activity {\n    //order matches activity lifecycle    \n    @override\n    public void oncreate() {\n    }\n\n    @override\n    public void onresume() {\n    }\n\n    @override\n    public void onpause() {\n    }\n\n    @override\n    public void ondestroy() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 函数参数的排序\n\n在 android 开发过程中，context 在函数参数中是再常见不过的了，我们最好把 context 作为其第一个参数。 正相反，我们把回调接口应该作为其最后一个参数。例如：\n\n    // context always goes first\n    public user loaduser(context context, int userid);\n    \n    // callbacks always go last\n    public void loaduserasync(context context, int userid, usercallback callback);\n\n\n1\n2\n3\n4\n5\n\n\n# 字符串常量的命名和值\n\nandroid sdk 中的很多类都用到了键值对函数，比如sharedpreferences、bundle、intent，所以，即便是一个小应用，我们最终也不得不编写大量的字符串常量。 当时用到这些类的时候，我们 必须 将它们的键定义为 static final 字段，并遵循以下指示作为前缀。\n\n类                    字段名前缀\nsharedpreferences    pref_\nbundle               bundle_\nfragment arguments   argument_\nintent extra         extra_\nintent action        action_\n\n说明：虽然 fragment.getarguments() 得到的也是 bundle ，但因为这是 bundle 的常用用法，所以特意为此定义一个不同的前缀。 例如：\n\n    // 注意：字段的值与名称相同以避免重复问题\n    static final string pref_email = "pref_email";\n    static final string bundle_age = "bundle_age";\n    static final string argument_user_id = "argument_user_id";\n    // 与意图相关的项使用完整的包名作为值的前缀\n    static final string extra_surname = "com.myapp.extras.extra_surname";\n    static final string action_open_user = "com.myapp.action.action_open_user";\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# activities 和 fragments 的传参\n\n当 activity 或 fragment 传递数据通过 intent 或 bundle 时，不同值的键须遵循上一条所提及到的。 当 activity 或 fragment 启动需要传递参数时，那么它需要提供一个 public static 的函数来帮助启动或创建它。 这方面，as 已帮你写好了相关的 live templates，启动相关 activity 的只需要在其内部输入 starter 即可生成它的启动器，如下所示：\n\n    public static void start(context context, user user) {\n        intent starter = new intent(context, mainactivity.class);\n        starter.putparcelableextra(extra_user, user);\n        context.startactivity(starter);\n    }\n\n\n1\n2\n3\n4\n5\n\n\n同理，启动相关 fragment 在其内部输入 newinstance 即可，如下所示：\n\n    public static mainfragment newinstance(user user) {\n        bundle args = new bundle();\n        args.putparcelable(argument_user, user);\n        mainfragment fragment = new mainfragment();\n        fragment.setarguments(args);\n        return fragment;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在kotlin中没有快捷指令，需要我们自己去新建一个 live templates。具体的实现方式在这里就不细说了，有心可以去自己学习下。\n\n> 注意：这些函数需要放在 oncreate() 之前的类的顶部；如果我们使用了这种方式，那么 extras 和 arguments 的键应该是 private 的，因为它们不再需要暴露给其他类来使用。\n\n# 行长限制\n\n代码中每一行文本的长度都应该不超过 100 个字符。虽然关于此规则存在很多争论，但最终决定仍是以 100 个字符为上限，如果行长超过了 100（as 窗口右侧的竖线就是设置的行宽末尾 ），我们通常有两种方法来缩减行长\n\n * 提取一个局部变量或方法（最好）。\n * 使用换行符将一行换成多行。\n\n不过存在以下例外情况：\n\n * 如果备注行包含长度超过 100 个字符的示例命令或文字网址，那么为了便于剪切和粘贴，该行可以超过 100 个字符。\n * 导入语句行可以超出此限制，因为用户很少会看到它们（这也简化了工具编写流程）。\n\n# 换行策略\n\n这没有一个准确的解决方案来决定如何换行，通常不同的解决方案都是有效的，但是有一些规则可以应用于常见的情况。\n\n# 操作符的换行\n\n除赋值操作符之外，我们把换行符放在操作符之前，例如：\n\nint longname = anotherverylongvariable + anevenlongerone - thisridiculouslongone\n        + thefinalone;\n\n\n1\n2\n\n\n赋值操作符的换行我们放在其后，例如：\n\nint longname =\n        anotherverylongvariable + anevenlongerone - thisridiculouslongone + thefinalone;\n\n\n1\n2\n\n\n# 函数链的换行\n\n当同一行中调用多个函数时（比如使用构建器时），对每个函数的调用应该在新的一行中，我们把换行符插入在 . 之前。例如：\n\n    picasso.with(context)\n            .load("https://blankj.com/images/avatar.jpg")\n            .into(ivavatar);\n\n\n1\n2\n3\n\n\n# 多参数的换行\n\n当一个方法有很多参数或者参数很长的时候，我们应该在每个 , 后面进行换行。比如：\n\n    loadpicture(context,"https://blankj.com/images/avatar.jpg",ivavatar,\n                "avatar of the user",clicklistener);\n\n\n1\n2\n\n\n# rxjava 链式的换行\n\nrxjava 的每个操作符都需要换新行，并且把换行符插入在 . 之前。例如：\n\n    public observable<location> synclocations() {\n        return mdatabasehelper\n                .getalllocations()\n                .concatmap(new func1<location, observable<? extends location>>() {\n                    @override\n                    public observable<? extends location> call(location location) {\n                        return mretrofitservice.getlocation(location.id);\n                    }\n                })\n                .retry(new func2<integer, throwable, boolean>() {\n                    @override\n                    public boolean call(integer numretries, throwable throwable) {\n                        return throwable instanceof retrofiterror;\n                    }\n                });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 资源文件规范\n\n资源文件命名为全部小写，采用下划线命名法。 如果想对资源文件进行分包可以参考下面的方法 方法很简单，配置我们的app文件夹下的 build.gradle 文件，比如我的\n\nandroid {    \n        ...\n            sourcesets {\n            main {\n                res.srcdirs(\'src/main/res\', \'src/main/res_core\', \'src/main/res_sub\')\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n配置完之后，sync project 一下就成功了。\n\n# 动画资源文件（anim/ 和 animator/）\n\n安卓主要包含属性动画和视图动画，其视图动画包括补间动画和逐帧动画。属性动画文件需要放在 res/animator/ 目录下，视图动画文件需放在 res/anim/ 目录下。\n\n命名规则：{模块名_}逻辑名称。 说明：{} 中的内容为可选，逻辑名称 可由多个单词加下划线组成。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。\n\n如果是普通的补间动画或者属性动画，可采用：动画类型_方向 的命名方式。例如：\n\n名称                  说明\nfade_in             淡入\nfade_out            淡出\npush_down_in        从下方推入\npush_down_out       从下方推出\npush_left           推向左方\nslide_in_from_top   从头部滑动进入\nzoom_enter          变形进入\nslide_in            滑动进入\nshrink_to_middle    中间缩小\n\n# 颜色资源文件（color/）\n\n专门存放颜色相关的资源文件。\n\n**命名规则：**类型_逻辑名称。 例如：sel_btn_font.xml。\n\n颜色资源也可以放于 res/drawable/ 目录，引用时则用 @drawable 来引用，但不推荐这么做，最好还是把两者分开。\n\n# 图片资源文件（drawable/ 和 mipmap/）\n\nres/drawable/ 目录下放的是位图文件（.png、.9.png、.jpg、.gif）或编译为可绘制对象资源子类型的 xml 文件，而 res/mipmap/ 目录下放的是不同密度的启动图标，所以 res/mipmap/ 只用于存放启动图标，其余图片资源文件都应该放到 res/drawable/ 目录下。\n\n命名规则：类型{_模块名}_逻辑名称、类型{_模块名}_颜色。 说明：{} 中的内容为可选；类型 可以是可绘制对象资源类型，也可以是控件类型（命令规范>非常量字段名规范>type0）；最后可加后缀 _small 表示小图，_big 表示大图。 例如：\n\n名称                        说明\nbtn_main_about.png        主页关于按键 类型_模块名_逻辑名称\nbtn_back.png              返回按键 类型_逻辑名称\ndivider_maket_white.png   商城白色分割线 类型_模块名_颜色\nic_edit.png               编辑图标 类型_逻辑名称\nbg_main.png               主页背景 类型_逻辑名称\nbtn_red.png               红色按键 类型_颜色\nbtn_red_big.png           红色大按键 类型_颜色\nic_head_small.png         小头像图标 类型_逻辑名称\nbg_input.png              输入框背景 类型_逻辑名称\ndivider_white.png         白色分割线 类型_颜色\nbg_main_head.png          主页头部背景 类型_模块名_逻辑名称\ndef_search_cell.png       搜索页面默认单元图片 类型_模块名_逻辑名称\nic_more_help.png          更多帮助图标 类型_逻辑名称\ndivider_list_line.png     列表分割线 类型_逻辑名称\nsel_search_ok.xml         搜索界面确认选择器 类型_模块名_逻辑名称\nshape_music_ring.xml      音乐界面环形形状 类型_模块名_逻辑名称\n\n如果有多种形态，如按钮选择器：sel_btn_xx.xml，采用如下命名：\n\n名称                      说明\nsel_btn_xx              作用在 btn_xx上的 selector\nbtn_xx_normal           默认状态效果\nbtn_xx_pressed          state_pressed点击效果\nbtn_xx_focused          state_focused聚焦效果\nbtn_xx_disabled         state_enabled不可用效果\nbtn_xx_checked          state_checked选中效果\nbtn_xx_selected         state_selected选中效果\nbtn_xx_hovered          state_hovered悬停效果\nbtn_xx_checkable        state_checkable可选效果\nbtn_xx_activated        state_activated激活效果\nbtn_xx_window_focused   state_window_focused窗口聚焦效果\n\n> 注意：使用 android studio 的插件 selectorchapek 可以快速生成 selector，前提是命名要规范。\n\n# 布局资源文件（layout/）\n\n命名规则：类型_模块名、类型{_模块名}_逻辑名称。 说明：{} 中的内容为可选。\n\n例如：\n\n名称                          说明\nactivity_main.xml           主窗体 类型_模块名\nactivity_main_head.xml      主窗体头部 类型_模块名_逻辑名称\nfragment_music.xml          音乐片段 类型_模块名\nfragment_music_player.xml   音乐片段的播放器 类型_模块名_逻辑名称\ndialog_loading.xml          加载对话框 类型_逻辑名称\nppw_info.xml                信息弹窗（popupwindow） 类型_逻辑名称\nitem_main_song.xml          主页歌曲列表项 类型_模块名_逻辑名称\n\n# 菜单资源文件（menu/）\n\n菜单相关的资源文件应放在该目录下。\n\n命名规则：{模块名_}逻辑名称 说明：{} 中的内容为可选。\n\n例如：main_drawer.xml、navigation.xml。\n\n# values 资源文件（values/）\n\nvalues/ 资源文件下的文件都以 s 结尾，如 attrs.xml、colors.xml、dimens.xml。 起作用的不是文件名称，而是 标签下的各种标签。 比如',charsets:{cjk:!0},lastUpdated:"10/15/2022",lastUpdatedTimestamp:1665831563e3},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:46:30.000Z",permalink:"/pages/caba2c/",categories:["iOS"],tags:[null],readingShow:"top"},regularPath:"/03.iOS/00.%E6%B5%8B%E8%AF%95.html",relativePath:"03.iOS/00.测试.md",key:"v-d12388be",path:"/pages/caba2c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:46:33.000Z",permalink:"/pages/5d9ede/",categories:["前端"],tags:[null],readingShow:"top"},regularPath:"/04.%E5%89%8D%E7%AB%AF/00.%E6%B5%8B%E8%AF%95.html",relativePath:"04.前端/00.测试.md",key:"v-6207de52",path:"/pages/5d9ede/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:47:18.000Z",permalink:"/pages/dd157d/",categories:["软实力","效率工具"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%BD%AF%E5%AE%9E%E5%8A%9B/01.%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/00.%E6%B5%8B%E8%AF%95.html",relativePath:"05.软实力/01.效率工具/00.测试.md",key:"v-7413e683",path:"/pages/dd157d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:47:18.000Z",permalink:"/pages/c9ee07/",categories:["软实力","调试工具"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%BD%AF%E5%AE%9E%E5%8A%9B/02.%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/00.%E6%B5%8B%E8%AF%95.html",relativePath:"05.软实力/02.调试工具/00.测试.md",key:"v-546e9ad7",path:"/pages/c9ee07/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:47:18.000Z",permalink:"/pages/c22b04/",categories:["软实力","版本控制"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%BD%AF%E5%AE%9E%E5%8A%9B/03.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/00.%E6%B5%8B%E8%AF%95.html",relativePath:"05.软实力/03.版本控制/00.测试.md",key:"v-f32c04aa",path:"/pages/c22b04/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"测试",frontmatter:{title:"测试",date:"2022-10-10T14:47:18.000Z",permalink:"/pages/0a00bd/",categories:["软实力","画图表达"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%BD%AF%E5%AE%9E%E5%8A%9B/04.%E7%94%BB%E5%9B%BE%E8%A1%A8%E8%BE%BE/00.%E6%B5%8B%E8%AF%95.html",relativePath:"05.软实力/04.画图表达/00.测试.md",key:"v-6c0f4a9d",path:"/pages/0a00bd/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/10/2022",lastUpdatedTimestamp:166538501e4},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-2957f703",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"7/25/2022",lastUpdatedTimestamp:1658728355e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-a9a3f93a",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"7/25/2022",lastUpdatedTimestamp:1658728355e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-34308afa",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"7/25/2022",lastUpdatedTimestamp:1658728355e3},{title:"Home",frontmatter:{home:!0,heroText:"极速cv",tagline:"CV操作好，下班就是早",bannerBg:"/img/bg.png",readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-7ecc48c8",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"10/7/2022",lastUpdatedTimestamp:1665160742e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"编程基础",link:"/article/"},{text:"Android",link:"/note/"},{text:"iOS",link:"/idea/"},{text:"前端",link:"/other/"},{text:"软实力",link:"/favorites/"}],sidebarDepth:2,logo:"/img/logo.png",repo:"CatCatBug/fastcv-blog",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!1,editLinkText:"编辑",sidebar:{"/00.目录页/":[["01. 编程基础.md","编程基础","/article"],["02.Android.md","Android","/note"],["03.iOS.md","iOS","/idea"],["04.前端.md","前端","/other"],["05.软实力.md","软实力","/favorites"]],catalogue:{" 编程基础":"/article",Android:"/note",iOS:"/idea","前端":"/other","软实力":"/favorites"},"/01.编程基础/":[{title:"数据结构与算法",collapsable:!0,children:[["01.数据结构与算法/00.测试.md","测试","/pages/43d909/"],{title:"数据结构",collapsable:!0,children:[["01.数据结构与算法/01.数据结构/00.线性表.md","线性表","/pages/e8e456/"]]}]},{title:"计算机组成原理",collapsable:!0,children:[["02.计算机组成原理/00.测试.md","测试","/pages/be0b6b/"]]},{title:"操作系统",collapsable:!0,children:[["03.操作系统/00.测试.md","测试","/pages/540b0e/"]]},{title:"网络",collapsable:!0,children:[["04.网络/00.测试.md","测试","/pages/e5a034/"]]},{title:"数据库原理",collapsable:!0,children:[["05.数据库原理/00.测试.md","测试","/pages/f6820e/"]]},{title:"C语言",collapsable:!0,children:[["06.C语言/00.测试.md","测试","/pages/586d36/"]]},{title:"Java",collapsable:!0,children:[["07.Java/00.JavaPoet的学习使用.md","JavaPoet的学习使用","/pages/1e535d/"],["07.Java/01.Java反射.md","Java反射","/pages/8f05cf/"],["07.Java/02.Java集合.md","Java集合","/pages/767133/"],["07.Java/03.Java正则表达式.md","Java正则表达式","/pages/88149c/"],["07.Java/04.Properties的学习.md","Properties的学习","/pages/2882fd/"]]},{title:"Kotlin",collapsable:!0,children:[["08.Kotlin/00.测试.md","测试","/pages/870746/"]]},{title:"Dart",collapsable:!0,children:[["09.Dart/00.测试.md","测试","/pages/96e35a/"]]},{title:"C++",collapsable:!0,children:[["10.C++/00.测试.md","测试","/pages/952ffa/"]]},{title:"Js",collapsable:!0,children:[["11.Js/00.测试.md","测试","/pages/478433/"]]}],"/02.Android/":[{title:"四大组件",collapsable:!0,children:[{title:"Application",collapsable:!0,children:[["00.四大组件/00.Application/00.Application基础.md","Application基础","/pages/0d8b25/"]]},{title:"Activity",collapsable:!0,children:[["00.四大组件/01.Activity/00.Activity基础.md","Activity基础","/pages/67f43d/"]]},{title:"BroadcastReceiver",collapsable:!0,children:[["00.四大组件/02.BroadcastReceiver/00.广播基础.md","广播基础","/pages/73feed/"]]},{title:"ContentProvider",collapsable:!0,children:[["00.四大组件/03.ContentProvider/00.内容提供者基础.md","内容提供者基础","/pages/f49146/"]]},{title:"Service",collapsable:!0,children:[["00.四大组件/04.Service/00.服务基础.md","服务基础","/pages/575d07/"]]},["00.四大组件/05.Intent-filter.md","Intent-filter","/pages/3e5b1b/"],["00.四大组件/06.URL与URI基础.md","URL与URI基础","/pages/f7396a/"]]},{title:"Fragment",collapsable:!0,children:[["01.Fragment/00.Fragment基础.md","Fragment基础","/pages/208508/"]]},{title:"UI控件",collapsable:!0,children:[{title:"基础布局",collapsable:!0,children:[["02.UI控件/00.基础布局/00.RelativeLayout.md","RelativeLayout","/pages/095150/"]]},{title:"基础控件",collapsable:!0,children:[["02.UI控件/01.基础控件/00.TextView.md","TextView","/pages/868569/"]]},{title:"ListView",collapsable:!0,children:[["02.UI控件/02.ListView/00.ListView基础.md","ListView基础","/pages/8c2382/"]]},{title:"自定义控件",collapsable:!0,children:[["02.UI控件/03.自定义控件/00.基础常识.md","基础常识","/pages/442ac8/"]]},{title:"弹窗",collapsable:!0,children:[["02.UI控件/04.弹窗/00.Dialog.md","Dialog","/pages/14a2f5/"],["02.UI控件/04.弹窗/01.Notification.md","Notification","/pages/4f989a/"],["02.UI控件/04.弹窗/02.PopupWindow.md","PopupWindow","/pages/5a9638/"],["02.UI控件/04.弹窗/03.Toast.md","Toast","/pages/1e4f68/"]]},{title:"WebView",collapsable:!0,children:[["02.UI控件/05.WebView/00.WebView基础.md","WebView基础","/pages/6e1c4a/"]]},{title:"自定义控件",collapsable:!0,children:[["02.UI控件/06.自定义控件/00.基础常识.md","基础常识","/pages/60a9ae/"]]},{title:"弹窗",collapsable:!0,children:[["02.UI控件/07.弹窗/00.Dialog.md","Dialog","/pages/914d16/"],["02.UI控件/07.弹窗/01.Notification.md","Notification","/pages/1ed6d5/"],["02.UI控件/07.弹窗/02.PopupWindow.md","PopupWindow","/pages/808803/"],["02.UI控件/07.弹窗/03.Toast.md","Toast","/pages/ee3e32/"]]},{title:"动画",collapsable:!0,children:[["02.UI控件/08.动画/00.View动画.md","View动画","/pages/f616c6/"],["02.UI控件/08.动画/01.属性动画.md","属性动画","/pages/d4d3f1/"],["02.UI控件/08.动画/02.转场动画.md","转场动画","/pages/0cffc9/"]]}]},{title:"数据持久化",collapsable:!0,children:[{title:"文件",collapsable:!0,children:[["03.数据持久化/00.文件/00.安卓文件基础.md","安卓文件基础","/pages/61d3af/"]]},{title:"数据库",collapsable:!0,children:[["03.数据持久化/01.数据库/00.SQLite基础.md","SQLite基础","/pages/fc8ccf/"]]},{title:"SharedPreferences",collapsable:!0,children:[["03.数据持久化/02.SharedPreferences/00.SharedPreferences基础.md","SharedPreferences基础","/pages/42bd30/"]]}]},{title:"传感器及连接性",collapsable:!0,children:[{title:"传感器",collapsable:!0,children:[["04.传感器及连接性/00.传感器/00.传感器基础介绍.md","传感器基础介绍","/pages/9f8db9/"]]},{title:"连接性",collapsable:!0,children:[["04.传感器及连接性/01.连接性/00.蓝牙.md","蓝牙","/pages/f75c98/"],["04.传感器及连接性/01.连接性/01.NFC.md","NFC","/pages/f8d0da/"],["04.传感器及连接性/01.连接性/02.低功耗蓝牙.md","低功耗蓝牙","/pages/4db516/"]]}]},{title:"三方框架",collapsable:!0,children:[{title:"OkHttp",collapsable:!0,children:[["05.三方框架/00.OkHttp/00.OkHttp基础.md","OkHttp基础","/pages/e006e9/"]]},{title:"Retrofit",collapsable:!0,children:[["05.三方框架/01.Retrofit/00.Retrofit基础.md","Retrofit基础","/pages/0886e5/"]]},{title:"Glide",collapsable:!0,children:[["05.三方框架/02.Glide/00.Glide基础.md","Glide基础","/pages/16acab/"]]},{title:"koin",collapsable:!0,children:[["05.三方框架/05.koin/00.Koin基础.md","Koin基础","/pages/a69c33/"]]}]},{title:"项目架构",collapsable:!0,children:[{title:"MVC",collapsable:!0,children:[["06.项目架构/00.MVC/00.MVC简介.md","MVC简介","/pages/d2011c/"]]},{title:"MVP",collapsable:!0,children:[["06.项目架构/01.MVP/00.MVP简介.md","MVP简介","/pages/62a8b5/"]]},{title:"MVVM",collapsable:!0,children:[["06.项目架构/02.MVVM/00.MVVM简介.md","MVVM简介","/pages/682f56/"]]},{title:"MVI",collapsable:!0,children:[["06.项目架构/03.MVI/00.MVI简介.md","MVI简介","/pages/4a6933/"]]}]},{title:"性能优化",collapsable:!0,children:[["07.性能优化/00.性能优化简介.md","性能优化简介","/pages/4c3f68/"]]},{title:"编码工具",collapsable:!0,children:[{title:"Gradle",collapsable:!0,children:[["08.编码工具/00.Gradle/00.Gradle简介.md","Gradle简介","/pages/e4244a/"]]},{title:"AndroidStudio",collapsable:!0,children:[["08.编码工具/01.AndroidStudio/00.AndroidStudio技巧.md","AndroidStudio技巧","/pages/be5e92/"]]}]},{title:"必会原理",collapsable:!0,children:[{title:"消息机制",collapsable:!0,children:[["09.必会原理/00.消息机制/00.Handler基础.md","Handler基础","/pages/30e044/"]]},{title:"IPC",collapsable:!0,children:[["09.必会原理/01.IPC/00.IPC基础.md","IPC基础","/pages/c2a627/"]]},{title:"屏幕适配",collapsable:!0,children:[["09.必会原理/02.屏幕适配/00.屏幕适配基础.md","屏幕适配基础","/pages/e0cd61/"]]}]},{title:"编码规范与技巧",collapsable:!0,children:[["10.编码规范与技巧/00.编码规范.md","编码规范","/pages/f80d6c/"]]}],"/03.iOS/":[["00.测试.md","测试","/pages/caba2c/"]],"/04.前端/":[["00.测试.md","测试","/pages/5d9ede/"]],"/05.软实力/":[{title:"效率工具",collapsable:!0,children:[["01.效率工具/00.测试.md","测试","/pages/dd157d/"]]},{title:"调试工具",collapsable:!0,children:[["02.调试工具/00.测试.md","测试","/pages/c9ee07/"]]},{title:"版本控制",collapsable:!0,children:[["03.版本控制/00.测试.md","测试","/pages/c22b04/"]]},{title:"画图表达",collapsable:!0,children:[["04.画图表达/00.测试.md","测试","/pages/0a00bd/"]]}]},author:{name:"fastcv",link:"https://fastcv.cc/"},blogger:{avatar:"/img/logo.png",name:"极速cv",slogan:"CV操作就是好~"},social:{icons:[{iconClass:"icon-github",title:"Star我",link:"https://github.com/CatCatBug/fastcv-blog"},{iconClass:"icon-erji",title:"有品位的歌单",link:"https://music.163.com/playlist?id=5161366267"}]},footer:{createYear:2021,copyrightInfo:'极速cv | <a href="https://beian.miit.gov.cn/" target="_blank" style="font-weight:normal">粤ICP备2022111699号-1</a> '},htmlModules:{homeSidebarB:'<ins class="adsbygoogle"\n     style="display:block"\n     data-ad-client="ca-pub-8621788234752924"\n     data-ad-slot="9814056513"\n     data-ad-format="auto"\n     data-full-width-responsive="true"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n<\/script>',sidebarB:'<ins class="adsbygoogle"\n     style="display:block"\n     data-ad-client="ca-pub-8621788234752924"\n     data-ad-slot="8498052873"\n     data-ad-format="auto"\n     data-full-width-responsive="true"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n<\/script>',pageB:'</br><ins class="adsbygoogle"\n     style="display:block; text-align:center;"\n     data-ad-layout="in-article"\n     data-ad-format="auto"\n     data-ad-client="ca-pub-8621788234752924"\n     data-ad-slot="7043271566"></ins>\n<script>\n     (adsbygoogle = window.adsbygoogle || []).push({});\n<\/script>',pageBshowMode:"article"}},locales:{"/":{lang:"zh-CN",title:"极速cv",description:"CV操作好，下班就是早。",path:"/"}}};var Ac=t(97),xc=t(98),_c=t(11);var wc={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(_c.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(_c.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(_c.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,i=n.length;a<i;a++){const{frontmatter:{categories:i,tags:r}}=n[a];"array"===Object(_c.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(_c.n)(r)&&r.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(Ac.default),Vt.component(xc.default);function Sc(n){return n.toString().padStart(2,"0")}t(244);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,420))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,97))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,98)));t(245);var Ec={name:"ReadingProgress",data:()=>({readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}),watch:{$readingShow(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:()=>Math.max(document.body.scrollHeight,document.body.offsetHeight,0),getScreenHeight:()=>Math.max(window.innerHeight,document.documentElement.clientHeight,0),getReadingTop:()=>Math.max(window.pageYOffset,document.documentElement.scrollTop,0),getTransform(){const n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find(e=>e in n.style)||void 0},getProgressStyle(){const n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?`${this.transform}: scaleX(${n})`:`width: ${100*n}%`;case"left":case"right":return this.transform?`${this.transform}: scaleY(${n})`:`height: ${100*n}%`;default:return null}}}},Ic=(t(246),Object(gc.a)(Ec,(function(){var n=this._self._c;return n("ClientOnly",[this.$readingShow?n("div",{staticClass:"reading-progress",class:this.$readingShow},[n("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),Cc=(t(247),t(96)),Tc=t.n(Cc),Bc=t(28);let Pc,Rc;var jc;"valine"===(jc="gitalk")?t.e(87).then(t.t.bind(null,335,7)).then(n=>Rc=n.default):"gitalk"===jc&&Promise.all([t.e(0),t.e(86)]).then(t.t.bind(null,336,7)).then(()=>t.e(85).then(t.t.bind(null,337,7))).then(n=>Pc=n.default);function Mc(n,e){const t={};return Reflect.ownKeys(n).forEach(a=>{if("string"==typeof n[a])try{t[a]=Tc.a.render(n[a],e)}catch(e){console.warn(`Comment config option error at key named "${a}"`),console.warn("More info: "+e.message),t[a]=n[a]}else t[a]=n[a]}),t}console.log(`How to use "gitalk" in ${Bc.name}@v${Bc.version}:`,Bc.homepage);const Lc={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Pc(Mc({clientID:"6f97ead0ad58265e7b9d",clientSecret:"13cb77ec7655cc71161ab8fcc1cc53d963c9df2b",repo:"fastcv-blog",owner:"CatCatBug",admin:["CatCatBug"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Rc({...Mc({clientID:"6f97ead0ad58265e7b9d",clientSecret:"13cb77ec7655cc71161ab8fcc1cc53d963c9df2b",repo:"fastcv-blog",owner:"CatCatBug",admin:["CatCatBug"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Oc="vuepress-plugin-comment";let Dc=null;function Nc(n){return Lc.gitalk.clear(Oc)}function zc(n){return!1!==n.comment&&!1!==n.comments}function Uc(n){clearTimeout(Dc);if(document.querySelector("main.page"))return Lc.gitalk.render(n,Oc);Dc=setTimeout(()=>Uc(n),200)}var $c={mounted(){Dc=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Nc()&&zc(n)&&Uc(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Nc()&&zc(t)&&Uc(t)})}},Fc=Object(gc.a)($c,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Hc=[({Vue:n,options:e,router:t,siteData:a})=>{},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Sc(n.getUTCMonth()+1)}-${Sc(n.getUTCDate())} ${Sc(n.getUTCHours())}:${Sc(n.getUTCMinutes())}:${Sc(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(wc)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({Vue:n})=>{n.component(Ic.name,Ic),n.mixin({computed:{$readingShow(){return this.$page.frontmatter.readingShow}}})},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?3a2a89979f0938d6ac21f967d18b9f3e";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Fc)}],qc=["ReadingProgress","Comment"];class Wc extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Wc.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:cs,getVueComponent:ls});var Vc={install(n){const e=new Wc;n.$vuepress=e,n.prototype.$vuepress=e}};function Jc(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Gc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Vt.component(e)||Vt.component(e,os(e)),Vt.component(e)?n(e):n("")}},Kc={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Yc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Xc=(t(253),t(254),Object(gc.a)(Yc,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Zc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(qo),Vt.use(Vc),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),r={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),r),{computed:r}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},kc)),Vt.component("Content",Gc),Vt.component("ContentSlotsDistributor",Kc),Vt.component("OutboundLink",Xc),Vt.component("ClientOnly",Zc),Vt.component("Layout",ss("Layout")),Vt.component("NotFound",ss("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"90c4f74"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:kc.routerBase||kc.base,t=new qo({base:e,mode:"history",fallback:!1,routes:yc,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Jc(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Jc(n,t)?a(t):a()}else a();else{const t=e.path+"/",i=e.path+".html";Jc(n,i)?a(i):Jc(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Hc.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:a,router:t,siteData:kc,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},qc.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);