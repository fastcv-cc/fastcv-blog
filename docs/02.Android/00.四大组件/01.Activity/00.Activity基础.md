---
title: Activity基础
date: 2022-10-10 14:28:27
permalink: /pages/67f43d/
categories:
  - Android
  - 四大组件
  - Activity
tags:
  - 
---

# 写在前面
Activity说实话，没有啥新点可以说的了，毕竟我也不是大佬。

一篇新的文章无非就是在别人的基础上加上自己的理解，糅合整理出来的。如果非要弄点新的点子出来，无非是遇到问题之后，在解决问题的过程中的产生的新的理解；
又或者是在研究源码的时候突然找到了一些不一样的认知观点。

那在没有以上两种情况的情况下，再来产出一篇关于Activity的文章（或者说笔记，因为可能只有自己能理解）确实是有点浪费时间和精力。

那为啥还要写呢？ emmmmmmmmmmmmmmm... 因为我在想，既然文章这么多了，不在乎我再糅合一次了，那我在官方文档的基础上面，结合众多大佬的理解，
整一篇精细的笔记出来，然后附上常用的代码段，是不是下次不用再查了。CV就是香！！！

# 简介
我觉得不需要简介了，因为我也讲不清楚它到底是什么？

从代码层次看，它是个基类，我们实现一个新的界面的时候就是从继承它开始，然后结合的它生命周期的接口进行功能开发。

从它的职责上看，它就是一个用户交互界面，负责处理用户的点击、滑动、输入等事件并给出相应的UI效果响应。

从设计的角度来看，它是窗口(Window)的给出来的代理使者，将复杂的UI相关的数据处理集成在底层， 然后提供上层一个简单的接口``` setContentView(R.layout.activity_main) ```来实现界面的搭建。

所以，它的基本使用很简单，我们开发者只需要简单一行代码就可以写个界面在手机上跑出效果来了。跑出来的这个界面就是Activity。

# 配置清单
如果，你新建了一个Activity，代码都写好了，然后运行的时候闪退。不妨想想是不是没在Manifest清单文件中配置当前Activity。
```xml
    <manifest ... >
      <application ... >
          <activity android:name=".ExampleActivity" />
          ...
      </application ... >
      ...
    </manifest >
```


又或者说，我是新手，我配置了，也运行了，但是我不知道这个里面
```xml
<activity android:name=".ExampleActivity" />
```
**name**指代的是什么？看其他代码有其他的标签，它们都是啥？有啥用？



额，这个问题，我上网一查全是答案，既然你诚心诚意的问了，那我就CV一下告诉你吧。

这个是activity标签元素支持的属性（如果你不明白，可以先学学XML相关的知识），比如``` android:name ``` 就是activity元素唯一的必要属性，用于指定 Activity 的类名称。还有很多相关属性，我这里就不一一自己写了。我直接CVCVCVCV.....



## activity元素属性

### 语法

```
<activity android:allowEmbedded=["true" | "false"]
          android:allowTaskReparenting=["true" | "false"]
          android:alwaysRetainTaskState=["true" | "false"]
          android:autoRemoveFromRecents=["true" | "false"]
          android:banner="drawable resource"
          android:clearTaskOnLaunch=["true" | "false"]
          android:colorMode=[ "hdr" | "wideColorGamut"]
          android:configChanges=["mcc", "mnc", "locale",
                                 "touchscreen", "keyboard", "keyboardHidden",
                                 "navigation", "screenLayout", "fontScale",
                                 "uiMode", "orientation", "density",
                                 "screenSize", "smallestScreenSize"]
          android:directBootAware=["true" | "false"]
          android:documentLaunchMode=["intoExisting" | "always" |
                                  "none" | "never"]
          android:enabled=["true" | "false"]
          android:excludeFromRecents=["true" | "false"]
          android:exported=["true" | "false"]
          android:finishOnTaskLaunch=["true" | "false"]
          android:hardwareAccelerated=["true" | "false"]
          android:icon="drawable resource"
          android:immersive=["true" | "false"]
          android:label="string resource"
          android:launchMode=["standard" | "singleTop" |
                              "singleTask" | "singleInstance" | "singleInstancePerTask"]
          android:lockTaskMode=["normal" | "never" |
                              "if_whitelisted" | "always"]
          android:maxRecents="integer"
          android:maxAspectRatio="float"
          android:multiprocess=["true" | "false"]
          android:name="string"
          android:noHistory=["true" | "false"]  
          android:parentActivityName="string" 
          android:persistableMode=["persistRootOnly" | 
                                   "persistAcrossReboots" | "persistNever"]
          android:permission="string"
          android:process="string"
          android:relinquishTaskIdentity=["true" | "false"]
          android:resizeableActivity=["true" | "false"]
          android:screenOrientation=["unspecified" | "behind" |
                                     "landscape" | "portrait" |
                                     "reverseLandscape" | "reversePortrait" |
                                     "sensorLandscape" | "sensorPortrait" |
                                     "userLandscape" | "userPortrait" |
                                     "sensor" | "fullSensor" | "nosensor" |
                                     "user" | "fullUser" | "locked"]
          android:showForAllUsers=["true" | "false"]
          android:stateNotNeeded=["true" | "false"]
          android:supportsPictureInPicture=["true" | "false"]
          android:taskAffinity="string"
          android:theme="resource or theme"
          android:uiOptions=["none" | "splitActionBarWhenNarrow"]
          android:windowSoftInputMode=["stateUnspecified",
                                       "stateUnchanged", "stateHidden",
                                       "stateAlwaysHidden", "stateVisible",
                                       "stateAlwaysVisible", "adjustUnspecified",
                                       "adjustResize", "adjustPan"] >   
    . . .
</activity>
```

嘶~   是有点多呀。懒得看，直接Ctrl + F搜关键字。



### 属性

#### android:allowEmbedded

表示该 activity 可作为其他 activity 的嵌入式子项启动。此属性尤其适用于子项位于其他 Activity 所拥有容器（如 Display）中的情况。例如，用于 Wear 自定义通知的 activity 必须声明此属性，以便 Wear 在其位于另一进程内的上下文流中显示 activity。

此属性的默认值为 `false`。（我没用到过）





#### android:alwaysRetainTaskState

系统是否始终保持 Activity 所在任务的状态 -“`true`”表示是，“`false`”表示允许系统在特定情况下将任务重置到其初始状态。默认值为“`false`”。该属性只对任务的根 activity 有意义；所有其他 activity 均忽略该属性。

正常情况下，当用户从主屏幕重新选择某个任务时，系统会在特定情况下清除该任务（从根 Activity 上的堆栈中移除所有 Activity）。通常，如果用户在一段时间（如 30 分钟）内未访问任务，系统会执行此操作。

不过，如果该属性的值是“`true`”，则无论用户如何返回任务，该任务始终会显示最后一次的状态。例如，该属性非常适用于网络浏览器这类应用，因为其中存在大量用户不愿丢失的状态（如多个打开的标签页）。



客户要求Home键退出app时再次打开时要重现界面，最开始想的每次打开activity就将activity放入集合中，操作难度很大也很麻烦。后来发现android:alwaysRetainTaskState这个属性。

这个属性用来标记应用的task是否保持原来的状态，“true”表示总是保持，“false”表示不能够保证，默认为“false”。此属性只对task的根Activity起作用，其他的Activity都会被忽略。 默认情况下，如果一个应用在后台呆的太久例如30分钟，用户从主选单再次选择该应用时，系统就会对该应用的task进行清理，除了根Activity，其他Activity都会被清除出栈，但是如果在根Activity中设置了此属性之后，用户再次启动应用时，仍然可以看到上一次操作的界面。 这个属性对于一些应用非常有用，例如Browser应用程序，有很多状态，比如打开很多的tab，用户不想丢失这些状态，使用这个属性就极为恰当。

写的多么详细，但是我加上后发现并不是这样的。Home键后再次进入一样会从引导页加载，而不是打开退出页。这就很尴尬了。研究发现注意一下几点：

1.android:alwaysRetainTaskState要设置在根Activity下，比如

LaunchActivity----》MainActivity-----》A-------》B-------》主需要在LaunchActivity设置就可以，当然MainActivity设置也可能，因为一般我们的LaunchActivity没什么东西。
2.必须不能有android:launchMode="singleTask"和“singleInstance”。因为LaunchActivity和MainActivity只打开一次，最开始

LaunchActivity是android:launchMode="singleInstance"，MainActivity是singleTask，发现android:alwaysRetainTaskState无效，当LaunchActivity和MainActivity启动模式删掉或者设置为singleTop的时候生效了
还发发现一个比较好玩的方法

moveTaskToBack(true);
这个方法竟然会打开通知栏



#### android:autoRemoveFromRecents

由具有该属性的 Activity 启动的任务是否一直保留在最近任务中，直至任务中的最后一个 Activity 完成为止。若为 `true`，则自动从概览屏幕中移除任务。它会替换调用方使用的 `FLAG_ACTIVITY_RETAIN_IN_RECENTS`。它必须是布尔值“`true`”或“`false`”。



#### android:clearTaskOnLaunch

是否每当从主屏幕重新启动任务时都从中移除根 activity 之外的所有 activity -“`true`”表示始终将任务清除到只剩其根 activity；“`false`”表示不做清除。默认值为“`false`”。该属性只对启动新任务的 activity（根 activity）有意义；任务中的所有其他 activity 均可忽略该属性。

若值为“`true`”，则每次当用户再次启动任务时，无论用户最后在任务中正在执行哪个 Activity，也无论用户是使用“返回”还是“主屏幕”按钮离开，系统都会将用户转至任务的根 Activity。当值为“`false`”时，可在某些情况下清除任务中的 Activity（请参阅 `alwaysRetainTaskState` 属性），但也有例外。

例如，假设用户从主屏幕启动 Activity P，然后从该处转到 Activity Q。接着，该用户按下*主屏幕*，然后返回到 Activity P。正常情况下，用户将看到 Activity Q，因为这是其最后在 P 的任务中所执行的 Activity。不过，如果 P 将此标志设置为“`true`”，当用户从主屏幕启动 activity P 时，系统会移除 P 上方的所有 activity（在本例中为 Q）。因此用户在返回任务时只会看到 P。

如果该属性和 `allowTaskReparenting` 的值均为“`true`”，则如上所述，任何可更改父项的 Activity 都将转移至与其有相似性的任务；而其余 Activity 随即会被移除。

如果未设置 `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED`，系统将忽略此属性。



#### android:allowTaskReparenting

allowTaskReparenting属性的作用是Activity的迁移。当allowTaskReparenting属性和TaskAffinity配合使用时，Activity可以从一个任务栈迁移到另一个任务栈。

迁移的规则是：从一个与该Activity TaskAffinity属性不同的任务栈中迁移到与它TaskAffinity相同的任务栈中。

举个例子：当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性设置为true，那么当应用B被启动，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。
 具体点来说，现在有两个应用A和B，A启动了B的一个Activity C，然后按Home键回到桌面，然后再单击B的桌面图标，这个时候不是启动了B的主Activity，而是重新显示了已经被应用A启动的Activity C。我们也可以理解为，C从A的任务栈转移到了B的任务栈中。
 可以这么理解，由于A启动了C，这个时候C只能运行在A的任务栈中，但是C属于B应用，正常情况下，它的TaskAffinity值肯定不可能和A的任务栈相同，所以当B启动后，B会创建自己的任务栈，这个时候系统发现C原本想要的任务栈已经创建了，所以就把C从A的任务栈中转移过来了。



