---
title: Activity基础
date: 2022-10-10 14:28:27
permalink: /pages/67f43d/
categories:
  - Android
  - 四大组件
  - Activity
tags:
  - 
---

# 写在前面
Activity说实话，没有啥新点可以说的了，毕竟我也不是大佬。

一篇新的文章无非就是在别人的基础上加上自己的理解，糅合整理出来的。如果非要弄点新的点子出来，无非是遇到问题之后，在解决问题的过程中的产生的新的理解；
又或者是在研究源码的时候突然找到了一些不一样的认知观点。

那在没有以上两种情况的情况下，再来产出一篇关于Activity的文章（或者说笔记，因为可能只有自己能理解）确实是有点浪费时间和精力。

那为啥还要写呢？ emmmmmmmmmmmmmmm... 因为我在想，既然文章这么多了，不在乎我再糅合一次了，那我在官方文档的基础上面，结合众多大佬的理解，
整一篇精细的笔记出来，然后附上常用的代码段，是不是下次不用再查了。CV就是香！！！

# 简介
我觉得不需要简介了，因为我也讲不清楚它到底是什么？

从代码层次看，它是个基类，我们实现一个新的界面的时候就是从继承它开始，然后结合的它生命周期的接口进行功能开发。

从它的职责上看，它就是一个用户交互界面，负责处理用户的点击、滑动、输入等事件并给出相应的UI效果响应。

从设计的角度来看，它是窗口(Window)的给出来的代理使者，将复杂的UI相关的数据处理集成在底层， 然后提供上层一个简单的接口``` setContentView(R.layout.activity_main) ```来实现界面的搭建。

所以，它的基本使用很简单，我们开发者只需要简单一行代码就可以写个界面在手机上跑出效果来了。跑出来的这个界面就是Activity。

# 配置清单
如果，你新建了一个Activity，代码都写好了，然后运行的时候闪退。不妨想想是不是没在Manifest清单文件中配置当前Activity。
```xml
    <manifest ... >
      <application ... >
          <activity android:name=".ExampleActivity" />
          ...
      </application ... >
      ...
    </manifest >
```


又或者说，我是新手，我配置了，也运行了，但是我不知道这个里面
```xml
<activity android:name=".ExampleActivity" />
```
**name**指代的是什么？看其他代码有其他的标签，它们都是啥？有啥用？



额，这个问题，我上网一查全是答案，既然你诚心诚意的问了，那我就CV一下告诉你吧。

这个是activity标签元素支持的属性（如果你不明白，可以先学学XML相关的知识），比如``` android:name ``` 就是activity元素唯一的必要属性，用于指定 Activity 的类名称。还有很多相关属性，我这里就不一一自己写了。我直接CVCVCVCV.....



## activity元素属性

### 语法

```
<activity android:allowEmbedded=["true" | "false"]
          android:allowTaskReparenting=["true" | "false"]
          android:alwaysRetainTaskState=["true" | "false"]
          android:autoRemoveFromRecents=["true" | "false"]
          android:banner="drawable resource"
          android:clearTaskOnLaunch=["true" | "false"]
          android:colorMode=[ "hdr" | "wideColorGamut"]
          android:configChanges=["mcc", "mnc", "locale",
                                 "touchscreen", "keyboard", "keyboardHidden",
                                 "navigation", "screenLayout", "fontScale",
                                 "uiMode", "orientation", "density",
                                 "screenSize", "smallestScreenSize"]
          android:directBootAware=["true" | "false"]
          android:documentLaunchMode=["intoExisting" | "always" |
                                  "none" | "never"]
          android:enabled=["true" | "false"]
          android:excludeFromRecents=["true" | "false"]
          android:exported=["true" | "false"]
          android:finishOnTaskLaunch=["true" | "false"]
          android:hardwareAccelerated=["true" | "false"]
          android:icon="drawable resource"
          android:immersive=["true" | "false"]
          android:label="string resource"
          android:launchMode=["standard" | "singleTop" |
                              "singleTask" | "singleInstance" | "singleInstancePerTask"]
          android:lockTaskMode=["normal" | "never" |
                              "if_whitelisted" | "always"]
          android:maxRecents="integer"
          android:maxAspectRatio="float"
          android:multiprocess=["true" | "false"]
          android:name="string"
          android:noHistory=["true" | "false"]  
          android:parentActivityName="string" 
          android:persistableMode=["persistRootOnly" | 
                                   "persistAcrossReboots" | "persistNever"]
          android:permission="string"
          android:process="string"
          android:relinquishTaskIdentity=["true" | "false"]
          android:resizeableActivity=["true" | "false"]
          android:screenOrientation=["unspecified" | "behind" |
                                     "landscape" | "portrait" |
                                     "reverseLandscape" | "reversePortrait" |
                                     "sensorLandscape" | "sensorPortrait" |
                                     "userLandscape" | "userPortrait" |
                                     "sensor" | "fullSensor" | "nosensor" |
                                     "user" | "fullUser" | "locked"]
          android:showForAllUsers=["true" | "false"]
          android:stateNotNeeded=["true" | "false"]
          android:supportsPictureInPicture=["true" | "false"]
          android:taskAffinity="string"
          android:theme="resource or theme"
          android:uiOptions=["none" | "splitActionBarWhenNarrow"]
          android:windowSoftInputMode=["stateUnspecified",
                                       "stateUnchanged", "stateHidden",
                                       "stateAlwaysHidden", "stateVisible",
                                       "stateAlwaysVisible", "adjustUnspecified",
                                       "adjustResize", "adjustPan"] >   
    . . .
</activity>
```

嘶~   是有点多呀。懒得看，直接Ctrl + F搜关键字。



### 属性

#### android:allowEmbedded

表示该 activity 可作为其他 activity 的嵌入式子项启动。此属性尤其适用于子项位于其他 Activity 所拥有容器（如 Display）中的情况。例如，用于 Wear 自定义通知的 activity 必须声明此属性，以便 Wear 在其位于另一进程内的上下文流中显示 activity。

此属性的默认值为 `false`。（我没用到过）





#### android:alwaysRetainTaskState

系统是否始终保持 Activity 所在任务的状态 -“`true`”表示是，“`false`”表示允许系统在特定情况下将任务重置到其初始状态。默认值为“`false`”。该属性只对任务的根 activity 有意义；所有其他 activity 均忽略该属性。

正常情况下，当用户从主屏幕重新选择某个任务时，系统会在特定情况下清除该任务（从根 Activity 上的堆栈中移除所有 Activity）。通常，如果用户在一段时间（如 30 分钟）内未访问任务，系统会执行此操作。

不过，如果该属性的值是“`true`”，则无论用户如何返回任务，该任务始终会显示最后一次的状态。例如，该属性非常适用于网络浏览器这类应用，因为其中存在大量用户不愿丢失的状态（如多个打开的标签页）。



客户要求Home键退出app时再次打开时要重现界面，最开始想的每次打开activity就将activity放入集合中，操作难度很大也很麻烦。后来发现android:alwaysRetainTaskState这个属性。

这个属性用来标记应用的task是否保持原来的状态，“true”表示总是保持，“false”表示不能够保证，默认为“false”。此属性只对task的根Activity起作用，其他的Activity都会被忽略。 默认情况下，如果一个应用在后台呆的太久例如30分钟，用户从主选单再次选择该应用时，系统就会对该应用的task进行清理，除了根Activity，其他Activity都会被清除出栈，但是如果在根Activity中设置了此属性之后，用户再次启动应用时，仍然可以看到上一次操作的界面。 这个属性对于一些应用非常有用，例如Browser应用程序，有很多状态，比如打开很多的tab，用户不想丢失这些状态，使用这个属性就极为恰当。

写的多么详细，但是我加上后发现并不是这样的。Home键后再次进入一样会从引导页加载，而不是打开退出页。这就很尴尬了。研究发现注意一下几点：

1.android:alwaysRetainTaskState要设置在根Activity下，比如

LaunchActivity----》MainActivity-----》A-------》B-------》主需要在LaunchActivity设置就可以，当然MainActivity设置也可能，因为一般我们的LaunchActivity没什么东西。
2.必须不能有android:launchMode="singleTask"和“singleInstance”。因为LaunchActivity和MainActivity只打开一次，最开始

LaunchActivity是android:launchMode="singleInstance"，MainActivity是singleTask，发现android:alwaysRetainTaskState无效，当LaunchActivity和MainActivity启动模式删掉或者设置为singleTop的时候生效了
还发发现一个比较好玩的方法

moveTaskToBack(true);
这个方法竟然会打开通知栏



#### android:autoRemoveFromRecents

由具有该属性的 Activity 启动的任务是否一直保留在最近任务中，直至任务中的最后一个 Activity 完成为止。若为 `true`，则自动从概览屏幕中移除任务。它会替换调用方使用的 `FLAG_ACTIVITY_RETAIN_IN_RECENTS`。它必须是布尔值“`true`”或“`false`”。



#### android:clearTaskOnLaunch

是否每当从主屏幕重新启动任务时都从中移除根 activity 之外的所有 activity -“`true`”表示始终将任务清除到只剩其根 activity；“`false`”表示不做清除。默认值为“`false`”。该属性只对启动新任务的 activity（根 activity）有意义；任务中的所有其他 activity 均可忽略该属性。

若值为“`true`”，则每次当用户再次启动任务时，无论用户最后在任务中正在执行哪个 Activity，也无论用户是使用“返回”还是“主屏幕”按钮离开，系统都会将用户转至任务的根 Activity。当值为“`false`”时，可在某些情况下清除任务中的 Activity（请参阅 `alwaysRetainTaskState` 属性），但也有例外。

例如，假设用户从主屏幕启动 Activity P，然后从该处转到 Activity Q。接着，该用户按下*主屏幕*，然后返回到 Activity P。正常情况下，用户将看到 Activity Q，因为这是其最后在 P 的任务中所执行的 Activity。不过，如果 P 将此标志设置为“`true`”，当用户从主屏幕启动 activity P 时，系统会移除 P 上方的所有 activity（在本例中为 Q）。因此用户在返回任务时只会看到 P。

如果该属性和 `allowTaskReparenting` 的值均为“`true`”，则如上所述，任何可更改父项的 Activity 都将转移至与其有相似性的任务；而其余 Activity 随即会被移除。

如果未设置 `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED`，系统将忽略此属性。



#### android:colorMode

请求在兼容设备上以广色域模式显示 Activity。 在广色域模式下，窗口可以在 `SRGB` 色域之外进行渲染，从而显示更鲜艳的色彩。如果设备不支持广色域渲染，则此属性无效。



#### android:configChanges

列出 Activity 将自行处理的配置变更。在运行时发生配置变更时，默认情况下会关闭 activity 并将其重启，但使用该属性声明配置将阻止 activity 重启。相反，activity 会保持运行状态，并且系统会调用其 `onConfigurationChanged()` 方法。

任何或所有下列字符串均是该属性的有效值。若有多个值，则使用“`|`”进行分隔，例如“`locale|navigation|orientation`”。

| 值                     | 说明                                                         |
| :--------------------- | :----------------------------------------------------------- |
| “`density`”            | 显示密度发生变更 - 用户可能已指定不同的显示比例，或者有不同的显示现处于活跃状态。在 API 级别 24 中引入。 |
| “`fontScale`”          | 字体缩放系数发生变更 - 用户已选择新的全局字号。              |
| “`keyboard`”           | 键盘类型发生变更 - 例如，用户插入外置键盘。                  |
| “`keyboardHidden`”     | 键盘无障碍功能发生变更 - 例如，用户显示硬键盘。              |
| “`layoutDirection`”    | 布局方向发生变更 - 例如，自从左至右 (LTR) 更改为从右至左 (RTL)。在 API 级别 17 中引入。 |
| “`locale`”             | 语言区域发生变更 - 用户已为文本选择新的显示语言。            |
| “`mcc`”                | IMSI 移动设备国家/地区代码 (MCC) 发生变更 - 检测到 SIM 并更新 MCC。 |
| “`mnc`”                | IMSI 移动设备网络代码 (MNC) 发生变更 - 检测到 SIM 并更新 MNC。 |
| “`navigation`”         | 导航类型（轨迹球/方向键）发生变更。（这种情况通常不会发生。） |
| “`orientation`”        | 屏幕方向发生变更 - 用户旋转设备。**注意**：如果应用面向 Android 3.2（API 级别 13）或更高版本的系统，则还应声明 `"screenLayout"` 和 `"screenSize"` 配置，因为当设备在纵向模式与横向模式之间切换时，屏幕布局和屏幕大小可能会发生变化。 |
| “`screenLayout`”       | 屏幕布局发生变更 - 现处于活跃状态的可能是其他显示模式。      |
| “`screenSize`”         | 当前可用屏幕尺寸发生变更。该值表示目前可用尺寸相对于当前宽高比的变更，当用户在横向模式与纵向模式之间切换时，它便会发生变更。在 API 级别 13 中引入。 |
| “`smallestScreenSize`” | 物理屏幕尺寸发生变更。该值表示与方向无关的尺寸变更，因此它只有在实际物理屏幕尺寸发生变更（如切换到外部显示器）时才会变化。对此配置所作变更对应 [smallestWidth 配置](https://developer.android.com/guide/topics/resources/providing-resources#SmallestScreenWidthQualifier)的变化。在 API 级别 13 中引入。 |
| “`touchscreen`”        | 触摸屏发生变更。（这种情况通常不会发生。）                   |
| “`uiMode`”             | 界面模式发生变更 - 用户已将设备置于桌面或车载基座，或者夜间模式发生变更。如需了解有关不同界面模式的更多信息，请参阅 `UiModeManager`。在 API 级别 8 中引入。 |



所有这些配置变更都可能影响应用所看到的资源值。因此，调用 `onConfigurationChanged()` 时，通常有必要再次检索所有资源（包括视图布局、可绘制对象等），以正确处理变更。





#### android:directBootAware

Activity 是否可感知直接启动 (direct-boot)；即，它是否可以在用户解锁设备之前运行。默认值为 `"false"`。



#### android:documentLaunchMode

指定每次启动任务时，应如何向其添加新的 Activity 实例。该属性允许用户让多个来自同一应用的文档出现在[概览屏幕](https://developer.android.com/guide/components/recents)中。

该属性具有四个值，在用户使用应用打开文档时分别会产生以下效果：

| 值               | 说明                                                         |
| :--------------- | :----------------------------------------------------------- |
| “`intoExisting`” | 系统会搜索基本 Intent 的 `ComponentName` 和数据 URI 与启动 Intent 的这些内容相匹配的任务。如果发现此类任务，系统会将其清除，并在根 Activity 收到对 `onNewIntent(android.content.Intent)` 的调用时自行重启。 如果未发现此类任务，系统会创建新任务。 |
| “`always`”       | Activity 为文档创建新任务，即便文档已经打开。 这与同时设置 `FLAG_ACTIVITY_NEW_DOCUMENT` 和 `FLAG_ACTIVITY_MULTIPLE_TASK` 标志的效果相同。 |
| “`none`”         | 该 Activity 不会为 Activity 创建新任务。这是默认值，它只会在已设置 `FLAG_ACTIVITY_NEW_TASK` 时创建新任务。 概览屏幕将按其默认方式处理此 Activity：为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行。 |
| “`never`”        | 即使 intent 包含 `FLAG_ACTIVITY_NEW_DOCUMENT`，该 activity 也不会启动到新文档中。设置此值会替换 `FLAG_ACTIVITY_NEW_DOCUMENT` 和 `FLAG_ACTIVITY_MULTIPLE_TASK` 标志的行为（如果在 Activity 中设置其中一个标志），并且概览屏幕将为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行。 |

**注意**：如果值不是“`none`”和“`never`”，必须使用 `launchMode="standard"` 定义 Activity。如果未指定此属性，系统会使用 `documentLaunchMode="none"`。





#### android:enabled

系统是否可实例化 Activity -“`"true"`”表示可以，“`false`”表示不可以。默认值为“`true`”。

`<application> `元素具有自己的 `enabled` 属性，该属性适用于所有应用组件，包括 Activity。只有在 `<application>` 和 `<activity>` 属性都为“`true`”（因为它们都默认使用该值）时，系统才能将 Activity 实例化。如果其中任一属性为“`false`”，则无法实例化。



#### android:excludeFromRecents

是否应从最近使用的应用列表（即[概览屏幕](https://developer.android.com/guide/components/recents)）中排除该 Activity 启动的任务。换言之，当该 Activity 是新任务的根 Activity 时，此属性确定最近使用的应用列表中是否应出现该任务。如果应将任务从列表中排除，则设置“`true`”；如果应将任务包含在列表中，则设置“`false`”。默认值为“`false`”。



#### android:exported

此元素设置 Activity 是否可由其他应用的组件启动：

- 如果设为“`true`”，那么 Activity 可由任何应用访问，并且可通过其确切类名称启动。
- 如果设为“`false`”，则 Activity 只能由同一应用的组件、使用同一用户 ID 的不同应用或具有特权的系统组件启动。 没有 intent 过滤器时，这是默认值。

如果应用中的 Activity 包含 intent 过滤器，请将此元素设置为“`true`”，以允许其他应用启动该 Activity。例如，假设 Activity 是应用的主要 Activity，并且包含 `category`“`android.intent.category.LAUNCHER`”。

如果此元素设为“`false`”，并且应用尝试启动该 Activity，系统会抛出 `ActivityNotFoundException`。

此属性并非是限制 Activity 向其他应用公开的唯一方式。权限还可用于限制可调用 Activity 的外部实体（请参阅 `permission` 属性）。



#### android:finishOnTaskLaunch

每当用户再次启动 Activity 的任务（在主屏幕上选择任务）时，是否应关闭（完成）根 Activity 之外的现有 Activity 实例 -“`true`”表示应关闭，“`false`”表示不应关闭。默认值为“`false`”。

如果此属性和 `allowTaskReparenting` 的值均为“`true`”，则优先使用此属性。系统会忽略 Activity 的相似性。系统不会更改 Activity 的父项，而是将其销毁。

如果未设置 `FLAG_ACTIVITY_RESET_TASK_IF_NEEDED`，系统将忽略此属性。



#### android:hardwareAccelerated

是否应为此 Activity 启用硬件加速渲染 -“`true`”表示应启用，“`false`”表示不应启用。默认值为“`false`”。

自 Android 3.0 开始，应用可使用经硬件加速的 OpenGL 渲染器，从而提高许多常见 2D 图形运算的性能。启用硬件加速的渲染程序后，Canvas、Paint、Xfermode、ColorFilter、Shader 和 Camera 中的大多数操作都会加速。这样可使动画和滚动更流畅并且可提高整体响应能力，即使对于没有明确使用框架的 OpenGL 库的应用也是如此。启用硬件加速需要更多资源，因此应用会占用更多内存。

请注意，并非所有 OpenGL 2D 操作都会加速。如果您启用硬件加速的渲染程序，请对应用进行测试，以确保它可以毫无错误地使用该渲染程序。





#### android:label

一种可由用户读取的 Activity 标签。在必须向用户呈现 Activity 时，屏幕上会显示此标签。此标签通常与 Activity 图标一并显示。

如果未设置此属性，则改用整个应用的标签集（请参阅 `<application>` 元素的 `label` 属性）。

Activity 的标签（无论是在此处设置，还是由 `<application>` 元素设置）同时也是 Activity 所有 Intent 过滤器的默认标签（请参阅 `<intent-filter>` 元素的 `label` 属性）。

此标签应设置为对字符串资源的引用，以便可以像界面中的其他字符串一样进行本地化。不过，为了方便您开发应用，也可以将其设为原始字符串。



#### android:icon

表示 Activity 的图标。当需要在屏幕上呈现 activity 时，系统会向用户显示该图标。例如，启动器窗口中会显示启动任务的 Activity 所用图标。该图标通常附带标签（请参阅 [`android:label`](https://developer.android.com/guide/topics/manifest/activity-element#label) 属性）。

必须将此属性设为对包含图片定义的可绘制资源的引用。如果未设置此属性，则改用为整个应用指定的图标（请参阅 `<application>` 元素的 `icon` 属性）。

Activity 的图标（无论是在此处设置，还是由 `<application>` 元素设置）- 同时也是 Activity 所有 Intent 过滤器的默认图标（请参阅 `<intent-filter>` 元素的 `icon` 属性）。



#### android:immersive

为当前 Activity 进行沉浸模式设置。如果在应用清单文件条目中为此 Activity 将 `android:immersive` 属性设置为 `true`，则 `ActivityInfo.flags` 成员会始终设置其 `FLAG_IMMERSIVE` 位（即便在运行时使用 `setImmersive()` 方法更改沉浸模式）。



#### android:maxRecents

[概览屏幕](https://developer.android.com/guide/components/recents)中位于此 Activity 根位置处的最大任务数。达到该条目数时，系统会从概览屏幕中移除近期最少使用的实例。有效值为 1 至 50（内存较小的设备使用 25）；0 为无效值。该值必须是整数，例如 50。默认值为 16。



#### android:maxAspectRatio

activity 支持的最大宽高比。如果应用在具有较大宽高比的设备上运行，则系统会自动为其添加黑边，不会使用屏幕的某些部分，以便应用可按其指定的最大宽高比运行。

最大宽高比表示为设备长边除以短边的商（小数形式）。例如，如果最大宽高比为 7:3，则此属性的值应设为 2.33。

在非穿戴式设备上，此属性的值需设为大于或等于 1.33。在穿戴式设备上，该值必须大于或等于 1.0。否则，系统将忽略此设定值。

**注意**：如果 activity 已将 `resizeableActivity` 设置为 true，则系统会忽略此属性，因为这意味着此 activity 支持任何尺寸。



#### android:multiprocess

是否可将 activity 实例启动到启动该实例的组件进程内 - `true` 表示可以，`false` 表示不可以。默认值为“`false`”。

正常情况下，新的 Activity 实例会启动到定义该实例的应用进程内，因此所有 Activity 实例都在同一进程内运行。不过，如果将该标志设置为“`true`”，则 Activity 实例便可在多个进程内运行，以便系统在任何使用实例的地方创建实例（前提是权限允许这样做），但这几乎毫无必要。



#### android:name

实现 Activity 的类的名称，是 `Activity` 的子类。属性值应该是一个完全限定类名（如“`com.example.project.ExtracurricularActivity`”）。不过，作为一种简写形式，如果名称的第一个字符是句点（例如“`.ExtracurricularActivity`”），则会将其附加到 `build.gradle` 文件中指定的[命名空间](https://developer.android.com/studio/build/configure-app-module#set-namespace)。

发布应用后，[不能更改此名称](http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html)（除非您已设置 `android:exported="false"`）。

没有默认值。必须指定此名称。



#### android:noHistory

当用户离开 Activity 且屏幕上不再显示该 Activity 时，是否应从 Activity 堆栈中将其移除并完成（调用其 `finish()` 方法）-“`true`”表示应将其完成，“`false`”表示不应将其完成。默认值为“`false`”。

“`true`”一值表示 Activity 不会留下历史跟踪记录。它不会留在任务的 activity 堆栈内，因此用户将无法返回该 activity。在此情况下，如果您通过启动另一个 Activity 来获取该 Activity 的结果，系统永远不会调用 `onActivityResult()`。



#### android:parentActivityName

Activity 逻辑父项的类名称。此处的名称必须与为相应 `<activity>` 元素的 [`android:name`](https://developer.android.com/guide/topics/manifest/activity-element#nm) 属性所指定的类名称一致。

系统会读取该属性，以确定当用户按下操作栏中的“向上”按钮时应该启动哪一个 Activity。系统还可利用这些信息，通过 `TaskStackBuilder` 合成 Activity 的返回堆栈。



#### android:permission

启动 Activity 或以其他方式使 Activity 响应 Intent 时，客户端必须具备的权限的名称。如果系统尚未向 `startActivity()` 或 `startActivityForResult()` 的调用方授予指定权限，则其 intent 将不会传递给 activity。

如果未设置该属性，则对 Activity 应用由 `<application>` 元素的 `permission` 属性所设置的权限。如果二者均未设置，则 Activity 不受权限保护。



#### android:process

应在其中运行 Activity 的进程的名称。正常情况下，应用的所有组件均以为应用创建的默认进程名称运行，您无需使用该属性。但如有必要，您可以使用该属性替换默认进程名称，以便将应用组件散布到多个进程中。

如果为该属性分配的名称以冒号（“:”）开头，则系统会在需要时创建应用专用的新进程，并且 Activity 会在该进程中运行。如果进程名称以小写字符开头，则 Activity 将在采用该名称的全局进程中运行，前提是它具有相应权限。这样，不同应用中的组件就可以共享进程，从而减少资源使用量。

`<application>` 元素的 `process` 属性可为所有组件设置一个不同的默认进程名称。



#### resizeableActivity

指定应用是否支持[多窗口模式](https://developer.android.com/guide/topics/ui/multi-window)。您可以在 `<activity>` 或 [``](https://developer.android.com/guide/topics/manifest/application-element) 元素中设置此属性。

如果您将此属性设为 true，则用户可以在分屏模式和自由窗口模式下启动 Activity。如果您将此属性设为 false，则无法针对多窗口环境测试或优化应用。在应用了兼容模式的情况下，系统可能仍会将 Activity 置于多窗口模式中。将此属性设置为 true 也不能保证屏幕（例如画中画）中不会显示多窗口模式下的其他应用。因此，设置此标志并不能确保您的应用获得专属资源访问权限。

如果您的应用以 API 级别 24 或更高级别为目标平台，但您未指定此属性的值，则其值默认设为 true。

如果您的应用以 API 级别 31 或更高级别为目标平台，则此属性在小屏设备和大屏设备上的运作方式会有所不同：

- 大屏 (sw >= 600dp) 设备：所有应用都支持多窗口模式。该属性指示应用是否可以调整大小（而不是应用是否支持多窗口模式）。如果 `resizeableActivity="false"`，应用会在必要时进入兼容模式，以与显示屏尺寸相符。
- 小屏 (sw < 600dp) 设备：如果 `resizeableActivity="true"`，activity 的最小宽度和最小高度都在多窗口模式要求范围内，则应用支持多窗口模式。如果 `resizeableActivity="false"`，则无论 activity 的最小宽度和高度是多少，应用都不支持多窗口模式。



#### android:screenOrientation

Activity 在设备上的显示方向。如果 Activity 是在[多窗口模式](https://developer.android.com/guide/topics/ui/multi-window)下运行，则系统会忽略该属性。

其值可以是下列任一字符串：

| “`unspecified`”      | 默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文中所做的选择可能会有所差异。 |
| -------------------- | ------------------------------------------------------------ |
| “`behind`”           | 与 activity 堆栈中紧接其后的 activity 的方向相同。           |
| “`landscape`”        | 屏幕方向为横向（显示的宽度大于高度）。                       |
| “`portrait`”         | 屏幕方向为纵向（显示的高度大于宽度）。                       |
| “`reverseLandscape`” | 屏幕方向是与正常横向方向相反的横向。 *在 API 级别 9 中引入。* |
| “`reversePortrait`”  | 屏幕方向是与正常纵向方向相反的纵向。 *在 API 级别 9 中引入。* |
| “`sensorLandscape`”  | 屏幕方向为横向，但可根据设备传感器调整为正常或反向的横向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 *在 API 级别 9 中引入。* |
| “`sensorPortrait`”   | 屏幕方向为纵向，但可根据设备传感器调整为正常或反向的纵向。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 *在 API 级别 9 中引入。* |
| “`userLandscape`”    | 屏幕方向为横向，但可根据设备传感器和用户首选项调整为正常或反向的横向。在 API 级别 18 中引入。 |
| “`userPortrait`”     | 屏幕方向为纵向，但可根据设备传感器和用户首选项调整为正常或反向的纵向。 在 API 级别 18 中引入。 |
| “`sensor`”           | 屏幕方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。但在默认情况下，一些设备不会旋转为所有四种可能的方向。如要支持所有这四种方向，请使用 `"fullSensor"`。即使用户锁定基于传感器的旋转，系统仍可使用传感器。 |
| “`fullSensor`”       | 屏幕方向由使用 4 种方向中任一方向的设备方向传感器决定。 这与 `"sensor"` 类似，不同之处在于无论设备在正常情况下使用哪种方向，该值均支持所有 4 种可能的屏幕方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但其支持这些方向）。*在 API 级别 9 中引入。* |
| “`nosensor`”         | 确定屏幕方向时不考虑物理方向传感器。系统会忽略传感器，因此显示内容不会随用户手持设备的方向而旋转。 |
| “`user`”             | 用户当前的首选方向。                                         |
| “`fullUser`”         | 如果用户锁定基于传感器的旋转，则其行为与 `user` 相同，否则，其行为与 `fullSensor` 相同，并且支持所有 4 种可能的屏幕方向。 在 API 级别 18 中引入。 |
| “`locked`”           | 将方向锁定在其当前的任意旋转方向。在 API 级别 18 中引入。    |



#### android:stateNotNeeded

能否在不保存 Activity 状态的情况下将其终止并成功重新启动 -“`true`”表示可在不考虑其之前状态的情况下重新启动，“`false`”表示需要之前状态。默认值为“`false`”。

正常情况下，为保存资源而暂时关闭 Activity 前，系统会调用其 `onSaveInstanceState()` 方法。该方法会将 Activity 的当前状态存储在一个 `Bundle` 对象中，然后在 Activity 重启时将其传递给 `onCreate()`。如果将该属性设置为“`true`”，则系统可能不会调用 `onSaveInstanceState()`，并且会向 `onCreate()` 传递 `null`（而非 Bundle）- 这与 activity 首次启动时的情况完全相同。

“`true`”设置可确保 Activity 能够在未保留状态时重启。例如，显示主屏幕的 Activity 可以使用该设置，确保系统不会在该 Activity 因某种原因而崩溃时将其移除。



#### supportsPictureInPicture

指定 Activity 是否支持[画中画](https://developer.android.com/training/tv/playback/picture-in-picture)显示。



#### android:theme

对定义 Activity 总体主题的样式资源的引用。此属性会自动将 Activity 的场景设置为使用该主题（请参阅 `setTheme()`），并且还可引发 Activity 启动前的“启动”动画（以更加符合 Activity 的实际外观）。

如果未设置该属性，则 Activity 会继承通过 `<application>` 元素的 `theme` 属性为应用整体设置的主题。如果同样未设置该属性，则使用默认系统主题。



#### android:windowSoftInputMode

Activity 的主窗口与包含屏幕软键盘的窗口之间的交互方式。该属性的设置会影响两点内容：

- 当 Activity 成为用户注意的焦点时软键盘的状态 - 隐藏还是可见。
- 对 Activity 主窗口所做的调整 - 是否将其尺寸调小，为软键盘腾出空间；或当软键盘遮盖部分窗口时，是否平移其内容以使当前焦点可见。

该设置必须是下表所列的其中一项值，或一个“`state...`”值加上一个“`adjust...`”值的组合。在任一组中设置多个值（例如，多个“`state...`”值）均会产生未定义的结果。各个值之间用竖线 (`|`) 分隔。例如：

```xml
<activity android:windowSoftInputMode="stateVisible|adjustResize" ... >
```

此处设置的值（“`stateUnspecified`”和“`adjustUnspecified`”除外）会替换主题中设置的值。

| 值                     | 说明                                                         |
| :--------------------- | :----------------------------------------------------------- |
| “`stateUnspecified`”   | 不指定软键盘的状态（隐藏还是可见）。系统会选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。 |
| “`stateUnchanged`”     | 当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。 |
| “`stateHidden`”        | 当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时）隐藏软键盘。 |
| “`stateAlwaysHidden`”  | 当 activity 的主窗口有输入焦点时始终隐藏软键盘。             |
| “`stateVisible`”       | 当用户选择 Activity 时（换言之，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时）显示软键盘。 |
| “`stateAlwaysVisible`” | 当窗口获得输入焦点时，会显示软键盘。                         |
| “`adjustUnspecified`”  | 不指定 Activity 的主窗口是否通过调整尺寸为软键盘腾出空间，或者是否通过平移窗口内容以在屏幕上显示当前焦点。根据窗口的内容是否存在任何可滚动其内容的布局视图，系统会自动选择其中一种模式。如果存在这种视图，系统会调整窗口尺寸，前提是可通过滚动操作在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。 |
| “`adjustResize`”       | 始终调整 Activity 主窗口的尺寸，以为屏幕上的软键盘腾出空间。 |
| “`adjustPan`”          | 不通过调整 Activity 主窗口的尺寸为软键盘腾出空间。相反，窗口的内容会自动平移，使键盘永远无法遮盖当前焦点，以便用户始终能看到自己输入的内容。这通常不如调整窗口尺寸可取，因为用户可能需关闭软键盘才能进入被遮盖的窗口部分，并与之进行交互。 |



#### android:taskAffinity

与 Activity 有着相似性的任务。从概念上讲，具有同一相似性的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。任务的相似性由其根 Activity 的相似性确定。

相似性确定两点内容 - Activity 更改父项后的任务（请参阅 `allowTaskReparenting` 属性），以及通过 `FLAG_ACTIVITY_NEW_TASK` 标志启动 Activity 时，用于容纳该 Activity 的任务。

默认情况下，应用中的所有 Activity 都具有同一相似性。您可以设置该属性，以不同方式将其分组，甚至可以在同一任务内放置不同应用中定义的 Activity。如要指定 Activity 与任何任务均无相似性，请将其设置为空字符串。

如果未设置该属性，则 Activity 会继承为应用设置的相似性（请参阅 `<application>` 元素的 `taskAffinity` 属性）。应用默认相似性的名称是在 `build.gradle` 文件中设置的[命名空间](https://developer.android.com/studio/build/configure-app-module#set-namespace)。



#### android:allowTaskReparenting

allowTaskReparenting属性的作用是Activity的迁移。当allowTaskReparenting属性和TaskAffinity配合使用时，Activity可以从一个任务栈迁移到另一个任务栈。

迁移的规则是：从一个与该Activity TaskAffinity属性不同的任务栈中迁移到与它TaskAffinity相同的任务栈中。

举个例子：当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性设置为true，那么当应用B被启动，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。
 具体点来说，现在有两个应用A和B，A启动了B的一个Activity C，然后按Home键回到桌面，然后再单击B的桌面图标，这个时候不是启动了B的主Activity，而是重新显示了已经被应用A启动的Activity C。我们也可以理解为，C从A的任务栈转移到了B的任务栈中。
 可以这么理解，由于A启动了C，这个时候C只能运行在A的任务栈中，但是C属于B应用，正常情况下，它的TaskAffinity值肯定不可能和A的任务栈相同，所以当B启动后，B会创建自己的任务栈，这个时候系统发现C原本想要的任务栈已经创建了，所以就把C从A的任务栈中转移过来了。



#### android:launchMode

有关应如何启动 activity 的指令。共有五种模式可与 `Intent` 对象中的 activity 标记（`FLAG_ACTIVITY_*` 常量）协同工作，以确定在调用 activity 处理 intent 时应执行的操作。它们是：

"`standard`"
"`singleTop`"
"`singleTask`"
"`singleInstance`"
"`singleInstancePerTask`"

默认模式为“`standard`”。

如下表所示，这些模式可分为两大类：“`standard`”和“`singleTop`”activity 为一类，“`singleTask`”“`singleInstance`”和“`singleInstancePerTask`”activity 为另一类。启动模式为“`standard`”或“`singleTop`”的 activity 可以多次实例化。实例可归属任何任务，并且可位于 activity 任务中的任何位置。通常，它们会启动到名为 `startActivity()` 的任务中（除非 intent 对象包含 `FLAG_ACTIVITY_NEW_TASK` 指令，在此情况下会选择其他任务 - 请参阅 [taskAffinity](https://developer.android.com/guide/topics/manifest/activity-element#aff) 属性）。

相比之下，"`singleTask`" "`singleInstance`" 和 "`singleInstancePerTask`" activity 的行为有所不同。 “`singleInstancePerTask`”始终位于 activity 任务的根位置。此外，设备一次只能保留一个 "`singleInstance`" activity 实例，而 "`singleInstancePerTask`" activity 在 `FLAG_ACTIVITY_MULTIPLE_TASK` 或 `FLAG_ACTIVITY_NEW_DOCUMENT` 已设置的情况下，在不同的任务中可以多次实例化。启动模式为 "`singleTask`" 的 activity 结合了 "`singleInstance`" 和 "`singleInstancePerTask`" 的行为：activity 可以多次实例化，并且可以位于具有相同 `taskAffinity` 的任务中的任意位置。同时，设备只能保留一个用于在 activity 任务的根位置查找 "`singleTask`" activity 的任务。

“`standard`”和“`singleTop`”模式只有一个不同之处：每次“`standard`”activity 有一个新的 intent 时，系统都会创建类的新实例来响应该 intent。每个实例处理单个 Intent。同样地，您也可以创建新的“`singleTop`”Activity 实例来处理新的 Intent。不过，如果目标任务的 Activity 堆栈顶部已有一个 Activity 实例，则该实例会（通过调用 `onNewIntent()`）接收新的 Intent；此时不会创建新实例。在其他情况下（例如，如果“`singleTop`”activity 的某个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中），系统会创建新实例并将其送入堆栈。

同样地，如果您[向上导航](https://developer.android.com/training/implementing-navigation/ancestral)到当前堆栈上的某个 Activity，则该行为由父 Activity 的启动模式决定。如果父 Activity 有启动模式 `singleTop`（或者 `up` Intent 包含 `FLAG_ACTIVITY_CLEAR_TOP`），则系统会将该父项置于堆栈顶部，并保留其状态。导航 Intent 由父 Activity 的 `onNewIntent()` 方法接收。如果父 activity 有启动模式 `standard`（并且 `up` intent 不包含 `FLAG_ACTIVITY_CLEAR_TOP`），则系统会将当前 activity 及其父项同时送出堆栈，并创建新的父 activity 实例来接收导航 intent。

“`singleInstance`”模式也与“`singleTask`”和“`singleInstancePerTask`”有一个不同之处：具有“`singleTask`”或“`singleInstancePerTask`”启动模式的 activity 允许其他 activity（必须是“`standard`”和“`singleTop`”activity）成为其任务的一部分。另一方面，“`singleInstance`”activity 不允许任何其他 activity 成为其任务的一部分；它必须是任务中唯一的 activity。如果它启动另一个 activity，则系统会将该 activity 分配给其他任务，就如同 intent 中包含 `FLAG_ACTIVITY_NEW_TASK` 一样。



| 使用场景                        | 启动模式       | 多个实例？                                                   | 备注                                                         |
| :------------------------------ | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 大多数 Activity 的正常启动      | “`standard`”   | 是                                                           | 默认。系统始终会在目标任务中创建新的 Activity 实例，并向其传送 Intent。 |
| “`singleTop`”                   | 视情况而定     | 如果目标任务的顶部已存在 Activity 实例，则系统会通过调用该实例的 `onNewIntent()` 方法向其传送 Intent，而非创建新的 Activity 实例。 |                                                              |
| 专用启动 （不建议用作常规用途） | "`singleTask`" | 视情况而定                                                   | 系统会在新任务的根位置创建 activity，或将该 activity 放置在具有相同 affinity 的现有任务上。 如果任务的根位置已存在 activity 实例，则系统会通过调用现有实例的 `onNewIntent()` 方法（而非创建新的 activity 实例），向其传送 intent。 |
| "`singleInstance`"              | 否             | 与 `singleTask"` 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。该 activity 始终是其任务中的唯一 activity。 |                                                              |
| "`singleInstancePerTask`"       | 视情况而定     | 此 activity 只能作为任务的根 activity、作为创建该任务的第一个 activity 运行，因此在任务中该 activity 只有一个实例；但是 activity 可以在不同的任务中多次实例化。 |                                                              |

如上表所示，`standard` 是默认模式，适用于大多数类型的 activity。对众多类型的 activity 而言，`SingleTop` 也是常见且有用的启动模式。其他模式（`singleTask`、`singleInstance` 和 `singleInstancePerTask`）不适用于大多数应用，因为它们所形成的交互模式可能让用户感到陌生，并且与大多数其他应用差别较大。





#  intent 过滤器

**Intent 过滤器**是 Android 平台的一项非常强大的功能。借助这项功能，您不但可以根据显式请求启动 Activity，还可以根据隐式请求启动 Activity。例如，显式请求可能会告诉系统“在 Gmail 应用中启动‘发送电子邮件’Activity”，而隐式请求可能会告诉系统“在任何能够完成此工作的 Activity 中启动‘发送电子邮件’屏幕”。当系统界面询问用户使用哪个应用来执行任务时，这就是 intent 过滤器在起作用。

要使用此功能，您需要在activity元素中声明intent-filter属性。此元素的定义包括action元素，以及可选的category元素和/或data元素。这些元素组合在一起，可以指定 Activity 能够响应的 intent 类型。例如，以下代码段展示了如何配置一个发送文本数据并接收其他 Activity 的文本数据发送请求的 Activity：

```xml
    <activity android:name=".ExampleActivity" android:icon="@drawable/app_icon">
        <intent-filter>
            <action android:name="android.intent.action.SEND" />
            <category android:name="android.intent.category.DEFAULT" />
            <data android:mimeType="text/plain" />
        </intent-filter>
    </activity>
    
```

在此示例中，action元素指定该 Activity 会发送数据。将 category元素声明为 `DEFAULT` 可使 Activity 能够接收启动请求。data元素指定此 Activity 可以发送的数据类型。以下代码段展示了如何调用上述 Activity：

```kotlin
    val sendIntent = Intent().apply {
        action = Intent.ACTION_SEND
        type = "text/plain"
        putExtra(Intent.EXTRA_TEXT, textMessage)
    }
    startActivity(sendIntent)
    
```

如果您打算构建一个独立的应用，不允许其他应用激活其 Activity，则不需要任何其他 intent 过滤器。您不想让其他应用访问的 Activity 不应包含 intent 过滤器，您可以自己使用显式 intent 启动它们。



## intent-filter属性/标签

### **语法**

```
<intent-filter android:icon="drawable resource"
               android:label="string resource"
               android:priority="integer" >
    . . .
</intent-filter>
```

**必须包含：**action属性





### **属性**

#### android:icon

一个表示父 Activity、服务或广播接收器的图标，在将该组件以具备过滤器所描述功能的形式呈现给用户时显示。

此属性必须设置为对包含图片定义的可绘制资源的引用。默认值为父组件的 `icon` 属性设置的图标。如果父组件未指定图标，则默认值为 `<application>` 元素设置的图标。





#### android:label

父组件的用户可读标签。将相应组件以具备过滤器所描述功能的形式呈现给用户时，将使用此标签（而不是父组件设置的标签）。

此标签应设置为对字符串资源的引用，以便可以像界面中的其他字符串一样进行本地化。不过，为了方便您开发应用，也可以将其设为原始字符串。

默认值为父组件设置的标签。如果父组件未指定标签，则默认值为 `<application>` 元素的 `label` 属性设置的标签。



#### android:priority

就处理过滤器所描述类型的 intent 而言，应该为父组件指定的优先级。此属性对 Activity 和广播接收器都有意义：

- 它说明了某个 Activity 对与过滤器匹配的 Intent 的响应能力，这是相对于也可以响应该 Intent 的其他 Activity 的响应能力。当 Intent 可由优先级不同的多个 Activity 处理时，Android 只会将优先级值较高的 Activity 视为 Intent 的潜在目标。
- 它控制按什么顺序执行广播接收器以接收广播消息。优先级值越高，调用顺序越靠前。（该顺序仅适用于同步消息；对于异步消息，系统会忽略该顺序。）

只有在您确实需要对接收广播施加特定顺序或想要强制 Android 优先选用某个 Activity 时，才能使用此属性。

值必须是一个整数，如“`100`”。数值越高，优先级也就越高。默认值为 0。

在某些情况下，系统会忽略请求的优先级，并将值限定为 `0`。此类情况发生在：

- 非特权应用请求任何大于 0 的优先级时
- 特权应用为 `ACTION_VIEW`、`ACTION_SEND`、`ACTION_SENDTO` 或 `ACTION_SEND_MULTIPLE` 请求大于 0 的优先级时



#### android:order

当多个过滤器匹配时应按什么顺序处理过滤器。

`order` 与 `priority` 的不同之处在于，`priority` 在多个应用间应用，而 `order` 可消除单个应用中多个匹配的过滤器的歧义。

当多个过滤器可以匹配时，请改用定向 Intent。

值必须是一个整数，如“`100`”。数值越高，匹配顺序越靠前。 默认值为 `0`。

此属性是在 API 级别 28 中引入的。





#### android:autoVerify

Android 是否应验证指定主机中的 Digital Asset Links JSON 文件与此应用的匹配情况。

请参阅：[验证 Android App Links](https://developer.android.com/training/app-links/verify-android-applinks)

默认值为 `false`。

此属性是在 API 级别 23 中引入的。





## action元素



### **语法：**

```
<action android:name="string" />
```



向 Intent 过滤器添加操作。 `<intent-filter>` 元素必须包含一个或多个 `<action>` 元素。如果 Intent 过滤器中没有 `<action>` 元素，则过滤器不接受任何 `Intent` 对象。



### **属性：**

#### android:name

操作的名称。某些标准操作在 `Intent` 类中定义为 `ACTION_*string*` 常量。若要将其中一项操作分配给此属性，请在 `ACTION_` 后跟的 `*string*` 前面加上“`android.intent.action.`”。例如，对于 `ACTION_MAIN`，请使用“`android.intent.action.MAIN`”；对于 `ACTION_WEB_SEARCH`，请使用“`android.intent.action.WEB_SEARCH`”。

对于您定义的操作，最好将应用的软件包名称用作前缀，以确保唯一性。例如，可按如下方式指定 `TRANSMOGRIFY` 操作：

```xml
<action android:name="com.example.project.TRANSMOGRIFY" />
```





## category元素



### 语法：

```
<category android:name="string" />
```

向 Intent 过滤器添加类别名称。



### **属性：**

#### android:name

类别的名称。标准类别在 `Intent` 类中定义为 `CATEGORY_*name*` 常量。此处分配的名称可以根据这些常量推导出来，方法是在 `CATEGORY_` 后跟的 `*name*` 前面加上“`android.intent.category.`”作为前缀。例如，`CATEGORY_LAUNCHER` 的字符串值为“`android.intent.category.LAUNCHER`”。

**注意**：为了接收隐式 intent，您必须在 intent 过滤器中添加 `CATEGORY_DEFAULT` 类别。`startActivity()` 和 `startActivityForResult()` 方法将所有 intent 当作声明了 `CATEGORY_DEFAULT` 类别一样对待。如果您没有在 Intent 过滤器中声明该类别，则任何隐式 Intent 都不会解析为您的 Activity。

自定义类别应将软件包名称用作前缀，以确保它们的唯一性。



##  data元素

### **语法：**

```
<data android:scheme="string"
      android:host="string"
      android:port="string"
      android:path="string"
      android:pathPattern="string"
      android:pathPrefix="string"
      android:mimeType="string" />
```



向 Intent 过滤器添加数据规范。该规范可以是只有数据类型（`mimeType` 属性），可以是只有 URI，也可以是既有数据类型又有 URI。URI 由其各个部分的单独属性指定：

```
<scheme>://<host>:<port>[<path>|<pathPrefix>|<pathPattern>]
```

用于指定网址格式的以下属性是可选的，但也相互依赖：

- 如果没有为 Intent 过滤器指定 `scheme`，则系统会忽略其他所有 URI 属性。
- 如果没有为过滤器指定 `host`，则系统会忽略 `port` 属性以及所有路径属性。

同一 `<intent-filter>` 元素中包含的所有 `<data>` 元素都对同一过滤器起作用。例如，以下过滤器规范：

```xml
<intent-filter . . . >
    <data android:scheme="something" android:host="project.example.com" />
    . . .
</intent-filter>
```

等同于以下规范：

```xml
<intent-filter . . . >
    <data android:scheme="something" />
    <data android:host="project.example.com" />
    . . .
</intent-filter>
```

您可以在 `<intent-filter>` 内放置任意数量的 `<data>` 元素，为其提供多个数据选项。它的属性都没有默认值。



### **属性：**

#### android:scheme

URI 的架构部分。这是指定 URI 时最基本的属性；必须至少为过滤器设置一个 `scheme` 属性，否则其他 URI 属性都没有意义。

指定的架构应不带尾随冒号（例如，应指定 `http`，而不是 `http:`）。

如果为过滤器设置了数据类型（`mimeType` 属性），但未设置架构，则采用 `content:` 和 `file:` 架构。

**注意**：Android 框架中的架构匹配区分大小写，这一点与 RFC 不同。因此，您应始终使用小写字母指定架构。





#### android:host

URI 授权方的主机部分。除非也为过滤器指定了 `scheme` 属性，否则此属性没有意义。如需匹配多个子网域，请使用星号 (`*`) 匹配主机中的零个或多个字符。例如，主机 `*.google.com` 匹配 `www.google.com`、`.google.com` 和 `developer.google.com`。

星号必须是主机属性的第一个字符。例如，主机 `google.co.*` 无效，因为星号通配符不是第一个字符。

**注意**：Android 框架中的主机名匹配区分大小写，这一点与正式的 RFC 不同。因此，您应始终使用小写字母指定主机名。



#### android:port

URI 授权方的端口部分。仅当同时为过滤器指定了 `scheme` 和 `host` 属性时，此属性才有意义。



#### android:path、android:pathPrefix、android:pathPattern

URI 的路径部分，必须以 / 开头。`path` 属性指定与 Intent 对象中的完整路径匹配的完整路径。`pathPrefix` 属性指定只与 Intent 对象中的路径的初始部分匹配的部分路径。`pathPattern` 属性指定与 Intent 对象中的完整路径匹配的完整路径，但它可以包含以下通配符：

- 星号（“`*`”）匹配出现零次到多次的紧邻前面的字符的一个序列。
- 后跟星号的句点（“`.*`”）匹配零个或多个字符的任意序列。

由于在从 XML 读取字符串时（在将其解析为模式之前）将“`\`”用作转义字符，因此您需要进行双重转义：例如，字面量“`*`”将编写为“`\\*`”，字面量“`\`”将编写为“`\\\\`”。这基本上与采用 Java 代码构造字符串时需要编写的内容一样。

如需详细了解这三种类型的模式，请参阅 `PatternMatcher` 类中的 `PATTERN_LITERAL`、`PATTERN_PREFIX` 和 `PATTERN_SIMPLE_GLOB` 的说明。

仅当同时为过滤器指定了 `scheme` 和 `host` 属性时，这些属性才有意义。



#### android:mimeType

MIME 媒体类型，如 `image/jpeg` 或 `audio/mpeg4-generic`。 子类型可以是星号通配符 (`*`)，以指示任何子类型都匹配。

Intent 过滤器经常会声明仅包含 `android:mimeType` 属性的 `<data>`。

**注意**：Android 框架中的 MIME 类型匹配区分大小写，这一点与正式的 RFC MIME 类型不同。因此，您应始终使用小写字母指定 MIME 类型。





# 声明权限

您可以使用清单的 activity 标记来控制哪些应用可以启动某个 Activity。父 Activity 和子 Activity 必须在其清单中具有相同的权限，前者才能启动后者。如果您为父 Activity 声明了 [``](https://developer.android.com/guide/topics/manifest/uses-permission-element) 元素，则每个子 Activity 都必须具有匹配的 [``](https://developer.android.com/guide/topics/manifest/uses-permission-element)元素。

例如，假设您的应用想要使用一个名为 SocialApp 的应用在社交媒体上分享文章，则 SocialApp 本身必须定义调用它的应用所需具备的权限：

```xml
    <manifest>
    <activity android:name="...."
       android:permission=”com.google.socialapp.permission.SHARE_POST”

    />
    
```

然后，为了能够调用 SocialApp，您的应用必须匹配 SocialApp 清单中设置的权限：

```xml
    <manifest>
       <uses-permission android:name="com.google.socialapp.permission.SHARE_POST" />
    </manifest>
    
```



# Activity 生命周期

