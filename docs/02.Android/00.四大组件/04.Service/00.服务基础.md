---
title: 服务基础
date: 2022-10-10 14:28:27
permalink: /pages/575d07/
categories:
  - Android
  - 四大组件
  - Service
tags:
  - 
---

Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。



和Activity一样，它也有自己的生命周期。但是和Activity不同的是，不同的服务状态有不用的生命周期。



所以，我们结合它的服务状态来探讨它的生命周期。但是在此之前，我们先了解下它的启动方式。



# 启动方式

这里和Activity一样，分为 **显式启动** 和 **隐式启动**。

## 显式启动

```
        startService(Intent(this,BaseService::class.java))
```

```
        bindService(Intent(this,BActivity::class.java),serviceConnection, BIND_AUTO_CREATE)
```



直接使用startService启动一个服务。



这里解释下 bindService 中需要的几个参数：

ServiceConnection：需要实现的一个接口

```
public interface ServiceConnection {
    void onServiceConnected(ComponentName name, IBinder service);

    void onServiceDisconnected(ComponentName name);

    default void onBindingDied(ComponentName name) {
    }

    default void onNullBinding(ComponentName name) {
    }
}
```



flags：我们一般使用 BIND_AUTO_CREATE



## 隐式启动

```
        startService(Intent().apply {
            action = "cc.fastcv.codelab.services.BaseService"
        })
```

```
        bindService(Intent().apply {
            action = "cc.fastcv.codelab.services.BaseService"
        },serviceConnection, BIND_AUTO_CREATE)
```



这里的action就是我们在清单文件中配置的intent-filter的action。清单文件中，service的标签属性如下：

```
<service android:enabled=["true" | "false"]
    android:exported=["true" | "false"]
    android:icon="drawable resource"
    android:isolatedProcess=["true" | "false"]
    android:label="string resource"
    android:name="string"
    android:permission="string"
    android:process="string" >
    . . .
</service>
```

| 属性                    | 作用                                                         |
| ----------------------- | ------------------------------------------------------------ |
| android:exported        | 代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。 |
| android:name            | 对应Service类名 android:permission：是权限声明 android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。 |
| android:isolatedProcess | 设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。 |
| android:enabled         | 是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。 |
| android:label           | 描述标签                                                     |
| android:permission      | 启动权限                                                     |
| android:name            | 必填，指向Service的类名                                      |



在安卓5.0之前，我们这样子去隐式启动一个服务是没有问题的。但是在安卓5.0之后，这样子启动就会报出错误：

```
    java.lang.IllegalArgumentException: Service Intent must be explicit: Intent { act=cc.fastcv.codelab.services.BaseService }
        at android.app.ContextImpl.validateServiceIntent(ContextImpl.java:1851)
        at android.app.ContextImpl.startServiceCommon(ContextImpl.java:1892)
        at android.app.ContextImpl.startService(ContextImpl.java:1864)
        at android.content.ContextWrapper.startService(ContextWrapper.java:817)
        at android.content.ContextWrapper.startService(ContextWrapper.java:817)
        at cc.fastcv.codelab.MainActivity.onClick(MainActivity.kt:28)
```

Android 5.0之后google出于安全的角度禁止了隐式声明Intent来启动Service。那么怎么适配呢？

答案是：在现有基础上加上 **packageName**，如下：

```
        startService(Intent().apply {
            action = "cc.fastcv.codelab.services.BaseService"
            `package` = packageName
        })
        
```

```
        bindService(Intent().apply {
            action = "cc.fastcv.codelab.services.BaseService"
            `package` = packageName
        },serviceConnection, BIND_AUTO_CREATE)
```





# 服务状态

服务状态我在这里分为两种：

- **启动状态**：当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。
- **绑定状态**：当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。



简单来说，就是启动服务的基础接口有两个：

- startService
- bindService

如果不需要和服务进行交互，只是单方面的给服务写入指令的话，我们就可以使用startService；而要进行交互的话，就必须使用bindService了。



一种更复杂的情况是，我们可能在不同的情况下分别使用 startService 和 bindService来处理业务。所以，我们需要非常了解不同情况下的生命周期是如何回调的，这样子才能更好的使用服务来处理我们的业务功能。



# 生命周期

先来一张官方图镇场！！！

![](https://xh-blog.oss-cn-guangzhou.aliyuncs.com/service_lifecycle.png)



## startService

从官方图上看，需要注意的是回调有：

- onCreate
- onStartCommand
- onDestory



其中 onStartCommand 是带参数的

- intent ：启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service
- flags：表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：
    - START_FLAG_REDELIVERY
      这个值代表了onStartCommand方法的返回值为
      START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。
    - START_FLAG_RETRY
      该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。
- startId ： 指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。



实际上onStartCommand的返回值int类型才是最最值得注意的，它有三种可选值， START_STICKY，START_NOT_STICKY，START_REDELIVER_INTENT，它们具体含义如下：

- START_STICKY
  当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。
- START_NOT_STICKY
  当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。
- START_REDELIVER_INTENT
  当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。



从应用场景来看的话，有以下场景需要验证：

### 启动 - 启动 - 启动

```
2022-10-24 15:06:45.091 4702-4702/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:06:45.091 4702-4702/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1
2022-10-24 15:06:54.102 4702-4702/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2
2022-10-24 15:06:54.799 4702-4702/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:3
```

除了第一次启动会调用onCreate之外，后面都只会调用onStartCommand了。

**已验证：和Activity无关，可以跨Activity操作。**



### 启动 - 关闭 - 启动 - 启动

```
2022-10-24 15:10:39.093 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:10:39.093 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1
2022-10-24 15:11:29.012 5410-5410/cc.fastcv.codelab D/BaseService: onDestroy: 
2022-10-24 15:11:43.049 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:11:43.050 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1
2022-10-24 15:11:47.284 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2
```

**已验证：和Activity无关，可以跨Activity操作。**



### 启动  - 关闭 - 关闭 - 关闭

```
2022-10-24 15:12:34.205 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:12:34.205 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1
2022-10-24 15:12:36.335 5410-5410/cc.fastcv.codelab D/BaseService: onDestroy: 
```

如果服务已经关闭，则再次调用 stopService是没有任何反应的。

**已验证：和Activity无关，可以跨Activity操作。**



### 关闭 - 启动 - 启动 - 关闭

```
2022-10-24 15:15:23.189 5410-5410/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:15:23.189 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1
2022-10-24 15:15:26.936 5410-5410/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2
2022-10-24 15:15:28.642 5410-5410/cc.fastcv.codelab D/BaseService: onDestroy: 
```

**已验证：和Activity无关，可以跨Activity操作。**



## bindService

从官方图上看，需要注意的是回调有：

- onCreate
- onBind
- onUnbind
- onDestory



**在这里需要注意的是，在Service的onBind回调中，如果返回的是null，会回调 onBind 但是，不会回调 connect里面的接口**



从应用场景来看的话，有以下场景需要验证：

### 绑定 - 绑定 - 绑定

```
2022-10-24 15:40:20.125 7906-7906/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:40:20.126 7906-7906/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 15:40:20.128 7906-7906/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 15:40:43.224 7906-7906/cc.fastcv.codelab D/BActivity: onCreate: 
2022-10-24 15:40:46.598 7906-7906/cc.fastcv.codelab D/BActivity: onServiceConnected: 
```

不同的Activity绑定之后，会有不用的connect接收，但是绑定之后再绑定是不会有任何回调的。



### 绑定 - 解绑 - 绑定 - 绑定

```
2022-10-24 15:42:29.512 8164-8164/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:42:29.512 8164-8164/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 15:42:29.514 8164-8164/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 15:42:31.043 8164-8164/cc.fastcv.codelab D/BaseService: onUnbind: 
2022-10-24 15:42:31.043 8164-8164/cc.fastcv.codelab D/BaseService: onDestroy:
2022-10-24 15:42:35.714 8164-8164/cc.fastcv.codelab D/BActivity: onCreate: 
2022-10-24 15:42:37.633 8164-8164/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:42:37.633 8164-8164/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 15:42:37.634 8164-8164/cc.fastcv.codelab D/BActivity: onServiceConnected: 
```

解绑之后，就会停止服务，再次绑定服务时，会重新启动服务。

**已验证：和Activity有关，不可以跨Activity操作。**



### 绑定  - 解绑 - 解绑 - 解绑

```
2022-10-24 15:44:37.633 8585-8585/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:44:37.634 8585-8585/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 15:44:37.636 8585-8585/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 15:44:39.276 8585-8585/cc.fastcv.codelab D/BaseService: onUnbind: 
2022-10-24 15:44:39.276 8585-8585/cc.fastcv.codelab D/BaseService: onDestroy: '
2022-10-24 15:44:40.687 8585-8585/cc.fastcv.codelab E/AndroidRuntime: FATAL EXCEPTION: main
    java.lang.IllegalArgumentException: Service not registered: cc.fastcv.codelab.MainActivity$serviceConnection$1@943aadb
        at android.app.LoadedApk.forgetServiceDispatcher(LoadedApk.java:1991)
        at android.app.ContextImpl.unbindService(ContextImpl.java:2076)
        at android.content.ContextWrapper.unbindService(ContextWrapper.java:889)
        at android.content.ContextWrapper.unbindService(ContextWrapper.java:889)
        at cc.fastcv.codelab.MainActivity.onCreate$lambda-3(MainActivity.kt:45)
```

可以看到，在解绑之后，再次解绑的话，就会出现 **Service not registered** 的错误，并且应用会奔溃。



### 解绑 - 绑定 - 绑定 - 解绑

```
2022-10-24 15:46:18.706 8835-8835/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:46:18.706 8835-8835/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 15:46:18.709 8835-8835/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 15:46:21.301 8835-8835/cc.fastcv.codelab D/BaseService: onUnbind:
2022-10-24 15:46:21.301 8835-8835/cc.fastcv.codelab D/BaseService: onDestroy:
2022-10-24 15:46:21.994 8835-8835/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 15:46:21.995 8835-8835/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 15:46:21.997 8835-8835/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 15:46:22.577 8835-8835/cc.fastcv.codelab D/BaseService: onUnbind: 
2022-10-24 15:46:22.577 8835-8835/cc.fastcv.codelab D/BaseService: onDestroy:
```

**这里需要注意的是，如果绑定的数量与解绑的数量不相等时，是不会回调onUnbind和onDestroy的。**



## startService与bindService

在前面分别对startService和bindService做了实验之后，我们可以得到：

startService：第一次启动会走onCreate，后面调用启动时，只会调用onStartCommand，然后调用stopService之后就会停止服务。可以重复调用停止服务。

bindService：第一次绑定会走onBind，后面会直接返回binder对象，然后调用解绑操作之后就会停止服务。无法重复调用解绑操作。



所以，当两者结合起来使用时，生命周期会变的复杂起来，这里我将它分为以下几个特例：

1、Service是否启动了，如果没有启动则无论调用哪个都会先走onCreate。如果启动了，这个时候调用start会回调onStartCommand（每次调用都会回调）；调用bind就会调用onBind（多次调用只会回调一次）。

2、如果即启动了又绑定了，则需要即解绑又停止服务才能停止服务，否则不会停止服务。

3、如果有多个地方绑定了，则需要全部解绑了才算完解绑完成。





# 数据传递

## 单向传递

从前面可以知道 **startService** 是个单项的操作，那我们怎么样传递数据到服务中呢？

还记得 onStartCommand 回调吗？我们每次调用 startService 方法时都会调用它，而这个回调接口有三个参数，其中的 Intent 就是我们传递数据的载体。



如：我们传递字符给服务：

```
2022-10-24 16:00:00.608 9652-9652/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 16:00:00.609 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1
2022-10-24 16:00:00.609 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: command = command1
2022-10-24 16:00:03.378 9652-9652/cc.fastcv.codelab D/BActivity: onCreate: 
2022-10-24 16:00:04.770 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:2
2022-10-24 16:00:04.770 9652-9652/cc.fastcv.codelab D/BaseService: onStartCommand: command = command2
```

可以看到，我们分别将command1、command2写入到服务中。



## 双向传递

我们在 **bindService** 的connect 回调中 获取 Binder对象，如：

```
class BaseBinder : Binder() {

    companion object {
        private const val TAG = "BaseBinder"
    }

    private val callbacks = mutableListOf<Callback>()

    fun addCallback(callback: Callback) {
        Log.d(TAG, "addCallback: 绑定监听者 $callback")
        if (!callbacks.contains(callback)) {
            callbacks.add(callback)
        }
    }

    fun removeCallback(callback: Callback) {
        Log.d(TAG, "removeCallback: 解除监听者 $callback")
        if (callbacks.contains(callback)) {
            callbacks.remove(callback)
        }
    }

    fun request() {
        for (callback in callbacks) {
            callback.onCall("收到请求")
        }
    }
}

interface Callback {
    fun onCall(msg:String)
}
```

那么，在绑定成功的时候 addCallback 在解绑的时候 removeCallback。最后运行结果：

```
2022-10-24 16:14:10.590 10620-10620/cc.fastcv.codelab D/MainActivity: onCreate: 
2022-10-24 16:14:14.544 10620-10620/cc.fastcv.codelab D/BaseService: onCreate: 
2022-10-24 16:14:14.545 10620-10620/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 16:14:14.547 10620-10620/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 16:14:14.547 10620-10620/cc.fastcv.codelab D/BaseBinder: addCallback: 绑定监听者 cc.fastcv.codelab.MainActivity@dc6dfb0
2022-10-24 16:14:18.029 10620-10620/cc.fastcv.codelab D/BActivity: onCreate: 
2022-10-24 16:14:19.459 10620-10620/cc.fastcv.codelab D/BActivity: onServiceConnected: 
2022-10-24 16:14:19.459 10620-10620/cc.fastcv.codelab D/BaseBinder: addCallback: 绑定监听者 cc.fastcv.codelab.BActivity@ded60a8
2022-10-24 16:14:23.244 10620-10620/cc.fastcv.codelab D/MainActivity: onCall: 收到请求
2022-10-24 16:14:23.244 10620-10620/cc.fastcv.codelab D/BActivity: onCall: 收到请求
```



## ANR问题

在这里需要注意的是，Service的回调都是在主线程中的，所以，如果我们在回调中做耗时操作的话，就会产生ANR的问题。

```
2022-10-24 16:17:19.339 10906-10906/cc.fastcv.codelab D/BaseService: onCreate: main
2022-10-24 16:17:19.339 10906-10906/cc.fastcv.codelab D/BaseService: onStartCommand: flags:0  startId:1  main
2022-10-24 16:17:23.123 10906-10906/cc.fastcv.codelab D/BaseService: onBind: main
2022-10-24 16:17:32.945 10906-10906/cc.fastcv.codelab D/BaseService: onUnbind: main
2022-10-24 16:17:32.945 10906-10906/cc.fastcv.codelab D/BaseService: onDestroy: main
```



所以，如果需要在服务中做耗时操作的话，我们需要在服务的回调之后开启一个子线程做相关耗时操作。这样处理太过繁琐了，所以谷歌推出了**IntentService**来帮助我们做类似的操作。



# IntentService

客户端通过startService(Intent)来启动IntentService; 我们并不需要手动地区控制IntentService,当任务执行完后,IntentService会自动停止; 可以启动IntentService多次,每个耗时操作会以工作队列的方式在IntentService的 onHandleIntent回调方法中执行,并且每次只会执行一个工作线程,执行完一，再到二这样。如：

```
class BaseIntentService : IntentService("intent") {

    companion object {
        private const val TAG = "BaseIntentService"
    }

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "onCreate: ")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "onStartCommand: ")
        return super.onStartCommand(intent, flags, startId)
    }

    override fun onHandleIntent(intent: Intent?) {
        val workId = intent?.getStringExtra("workId")
        Log.d(TAG, "onHandleIntent: workId = $workId  threadId = ${Thread.currentThread().name}")
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy: ")
    }
}
```

我们多次点击启动服务

```
            val baseService = Intent(this, BaseIntentService::class.java)
            baseService.putExtra("workId","" + index++ )
            startService(baseService)
```

结果：

```
2022-10-24 16:25:20.857 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: 
2022-10-24 16:25:20.857 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: 
2022-10-24 16:25:20.858 11738-11776/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 1  threadId = IntentService[intent]
2022-10-24 16:25:20.859 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: 
2022-10-24 16:25:23.521 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: 
2022-10-24 16:25:23.522 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: 
2022-10-24 16:25:23.522 11738-11785/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 2  threadId = IntentService[intent]
2022-10-24 16:25:23.523 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: 
2022-10-24 16:25:23.729 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: 
2022-10-24 16:25:23.729 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: 
2022-10-24 16:25:23.730 11738-11786/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 3  threadId = IntentService[intent]
2022-10-24 16:25:23.731 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: 
2022-10-24 16:25:23.911 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: 
2022-10-24 16:25:23.911 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: 
2022-10-24 16:25:23.912 11738-11787/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 4  threadId = IntentService[intent]
2022-10-24 16:25:23.913 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: 
2022-10-24 16:25:24.085 11738-11738/cc.fastcv.codelab D/BaseIntentService: onCreate: 
2022-10-24 16:25:24.086 11738-11738/cc.fastcv.codelab D/BaseIntentService: onStartCommand: 
2022-10-24 16:25:24.086 11738-11788/cc.fastcv.codelab D/BaseIntentService: onHandleIntent: workId = 5  threadId = IntentService[intent]
2022-10-24 16:25:24.087 11738-11738/cc.fastcv.codelab D/BaseIntentService: onDestroy: 
```

可以看到，最终的处理回调都是在子线程中进行的。我们来看看源码（比较简单的源码）

## 源码解析

首先看下这个类组成

```
public abstract class IntentService extends Service {}
```

可以看到，这是个抽象类，集成自Service。其中需要我们重写的 **onHandleIntent** 方法是个抽象方法。

```
    protected abstract void onHandleIntent(@Nullable Intent intent);
```

那它在哪个地方回调的呢？可以看到，是在一个内部类ServiceHandler中回调的。

```
    private final class ServiceHandler extends Handler {
        public ServiceHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            onHandleIntent((Intent)msg.obj);
            stopSelf(msg.arg1);
        }
    }
```

而ServiceHandler又是Handler的子类，用来接收消息，并且从ServiceHandler的构造方法可以看出，这里使用的 Looper是从外部传入的。我们看看 ServiceHandler 是在哪里被初始化的。



可以轻易的找到

```
    @Override
    public void onCreate() {
        super.onCreate();
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
        thread.start();

        mServiceLooper = thread.getLooper();
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }
```

是在Service的onCreate回调中初始化的，而Looper是在本地启动了一个 HandlerThread 之后获取的 Looper。那子线程的问题应该就可以解释的通了。



那我们的消息是怎么发送过来的呢？

从之前的学习可以知道，要接收消息的话，只能从 onStartCommand 回调中去接收，那我们来看看 onStartCommand 回调接口里面做了什么？

```
    @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    }
    
    @Override
    public void onStart(@Nullable Intent intent, int startId) {
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    }
```

哦~，原来是在onStartCommand接收的消息，然后封装成 Message ，再通过 ServiceHandler 回调出来。



虽然这个类很好用，但是，在官方文档上，Android 8.0之后 这个类被废弃掉了，推荐使用 **JobIntentService** *或者* **WorkManager**



## JobScheduler

Android从5.0开始，增加支持一种特殊的机制，即任务调度JobScheduler，为啥要先讲这个呢？

因为，我们后面要提到的 JobService 和 JobIntentService 都是基于它来工作的，包括说后面推出的WorkManager也和它有很大的渊源，所以需要先了解一下这个工具先。



App除了通过屏幕向用户展示可交互的界面元素之外，还经常需要在后台做些背地里做的事情，比如说精密计算、文件下载、统计分析、数据导入、状态监控等等，这些用户看不到的事一般放在Service中处理。



然而有时候我们希望在特定情况下再启动事务，比如说延迟若干时间之后，或者等手机空闲了再运行，这样一方面不会在系统资源紧张之时喧宾夺主，另一方面也起到削峰填谷提高系统效率的作用。对于这些额外的条件要求，Service并不能直接支持，往往需要加入其他手段，才能较好地满足相关的运行条件，比如：

- 对于延迟时间执行，通常考虑利用系统的闹钟管理器AlarmManager进行定时管理
- 对于是否联网、是否充电、是否空闲，一般要监听系统的相应广播，常见的系统广播说明如下：
    -  1、网络状态变化需要监听系统广播android.net.conn.CONNECTIVITY_CHANGE；
    -  2、设备是否充电需要监听系统广播Intent.ACTION_POWER_CONNECTED也就是android.intent.action.ACTION_POWER_CONNECTED；
    -  3、设备是否空闲需要监听系统广播Intent.ACTION_SCREEN_OFF也就是android.intent.action.SCREEN_OFF；

可是要想给Service补充以上条件，势必加大了程序逻辑的复杂度，一会儿注册这个事件，一会儿注册那个事件，工程代码将变得不易维护。



有鉴于此，Android从5.0开始，增加支持一种特殊的机制，即任务调度JobScheduler，该工具集成了常见的几种运行条件，开发者只需添加少数几行代码，即可完成原来要多种组件配合的工作。



任务调度机制由三个工具组成，首先是JobInfo，它指定了一个任务的概要信息，比如何时启动，启动时需要满足什么条件等等；其次是JobScheduler，它是系统提供的任务调度服务，它的实例从系统服务Context.JOB_SCHEDULER_SERVICE中获得；最后是JobService，它描述了该任务内部的具体业务逻辑，它的运行时刻由JobScheduler根据JobInfo指定的条件而计算决定。下面分别说明这三个工具的编码过程：



### JobInfo

任务信息的运行条件由JobInfo.Builder来构造，下面是Builder的函数说明：

- 构造函数：指定该任务来源与目的，与Intent类似，第二个参数指定了开发者自定义的JobService。
- setRequiredNetworkType：设置需要的网络条件，有三个取值：
    - JobInfo.NETWORK_TYPE_NONE（无网络时执行，默认）
    - JobInfo.NETWORK_TYPE_ANY（有网络时执行）
    - JobInfo.NETWORK_TYPE_UNMETERED（网络无需付费时执行）

- setPersisted：重启后是否还要继续执行，此时需要声明权限RECEIVE_BOOT_COMPLETED，否则会报错“java.lang.IllegalArgumentException: Error: requested job be persisted without holding RECEIVE_BOOT_COMPLETED permission.”而且RECEIVE_BOOT_COMPLETED需要在安装的时候就要声明，如果一开始没声明，而在升级时才声明，那么依然会报权限不足的错误。
- setRequiresCharging：是否在充电时执行
- setRequiresDeviceIdle：是否在空闲时执行
- setPeriodic：设置时间间隔，单位毫秒。该方法不能和setMinimumLatency、setOverrideDeadline这两个同时调用，否则会报错“java.lang.IllegalArgumentException: Can't call setMinimumLatency() on a periodic job”，或者报错“java.lang.IllegalArgumentException: Can't call setOverrideDeadline() on a periodic job”。
- setMinimumLatency：设置至少延迟多久后执行，单位毫秒。
- setOverrideDeadline：设置最多延迟多久后执行，单位毫秒。
- build：完成条件设置，返回构建好的JobInfo对象。

如：

```
        val jobinfo = JobInfo.Builder(10001, ComponentName(this, MyJobService::class.java))
            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE)
            .setPersisted(false)
            .setRequiresCharging(false)
            .setRequiresDeviceIdle(true)
            .setPeriodic(5 * 1000L)
            .build()
```



### JobScheduler

任务调度的实例从系统服务Context.JOB_SCHEDULER_SERVICE中获得，代码举例如下：

```javascript
	val js = getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler	
```

获得任务调度实例后，即可进行任务调度操作，下面是任务调度的相关方法：

- schedule：把指定的JobInfo对象放入调度队列，并在条件满足时触发该对象中定义的JobService。
- cancel：取消指定编号的任务。
- cancelAll：取消所有任务。
- getAllPendingJobs：获取所有挂起（即尚未执行）的任务。

```
        val js = getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler
        js.schedule(jobinfo)
        js.cancel(10001)
        js.cancelAll()
        for (allPendingJob in js.allPendingJobs) {
            Log.d(TAG, "test: allPendingJob.id.")
        }
```



### JobService

任务服务是一种特殊的Service，它描述了该任务内部的具体业务逻辑，需要开发者重写的方法如下： onStartJob：在任务开始执行时触发。返回false表示执行完毕，返回true表示需要开发者自己调用jobFinished方法通知系统已执行完成。 onStopJob：在任务停止执行时触发。 JobService内部另外实现了两个方法，说明如下

1、onBind方法，源码如下所示

```javascript
    public final IBinder onBind(Intent intent) {
        return mBinder.asBinder();
    }
```



JobService实现了onBind方法，表示任务调度在工作的时候，JobService是通过绑定方式启动的。



2、jobFinished方法，源码如下所示

```javascript
    public final void jobFinished(JobParameters params, boolean needsReschedule) {
        ensureHandler();
        Message m = Message.obtain(mHandler, MSG_JOB_FINISHED, params);
        m.arg2 = needsReschedule ? 1 : 0;
        m.sendToTarget();
    }
```



因为JobService由系统触发，不是在App的主线程中，所以这里通过Message机制与主线程进行通信。



示例：

```
class MyJobService : JobService() {

    companion object {
        private const val TAG = "MyJobService"
    }

    private val mHandler: Handler = object : Handler(Looper.getMainLooper()) {
        override fun handleMessage(msg: Message) {
            try {
                Thread.sleep(5000)
            } catch (e: InterruptedException) {
                e.printStackTrace()
            }
            val param = msg.obj as JobParameters
            jobFinished(param, true)
            Log.d(TAG, "jobFinished")
        }
    }


    override fun onStartJob(params: JobParameters?): Boolean {
        Log.d(TAG, "onStartJob")
        val message = Message.obtain()
        message.obj = params
        mHandler.sendMessage(message)
        //返回false表示执行完毕，返回true表示需要开发者自己调用jobFinished方法通知系统已执行完成
        return true
    }

    override fun onStopJob(params: JobParameters?): Boolean {
        //停止，不是结束。jobFinished不会直接触发onStopJob
        //必须在“onStartJob之后，jobFinished之前”取消任务，才会在jobFinished之后触发onStopJob
        Log.d(TAG, "onStopJob")
        mHandler.removeMessages(0)
        return true
    }
}
```

以上代码需要注意的是： 1、因为系统服务是通过绑定方式启动JobService，所以此时onStartCommand方法永远不会执行； 2、onStopJob顾名思义是在任务停止时触发，但是直接调用jobFinished方法并不能触发onStopJob。原因是onStopJob的触发是有条件的，首先这里的停止指的是取消任务而不是完成任务；其次必须在“onStartJob之后，jobFinished之前”取消任务，才会在jobFinished之后触发onStopJob。 另外注意在AndroidManifest.xml中补充服务声明：

```javascript
        <service
            android:name=".service.MyJobService"
            android:permission="android.permission.BIND_JOB_SERVICE" />
```



## AlarmManager



### Timer

Java中的定时器机制有现成的方案，就是Timer+TimerTask。其中TimerTask用来描述时刻到达后的事务处理，而Timer用来调度定时任务，如何时启动、间隔多久再次运行等等。

Timer的调度方法是schedule，主要有三个参数。第一个参数表示用来调度的定时任务，第二个参数表示延迟多久首次启动任务，第三个参数表示间隔多久再次启动任务。
public void schedule(TimerTask task, long delay, long period)


定时任务得自己写个继承自TimerTask的新类，并重写run方法填入具体的事务处理代码。调用Timer的schedule方法，定时任务便会按照调度设置按时启动；TimerTask不能直接设置运行的次数上限，一旦启动就会持续定时运行，除非对象销毁或者调用了TimerTask的cancel方法。调用cancel方法停止定时任务后，若想重启该定时任务，只能重新声明TimerTask对象，并且重新调用schedule方法。

Timer+TimerTask的实质是利用开启Thread来触发定时任务，所以TimerTask实际上运行于非UI线程，也就无法直接操作UI。若想在TimerTask中修改UI控件，得通过Handler发送消息来间接实现。



示例：

```
    //创建任务
    private val timerTask = object : TimerTask() {
        override fun run() {
            Log.d(TAG, "run: 执行任务 ${Thread.currentThread().name}")
        }
    }
    
    //开始任务
    val timer = Timer()
    timer.schedule(timerTask,3000,3000)
    
    //取消任务
    timerTask.cancel()
```



### CountDownTimer

CountDownTimer是Android提供的倒计时器，日常生活中时有见到倒计时的场景，比如说火箭发射倒计时。

通常我们要自定义一个CountDownTimer的派生类，并重写如下的三个方法：

- 构造函数 : 第一个参数是总的计时长度，第二个参数是每次的计时间隔（好像时钟的滴答）。
- onTick : 每次计时触发的事件。
- onFinish : 计时结束事件。

要想启动CountDownTimer计时，调用它的start方法即可，停止计时则调用cancel方法。另外倒计时器触发的onTick和onFinish都运行于非UI线程，所以与Timer一样，也得借助于Handler机制才能操作UI元素。

示例：

```
    //创建任务
    private val countDownTimer = object : CountDownTimer(60000, 1000) {
        override fun onTick(millisUntilFinished: Long) {
            Log.d(TAG, "onTick: $millisUntilFinished   ${Thread.currentThread().name}")
        }

        override fun onFinish() {
            Log.d(TAG, "onFinish:    ${Thread.currentThread().name}")
        }
    }
    
    //开始任务
    countDownTimer.start()
    
    //取消任务
    countDownTimer.cancel()
```



### AlarmManager

AlarmManager是Android提供的一个全局定时器，其使用范围要大于Timer方式。

因为Timer方式采用Thread通信，所以只适用于线程间通信，并且生命周期也有限。如果在Activity中定义Timer，那么Activity页面销毁后，定时器也失效了；如果在Application中定义Timer，那么APP退出后，定时器也要失效。相比之下，AlarmManager利用系统的提醒服务定时发送广播，所以不但适用于线程间通信，而且也适用于进程间通信。另外，由于是系统服务发送广播，因此只要再次打开APP，就会自动收到广播发来的定时任务。

AlarmManager常用的启动方法有两个：

- set : 该方法用于设置一次性定时器。第一个参数表示定时器类型，第二个参数表示任务执行时间，第三个参数表示定时任务。
- setRepeating : 该方法用于设置重复定时器。第一个参数表示定时器类型，第二个参数表示任务首次执行时间，第三个参数表示再次执行的间隔时间，第四个参数表示定时任务。其中定时器类型主要取值有：
  RTC_WAKEUP : 表示定时器即使在睡眠状态下也会启用，此时定时器使用系统时间
  RTC : 表示定时器在睡眠状态下不可用，此时定时器使用系统时间
  ELAPSED_REALTIME_WAKEUP : 表示定时器即使在睡眠状态下也会启用，此时定时器使用相对时间（相对于系统启动开始）
  ELAPSED_REALTIME : 表示定时器在睡眠状态下不可用，此时定时器使用相对时间



因为AlarmManager使用的是系统服务来发送广播，所以在注册广播接收器时需要注意以下几点：
**1、要在AndroidManifest.xml中定义receiver**
**2、代码中注册接收器必须使用Context.registerReceiver，不能使用LocalBroadcastManager来注册**



AlarmManager启动方法中的定时任务使用了PendingIntent类，PendingIntent顾名思义就是一个延迟处理的通信工具。PendingIntent的实例可通过下列三种方法得到：

- getActivity : 获取用于启动页面的实例
- getService : 获取用于启动服务的实例
- getBroadcast : 获取用于发送广播的实例

三个方法的参数是一样的，第一个参数表示Context，第二个参数表示请求代码用于标识本次请求的唯一性，第三个参数表示Intent实例（可捆绑具体参数信息Bundle），第四个参数表示PendingIntent的启动标志，具体取值说明如下：

- FLAG_ONE_SHOT : 此时启动的PendingIntent只能使用一次。
- FLAG_NO_CREATE : 如果不存在描述的PendingIntent，则不会创建新任务。
- FLAG_CANCEL_CURRENT : 如果已存在描述的PendingIntent，则先取消该任务再创建新任务。
- FLAG_UPDATE_CURRENT : 一般用这个标志。如果已存在描述的PendingIntent，则更新而不是取消该任务。



示例：

```
        //创建任务
        val filter = IntentFilter("cc.fastcv.codelab.alarmReceiver")
        registerReceiver(alarmReceiver, filter)

        val intent = Intent("cc.fastcv.codelab.alarmReceiver")
        val pIntent = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            PendingIntent.getBroadcast(
                this, R.string.app_name, intent, PendingIntent.FLAG_UPDATE_CURRENT or  PendingIntent.FLAG_IMMUTABLE)
        } else {
            PendingIntent.getBroadcast(
                this, R.string.app_name, intent, PendingIntent.FLAG_UPDATE_CURRENT)
        }

        Log.d(TAG, "onCreate: 发送警告任务")
        val alarmMgr = getSystemService(ALARM_SERVICE) as AlarmManager
        alarmMgr.setRepeating(
            AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 3000, pIntent);
            
        //设置接收器
        private val alarmReceiver = object  : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                Log.d(TAG, "onReceive: 收到警报消息")
            }
        }
        val filter = IntentFilter("cc.fastcv.codelab.alarmReceiver")
        registerReceiver(alarmReceiver, filter)
        
        
```



## JobIntentService

JobIntentService实质为Service其继承关系如下所示。

```
 java.lang.Object
    ↳   android.content.Context
       ↳    android.content.ContextWrapper
           ↳    android.app.Service
               ↳    android.support.v4.app.JobIntentService
```

用于处理被加入到job或service任务的一个辅助工具。

- 8.0以下被当作普通的Intent使用startSerivce()启动service来执行。
- 8.0以上任务被作为job用jobScheduler.enqueue()方法来分发。



说到Jobscheduler，应该不陌生了，框架提供的用来APP调度任务的接口，根据APP要求构建JobInfo，系统会在适当的时间调用JobInfo指定的JobService来执行你的任务。

所以在Android8.0及以上JobIntentService和JobService做的事情是相同的，都是等着JobScheduler分配任务来执行。

不同点在于，JobService使用的handler使用的是主线程的Looper，因此需要在onStartJob（）中手动创建AsyncTask去执行耗时任务，而JobIntentService则帮我们处理这一过程，使用它只需要写需要做的任务逻辑即可，不用关心卡住主线程的问题。另外，向jobScheduler传递任务操作也更简单了，不需要在指定JobInfo中的参数，直接enqueue(context,intent)就可以。

这有点像Service和IntentService的关系。



示例：

```
    Intent workIntent = new Intent();
    workIntent.putExtra("work","work num:"+num);
    MyJobIntentService.enqueueWork(getApplicationContext(),workIntent);
```

```
public class MyJobIntentService extends JobIntentService {

    /**
     * 这个Service 唯一的id
     */
    static final int JOB_ID = 10111;

    /**
     * Convenience method for enqueuing work in to this service.
     */
    static void enqueueWork(Context context, Intent work) {
        enqueueWork(context, MyJobIntentService.class, JOB_ID, work);
    }

    @Override
    protected void onHandleWork( Intent intent) {
        Log.d("houson", "onHandleWork: "+intent.getStringExtra("work").toString());
    }
}
```

注意manifest！

```
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<service android:name=".MyJobIntentService"></service>
```





## WorkManager

关于workmanager 的介绍 官网上是这么说的: **使用 WorkManager API 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。** 重点是后面的几个字,运行可延迟的异步任务, 在退出或者重启的时候,我们在之前要实现这种任务可能需要 BroadcastReceiver 或者 AlarmManager,现在的话可以使用WorkManager,这个框架最高兼容至Android api 14。

- Android 23以上是采用JobScheduler
- Android 14-22 采用的是BroadcastReceiver 和 AlarmManager



要使用的话，需要添加依赖：

```
       def work_version = "2.3.1"

        // (Java only)
        implementation "androidx.work:work-runtime:$work_version"//java 语言选这个

        // Kotlin + coroutines
        implementation "androidx.work:work-runtime-ktx:$work_version"//kotlin 选这个
```



在使用之前，我们介绍下它的几个成员：

### Worker

任务的执行者，是一个抽象类，用于指定需要执行的具体任务，需要实现doWork() 这一个方法，它是执行在一个单独的后台线程里的。所有需要在后台执行的任务都在这个方法里完成。
doWork()函数的返回值：

- Worker.Result.SUCCESS:任务执行成功。
- Worker.Result.FAILURE:任务执行失败。
- Worker.Result.RETRY:任务需要重新执行，如果出现这个返回结果，就需要与WorkRequest.Builder中的setBackoffCriteria()函数一起使用。

如：

```
class UploadPicWork(
    private val context: Context,
    private val workerParameters: WorkerParameters
) :
    Worker(context, workerParameters) {
    override fun doWork(): Result {

       val params = inputData.getString("params_tag")//获取传递的参数

        try {
            uploadPic()//上传图片
        } catch (e: Exception) {
            return Result.failure(Data())//执行失败了
        }

        return Result.success()
    }
}

```



### WorkRequest

代表一个单独的任务，对Worker任务进行包装，一个WorkRequest对应一个Worker类。可以通过WorkRequest来给Worker类添加约束细节，比如设备是否空闲，设备电池是否不应低于临界阈值，指定设备在充电时是否启动任务等等。WorkRequest是一个抽象类，具体要使用两个子类：

- OneTimeWorkRequest(任务只执行一遍)
- PeriodicWorkRequest(任务周期性的执行)。

如：

```
val UploadPicWork =
                OneTimeWorkRequestBuilder<UploadPicWork>()
                    .setInputData(workDataOf("params_tag" to "params"))//传递参数
                    .setConstraints(triggerContentMaxDelay)//设置约束条件
                    .addTag("tag")//设置tag
                    .build()
```



#### WorkRequest加标签

可以通过addTag给WorkRequest加入标签，比如：

```kotlin
 PeriodicWorkRequest request = new PeriodicWorkRequest.Builder(MyWorker.class, 15, TimeUnit.SECONDS)
                .setInputData(data)
                .addTag("A")
                .build();
PeriodicWorkRequest request2 = new PeriodicWorkRequest.Builder(MyWorker.class, 15, TimeUnit.SECONDS)
                .setInputData(data)
                .addTag("A")
                .build();
```

通过addTag()，将WorkRequest成为了一个组：A组。以后可以直接控制整个组就行了，组内的每个成员都会受到影响。比如通过WorkManager的cancelAllWorkByTag(String tag):取消一组带有相同标签的任务。





#### 获取 **WorkInfo**

- 听过 **id** 获取,可以听过 **WorkManager.getWorkInfoById(UUID)** 或 **WorkManager.getWorkInfoByIdLiveData(UUID)** 来通过 **WorkRequest id** 来获取 **WorkInfo**。



```kotlin
 WorkManager.getInstance(this)
                .getWorkInfoByIdLiveData(UploadPicWork.id)// 通过id 获取
                .observe(this, Observer { //it:WorkInfo
                    it?.apply {
                        when (this.state) {
                            WorkInfo.State.BLOCKED -> println("BLOCKED")
                            WorkInfo.State.CANCELLED -> println("CANCELLED")
                            WorkInfo.State.RUNNING -> println("RUNNING")
                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")
                            WorkInfo.State.FAILED -> println("FAILED")
                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")
                            else -> println("else status ${this.state}")
                        }
                    }

                })
```

- 通过 **tag** 获取,可以利用 **WorkManager.getWorkInfosByTag(String)** 或 **WorkManager.getWorkInfosByTagLiveData(String)** 来通过 **WorkRequest** 的 **WorkInfo** 对象。



```kotlin
//要通过 tag 获取,则需要先设置 tag
val UploadPicWork =
                OneTimeWorkRequestBuilder<UploadPicWork>()
                    .setInputData(workDataOf("params_tag" to "params"))//传递参数
                    .setConstraints(triggerContentMaxDelay)//设置约束条件
                    .addTag("tag")//设置tag
                    .build()

//获取 workInfo

WorkManager.getInstance(this)
                .getWorkInfosByTagLiveData("tag")
                .observe(this, Observer {it:List<WorkInfo>//此处返回的是一个集合,作为示例代码,默认只取 0 index
                    it?.apply {
                        when (this[0].state) {
                            WorkInfo.State.BLOCKED -> println("BLOCKED")
                            WorkInfo.State.CANCELLED -> println("CANCELLED")
                            WorkInfo.State.RUNNING -> println("RUNNING")
                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")
                            WorkInfo.State.FAILED -> println("FAILED")
                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")
                            else -> println("else status ${this[0]}")
                        }
                    }

                })
```

- 对于 **唯一工作名称** 的一个 **Worker** ,可以利用 **WorkManager.getWorkInfosForUniqueWork(String)** 或 **WorkManager.getWorkInfosForUniqueWorkLiveData(String)** 检索所有匹配的 **WorkRequest** 的 **WorkInfo** 对象。此处估计不太好理解,唯一工作是一个概念性非常强的术语，可确保一次只有一个具有特定名称的工作链。与 id 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 **WorkManager** 自动生成。与标记不同，唯一名称仅与“一个”工作链关联。您可以通过调用 **WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)** 或 **WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest)** 创建唯一工作序列。



```kotlin
WorkManager.getInstance(this)
                .getWorkInfosForUniqueWorkLiveData("UploadPicWork")//唯一工作名称 
                .observe(this, Observer {it:List<WorkInfo> //此处返回的是一个集合,作为示例代码,默认只取 0

                    it?.apply {
                        when (this[0].state) {
                            WorkInfo.State.BLOCKED -> println("BLOCKED")
                            WorkInfo.State.CANCELLED -> println("CANCELLED")
                            WorkInfo.State.RUNNING -> println("RUNNING")
                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")
                            WorkInfo.State.FAILED -> println("FAILED")
                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")
                            else -> println("else status ${this[0]}")
                        }
                    }

                })
```

> 注意如采用这种方式获取 **workinfo** ,在执行 **worker** 的时候与之前不一样,需要采用 **WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)** 或 **WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest)** 来执行



```kotlin
//全部代码如下


//创建约束条件
val triggerContentMaxDelay =
                Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED)
//                    .setRequiresDeviceIdle(false)
                    .setRequiresBatteryNotLow(true)
                    .setRequiresStorageNotLow(true)
                    .setRequiresCharging(true)
                    .setTriggerContentMaxDelay(1000 * 1, TimeUnit.MILLISECONDS)
                    .build()

// 创建workrequest
            val UploadPicWork =
                OneTimeWorkRequestBuilder<UploadPicWork>()
                    .setInputData(workDataOf("params_tag" to "params"))
                    .setConstraints(triggerContentMaxDelay)
                    .build()

    //注意!!!,此处区别与之前的 WorkManager.getInstance(this).enqueue(UploadPicWork)
    
    // "UploadPicWork" 需要与下面代码 getWorkInfosForUniqueWorkLiveData("UploadPicWork") 中字符串对应
    // ExistingWorkPolicy.APPEND 一个枚举值,worker 执行的策略,想要了解的同学,可以看下面的链接
    WorkManager.getInstance(this).enqueueUniqueWork("UploadPicWork",ExistingWorkPolicy.APPEND,UploadPicWork)

            WorkManager.getInstance(this)
                .getWorkInfosForUniqueWorkLiveData("UploadPicWork")
                .observe(this, Observer {

                    it?.apply {
                        when (this[0].state) {
                            WorkInfo.State.BLOCKED -> println("BLOCKED")
                            WorkInfo.State.CANCELLED -> println("CANCELLED")
                            WorkInfo.State.RUNNING -> println("RUNNING")
                            WorkInfo.State.ENQUEUED -> println("ENQUEUED")
                            WorkInfo.State.FAILED -> println("FAILED")
                            WorkInfo.State.SUCCEEDED -> println("SUCCEEDED")
                            else -> println("else status ${this[0]}")
                        }
                    }
```



### WorkManager

主要管理任务请求和任务队列，将WorkRequest加入任务队列。 通过WorkManager来调度任务，以分散系统资源的负载。



### WorkStatus

当 WorkManager 把任务加入队列后，会为每个WorkRequest对象提供一个 LiveData， LiveData 持有 WorkStatus，包含有任务的状态和任务的信息。

```
public enum State {

    ENQUEUED,

    RUNNING,

    SUCCEEDED,

    FAILED,

    BLOCKED,

    CANCELLED;

    public boolean isFinished() {
        return (this == SUCCEEDED || this == FAILED || this == CANCELLED);
    }
}
```







### 基本用法

基本用法分为3步：

1. 定义后台任务，并实现相关逻辑
2. 配置该后台任务的运行条件和约束条件
3. 构建后台任务请求

**定义后台任务，并实现相关逻辑**
定义自己的Worker类继承自Worker类并重写doWork方法

doWork方法指定Worker类如何执行操作，但是不能出现任何关于任务何时运行的信息

```

class myWorker(context: Context, params: WorkerParameters) : Worker(context, params){
    override fun doWork() : Result{
        //执行操作
        return Result.success()
    }
}
```

**配置该后台任务的运行条件和约束条件**
在MainActivity中根据myWorker类创建OneTimeWorkRequest对象

```
val myConstraints = Constraints.Builder().build()
val myRequest = OneTimeWorkRequest.Builder(myWorker::class.java)
                                  .setConstraints(myContraints)
                                  .build()
```


OneTimeWorkRequest.Builder用于构建单次运行的后台任务请求

PeriodicWorkRequest.Builder用于构建周期运行的后台任务请求，且运行间隔不能短于15 mins

在创建Constraints和创建WorkRequest时可以配置各种各样的运行条件和约束条件



**构建后台任务请求**
在MainActivity中将该后台任务请求传入WorkManager的enqueue方法。

```
WorkManager.getInstance(this).enqueue(myRequest)
```



检查任务状态方法：

```
 WorkManager.getInstance(this).getWorkInfoByIdLiveData(myRequest.id)
                              .observe(this){ workInfo ->
 	if (workInfo.state == WorkInfo.State.SUCCEEDED){
                //利用workInfo对结果进行判断
    }
}
```



取消任务方法：

```
WorkManager.getInstance(this).cancelByWorkId(myRequest.id)
```





### 含参Worker类

使用键值对和Data对象进行参数的输入和结果的返回。

在主函数中通过观察任务的WorkStatus获取输出



TestWorker类


    class TestWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
        companion object{
            const val KEY_INT_ARG = "INT"
            const val KEY_STR_ARG = "STR"
            const val KEY_LIST_ARG = "LIST"
            const val KEY_CLASS_ARG = "CLASS"
            const val KEY_RESULT = "RESULT"
        }
        @SuppressLint("RestrictedApi")
        override fun doWork(): Result {
        //获取参数
        val int = inputData.getInt(KEY_INT_ARG, 0)
        println("int:$int.toString()")
        val str = inputData.getString(KEY_STR_ARG)
        /**
         * 仅传递基础数据类型和其构成的数组
         * 对于类和类组成的数组，需要使用Gson转换成json字符串
         * Gson依赖：implementation 'com.google.code.gson:gson:2.8.6'
         */
        val list: ArrayList<TestClass> = Gson().fromJson(
            inputData.getString(KEY_LIST_ARG),
            object : TypeToken<ArrayList<TestClass>>() {}.type
        )
        val cls: TestClass = Gson().fromJson(
            inputData.getString(KEY_CLASS_ARG),
            object : TypeToken<TestClass>() {}.type
        )
    
        //对参数进行操作
        println("TestWorker:")
        println("int:$int.toString()")
        println("str:$str")
        for (item in list){
            println("list:${item.text}")
        }
        println("class:${cls.text}")
    
        //返回值
        val listString = Gson().toJson(list)
        val result = Data.Builder().putString(KEY_RESULT, listString).build()
        return Result.Success(result)
    }
    }

主函数

```
class MainActivity : AppCompatActivity() {
    @SuppressLint("EnqueueWork")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        //非基本类型参数转换成String
        val cls = TestClass("TestClass")
        val clsString = Gson().toJson(cls)
        val list = ArrayList<TestClass>()
        list.add(TestClass("TestClass1"))
        list.add(TestClass("TestClass2"))
        list.add(TestClass("TestClass3"))
        val listString = Gson().toJson(list)
        //创建参数
        val myData = Data.Builder().putInt(TestWorker.KEY_INT_ARG, 999)
                                   .putString(TestWorker.KEY_STR_ARG, "String")
                                   .putString(TestWorker.KEY_CLASS_ARG, clsString)
                                   .putString(TestWorker.KEY_LIST_ARG, listString)
                                   .build()
        //构建后台
        val work = OneTimeWorkRequest.Builder(TestWorker::class.java)
                                     .setInputData(myData)
                                     .build()
        WorkManager.getInstance(this).enqueue(work)
        //获得返回值
        WorkManager.getInstance(this).getWorkInfoByIdLiveData(work.id)
                                     .observe(this){workInfo ->
            val str = workInfo.outputData.getString(TestWorker.KEY_RESULT)
            if (str != null){
                val result: ArrayList<TestClass> = Gson().fromJson(str, object : TypeToken<ArrayList<TestClass>>() {}.type)
                for (item in result){
                    println("result:${item.text}")
                }
            }
        }
    }
}
```


链式任务
WorkManager允许我们创建和排队多个任务的工作序列，以及它们按照什么顺序运行。

任何一个任务返回Work.WorkResult.FAILURE，整个序列结束

```
WorkManager.getInstance(this).beginWith(workA)
                             .then(workB)
                             .then(workC)
                             .enqueue()
```


允许多个对象传递给begin()和then()

WorkManager并行运行同一次方法传进的任务

```
WorkManager.getInstance(this).beginWith(listOf(workerA1, workerA2, workerA3))
                             .then(listOf(workerB1, workerB2))
                             .then(workerC)
                             .enqueue()
```


允许使用WorkContinuation.combine方法连接多个链

WorkManager根据连接链的顺序依次运行。

链内任务按顺序执行

链间任务可能重叠导致任务顺序的改变。

```
val chain1 = WorkManager.getInstance(this)
                         .beginWith(workerA1)
                         .then(workerB1)
val chain2 = WorkManager.getInstance(this)
                        .beginWith(workerA2)
                        .then(workerB2)
WorkContinuation.combine(listOf(chain1, chain2))
                .then(workerC)
                .enqueue()
```





# IPC

为啥要在这里突然提起IPC呢？ 因为服务在我们日常的开发中，它还有一个重要的使用场景：作为一个子进程！！！，既然有多个进程，肯定会涉及到进程间通信的问题。那 **进程间通信** 就是 **IPC** 了



IPC (Inter processCommunication) 就是指的是不同进程之间的数据交换。也被叫做进程间通信。那么，在安卓中，我们怎么去测试多进程的内容。这个就首先涉及到了安卓应用开启多进程的方式。我们只需要在四大组件的xml属性中加上

```
android:precess = "xxx"
```

就可以了。



既然分了多个进程，肯定会出现数据不同步的问题，大佬们总结了一下，有一下几个：

- 静态成员和单例完全失效
- 线程同步机制完全失效
- SharedPreferences的可靠性下降
- Apllication会多次创建

这个问题总的来说，就是因为不在同一个进程，没有共享内存，那么生成的字节码相互之间访问不了，地址都不同，肯定是会出问题的。这就涉及到了跨进程通信的使用了。



这里，我们就在服务里面使用

```
android:precess = "xxx"
```

属性将其变为子进程。再看看之前的绑定交换数据的操作能不能成功。

emmmmm , 一运行就出问题了

```
    java.lang.ClassCastException: android.os.BinderProxy cannot be cast to cc.fastcv.codelab.services.BaseBinder
```

它告诉我无法强转？ 我就是返回的 BaseBinder 对象呀，为啥无法强转呢？



因为我们返回的是这个对象的引用，但是在不同的进程里面，都不在同一块内存了，引用根本无法访问，更别说强转了。那该怎么办呢？



无法访问对象引用，那只能将数据完完整整的传递过去了。常见的IPC方式有：

## 跨进程通信的方式

### 广播

广播的话，是最容易理解的，就比如系统广播一样，可以携带一些数据给其他应用。这个可以去看广播的章节。

### 内容提供者

这个也是一样的，提供一个URI给外部应用区访问内部应用的数据库数据。这个可以去看内容提供者的章节。

### Socket

这个也可以理解，直接以网络的形式进行数据传输。





### Messenger

Messenger可以翻译为信使，顾名思义，通过它可以在不同进程传递Message对象，在Message中放入我们需要传递的数据，就可以轻松的实现数据的进程间传递了。Messenger是一种轻量级的IPC方案，就像上面说的，它的底层实现时AIDL。



#### 服务端

我们首先实现一个服务端：

```
class BaseService : Service() {
    companion object {
        private const val TAG = "BaseService"
    }

    private val messengerHandler = object : Handler(Looper.getMainLooper()) {
        override fun handleMessage(msg: Message) {
            Log.d(TAG, "receive msg from Client: " + msg.data.getString("msg"))
        }
    }

    private val messenger = Messenger(messengerHandler)

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "onCreate: ${Thread.currentThread().name}")
    }

    override fun onBind(intent: Intent?): IBinder? {
        return messenger.binder
    }
}
```

注册为单个进程

```
    <service android:name="xxx"
            android:process=":remote"/>
```



#### 客户端

再实现客户端：

```
    private var messenger: Messenger? = null

    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            Log.d(TAG, "onServiceConnected: ")
            messenger = Messenger(service)
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            Log.d(TAG, "onServiceDisconnected: ")
        }
    }
```



#### 消息

发送消息：

```
    val message = Message.obtain()
    val bundle = Bundle()
    bundle.putString("msg","Hello I'm Client")
    message.data = bundle
    messenger?.send(message)
```



#### 结果

结果：

```
2022-10-24 17:30:30.080 16283-16283/cc.fastcv.codelab D/MainActivity: onCreate: 
2022-10-24 17:30:33.282 16458-16458/cc.fastcv.codelab D/BaseService: onCreate: main
2022-10-24 17:30:33.282 16458-16458/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 17:30:33.284 16283-16283/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 17:30:35.763 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I'm Client
2022-10-24 17:30:36.924 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I'm Client
2022-10-24 17:30:39.025 16458-16458/cc.fastcv.codelab D/BaseService: unbindService: 
2022-10-24 17:30:39.026 16458-16458/cc.fastcv.codelab D/BaseService: onDestroy: 
2022-10-24 17:30:40.699 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I'm Client
2022-10-24 17:30:41.532 16458-16458/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I'm Client
```

从结果上看，我们明明已经停止服务了。为啥还可以继续发送消息呢？



这是因为，我们的 Binder 服务已经跑起来了，相互建立连接后，依赖的是 Binder 服务在通信，和Service无关了。



#### 异常处理

如果我们的远程服务进程死掉了，那么我们再发送消息的时候就会出现一个异常：

```
     Caused by: android.os.DeadObjectException
        at android.os.BinderProxy.transactNative(Native Method)
        at android.os.BinderProxy.transact(BinderProxy.java:510)
        at android.os.IMessenger$Stub$Proxy.send(IMessenger.java:123)
        at android.os.Messenger.send(Messenger.java:57)
        at com.example.pipixia.MainActivity.send(MainActivity.kt:68)
```

所以，我们在发送消息时，需要做异常处理。

```
    fun send(view: View?) {
        val message = Message.obtain()
        val bundle = Bundle()
        bundle.putString("msg","Hello I'm Client")
        message.data = bundle

        try {
            messenger?.send(message)
        } catch (e: RemoteException) {
            Log.d(TAG, "send: messenger 消息发送失败")
        }
    }
```



#### 双向通信

其实，实现双向通信的诀窍在 Message 的 replyTo 字段上，我们可以把我们客户端加一个 Messenger 当成一个 服务端来使用。只要将客户端服务器的 binder 地址发送给服务端即可。



客户端

```
    //新增服务
    private val messengerHandler = object : Handler(Looper.getMainLooper()) {
        override fun handleMessage(msg: Message) {
            Log.d(TAG, "receive msg from Server: " + msg.data.getString("msg"))
        }
    }

    private val messengerServer = Messenger(messengerHandler)
    
    //发送消息时 带上服务地址
    val message = Message.obtain()
    val bundle = Bundle()
    bundle.putString("msg","Hello I'm Client")
    message.data = bundle
    message.replyTo = messengerServer
    messenger?.send(message)
```



服务端：

```
    //收到消息 回复
    val message = Message.obtain()
    val bundle = Bundle()
    bundle.putString("msg","Hello I'm Server")
    message.data = bundle
    msg.replyTo.send(message)
```



结果：

```
2022-10-24 17:47:32.433 17222-17222/cc.fastcv.codelab D/MainActivity: onCreate: 
2022-10-24 17:47:39.798 17280-17280/cc.fastcv.codelab D/BaseService: onCreate: main
2022-10-24 17:47:39.799 17280-17280/cc.fastcv.codelab D/BaseService: onBind: 
2022-10-24 17:47:39.801 17222-17222/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-24 17:47:43.332 17280-17280/cc.fastcv.codelab D/BaseService: receive msg from Client: Hello I'm Client
2022-10-24 17:47:43.333 17222-17222/cc.fastcv.codelab D/MainActivity: receive msg from Server: Hello I'm Server
```



**总结**

- 优点：使用简单，上手很快
- 缺点：执行方法时串行的，只能一个一个的执行，不能进行大量的并发处理。这个时候还是得用AIDL。





### AIDl

AIDL是Android中**IPC（Inter-Process Communication）**方式中的一种，AIDL是**Android Interface definition language**的缩写，对于小白来说，AIDL的作用是让你可以在自己的APP里绑定一个其他APP的service，这样你的APP可以和其他APP交互。



#### 单向读写数据

通过as我们在我们的包下新建一个AIDL文件，我们项目目录就会出现一个aidl文件夹，里面有我们刚才新建的那个AIDL文件，查看文件可以看到，如

```
interface IMyAidlInterface {
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);
}
```



**序列化**

前面说过，如果要把数据跨进程传输，需要把数据序列化之后才行，所以，这里我们举个例子，将Book类实现序列化接口：

```
data class Book(var bookId: Int, var bookName: String?) : Parcelable {
    constructor(parcel: Parcel) : this(parcel.readInt(), parcel.readString()) {}

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeInt(bookId)
        parcel.writeString (bookName)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator<Book> {
        override fun createFromParcel(parcel: Parcel): Book {
            return Book(parcel)
        }

        override fun newArray(size: Int): Array<Book?> {
            return arrayOfNulls(size)
        }
    }
}
```



**实现AIDL文件**

```
import cc.fastcv.codelab.Book;

interface IBookManagerInterface {

    //得到所有的书籍
    List<Book> getBookList();

    //新增书籍
    void addBook(in Book book);
}
```



**构建module自动生成类文件**

我们build下我们的项目模块，然后可以在

```
build/generated/aidl_source_output_dir/[debug|release]/out/<packageName>/xxx/xxxx.java
```

我们可以点开看一下：(这里我们把它拆解一下)

```
public interface IBookManagerInterface extends android.os.IInterface
{
  public static class Default implements cc.fastcv.codelab.IBookManagerInterface
  { ... }

  public static abstract class Stub extends android.os.Binder implements cc.fastcv.codelab.IBookManagerInterface
  {
    ...
    
    private static class Proxy implements cc.fastcv.codelab.IBookManagerInterface
    {
     ...
    }
  }
  //得到所有的书籍

  public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException;
  //新增书籍

  public void addBook(cc.fastcv.codelab.Book book) throws android.os.RemoteException;
}
```

这样子，整体结构就比较清晰了，首先是一个大的接口类：**IBookManagerInterface**，然后在内部有一个静态的默认实现类Default实现了IBookManagerInterface接口。还有一个抽象代理类**Stub**也实现了IBookManagerInterface并且继承自 **android.os.Binder**，如果你仔细看这个Stub类的内容，你会发现很多很奇怪的内容，如：

```
        case TRANSACTION_getBookList:
        {
          data.enforceInterface(descriptor);
          java.util.List<cc.fastcv.codelab.Book> _result = this.getBookList();
          reply.writeNoException();
          reply.writeTypedList(_result);
          return true;
        }
```

还有就是它本身没有实现IBookManagerInterface接口的方法，它只是定义了一些常量和相应常量的底层处理逻辑。那谁实现了IBookManagerInterface接口？



没错就是最后一个类 Proxy 实现的这个接口，从它的内容来看，它并不关心底层的逻辑是怎么样处理的，它只用实现 IBookManagerInterface 的方法，然后通过 ``` android.os.IBinder mRemote ``` 来实现底层逻辑，如：

```
            @Override
            public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                java.util.List<cc.fastcv.codelab.Book> _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);
                    if (!_status && getDefaultImpl() != null) {
                        return getDefaultImpl().getBookList();
                    }
                    _reply.readException();
                    _result = _reply.createTypedArrayList(cc.fastcv.codelab.Book.CREATOR);
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
```





**服务端**

```
class BookService : Service() {
    companion object {
        val TAG = "ServerService"
    }

    val manager = object : IBookManagerInterface.Stub() {
        override fun getBookList(): MutableList<Book> {
            Log.d(TAG, "getBookList:  pid = ${myPid()}")
            return books
        }

        override fun addBook(book: Book?) {
            Log.d(TAG, "addBook: $book  pid = ${myPid()}")
            books.add(book!!)
        }
    }

    val books = ArrayList<Book>()

    override fun onBind(intent: Intent?): IBinder? {
        Log.d(TAG, "onBind: ")
        return manager
    }

    override fun onUnbind(intent: Intent?): Boolean {
        Log.d(TAG, "onUnbind: ")
        return super.onUnbind(intent)
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy: ")
    }
}
```

记得在清单文件加上

```
        <service android:name=".services.BookService"
            android:process=":remote"/>
```



**客户端**

```
    var stub:IBookManagerInterface? = null

    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            Log.d(TAG, "onServiceConnected: ")
            stub = IBookManagerInterface.Stub.asInterface(service)
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            Log.d(TAG, "onServiceDisconnected: ")
        }
    }
```



新增

```
       stub?.addBook(Book(index++,"C语言$index 册"))
```



查询

```
        stub?.bookList?.let {
            for (book in it) {
                Log.d(TAG, "书籍信息: $book")
            }
        }
```



结果：

```
2022-10-25 14:10:12.960 13642-13656/cc.fastcv.codelab D/ServerService: getBookList:  pid = 13642
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=1, bookName=C语言2 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=2, bookName=C语言3 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=3, bookName=C语言4 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=4, bookName=C语言5 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=5, bookName=C语言6 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=6, bookName=C语言7 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=7, bookName=C语言8 册)
2022-10-25 14:10:12.961 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=8, bookName=C语言9 册)
2022-10-25 14:10:26.973 13642-13656/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=9, bookName=C语言10 册)  pid = 13642
2022-10-25 14:10:31.545 13642-13656/cc.fastcv.codelab D/ServerService: getBookList:  pid = 13642
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=1, bookName=C语言2 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=2, bookName=C语言3 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=3, bookName=C语言4 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=4, bookName=C语言5 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=5, bookName=C语言6 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=6, bookName=C语言7 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=7, bookName=C语言8 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=8, bookName=C语言9 册)
2022-10-25 14:10:31.545 13545-13545/cc.fastcv.codelab D/MainActivity: 书籍信息: Book(bookId=9, bookName=C语言10 册)
```



#### 双向读写数据

在实现双向读写数据时，我们先记住一些常识，如AIDL支持的数据类型有哪些

- 基本数据类型（int、long、char、boolean、double等）
- String 和 CharSequence
- List：只支持ArrayList，里面的每个元素都必须能够被AIDL支持
- Map：只支持HashMap，里面的每个元素都必须能够被AIDL支持，包括key和value
- Parcelable：所有实现了Parcelable接口的对象
- AIDL ：所有的AIDL接口本身也可以在AIDL文件中使用

但是，其中自定义的parcelable对象和AIDL对象必须显示import进来，不管它们是否和当前的AIDL文件位于同一个包内。就像我们的Book

```
import cc.fastcv.codelab.Book;
```



接下来，我们想象一下，怎么样实现双向读写数据。从上面的代码，我们可以看到，客户端向服务器读写数据时，是拿到了服务器的一个BInder对象然后进行数据读写的，那么我们可不可以逆向思维，把客户端也当成一个服务器，实现一个BInder接口。因为上面说了，可以把AIDL接口本身进行传递，我们来试一下



**首先实现客户端接收消息的AIDL**

```
interface IServerNotyfyInterface {
    void nofity(int limit);
}
```

然后，修改之前服务端实现的接口，需要把我们客户端的接口注册过去，还得取消注册

```
import cc.fastcv.codelab.Book;
import cc.fastcv.codelab.IServerNotyfyInterface;

interface IBookManagerInterface {

    //得到所有的书籍
    List<Book> getBookList();

    //新增书籍
    void addBook(in Book book);

    //传入我们的Binder
    void register(IServerNotyfyInterface listener);

    //取消监听
    void unRegister(IServerNotyfyInterface listener);
}
```



**实现客户端接收消息**

```
    val listener = object : IServerNotyfyInterface.Stub() {
        override fun nofity(limit: Int) {
            Log.d(TAG, "nofity: limit = $limit")
        }
    }
```

```
    //注册监听
    stub?.register(listener)
    //注销监听
    stub?.register(listener)
```



**服务端接收客户端的binder注册和反注册**

```
    var notify:IServerNotyfyInterface? = null

    val manager = object : IBookManagerInterface.Stub() {
        override fun getBookList(): MutableList<Book> {
            Log.d(TAG, "getBookList:  pid = ${myPid()}")
            return books
        }

        override fun addBook(book: Book?) {
            Log.d(TAG, "addBook: $book  pid = ${myPid()}")
            if (notify != null && notify!!.asBinder().isBinderAlive && books.size%5 == 0) {
                notify!!.nofity(books.size)
            }
            books.add(book!!)
        }

        override fun register(listener: IServerNotyfyInterface?) {
            Log.d(TAG, "register: ${listener.hashCode()}")
            notify = listener
        }

        override fun unRegister(listener: IServerNotyfyInterface?) {
            Log.d(TAG, "register: ${listener.hashCode()}")
            notify = null
        }
    }
```

在代码中可以看到，我们添加书籍的数量达到5的倍数后就会提醒客户端一次。

```
2022-10-25 15:22:37.921 23575-23575/cc.fastcv.codelab D/ServerService: onBind: 
2022-10-25 15:22:37.922 23521-23521/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-25 15:22:37.923 23575-23588/cc.fastcv.codelab D/ServerService: register: 107797164
2022-10-25 15:22:44.897 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=1, bookName=C语言2 册)  pid = 23575
2022-10-25 15:22:44.898 23521-23521/cc.fastcv.codelab D/MainActivity: nofity: limit = 0
2022-10-25 15:22:47.277 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=2, bookName=C语言3 册)  pid = 23575
2022-10-25 15:22:49.655 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=3, bookName=C语言4 册)  pid = 23575
2022-10-25 15:22:51.132 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=4, bookName=C语言5 册)  pid = 23575
2022-10-25 15:22:52.287 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=5, bookName=C语言6 册)  pid = 23575
2022-10-25 15:22:53.610 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=6, bookName=C语言7 册)  pid = 23575
2022-10-25 15:22:53.611 23521-23521/cc.fastcv.codelab D/MainActivity: nofity: limit = 5
2022-10-25 15:22:55.674 23521-23533/cc.fastcv.codelab W/System: A resource failed to call close. 
2022-10-25 15:22:55.726 23575-23588/cc.fastcv.codelab D/ServerService: addBook: Book(bookId=7, bookName=C语言8 册)  pid = 23575
```

这样子，我们就实现了双向读写操作了。



这里还存在一个问题

我们看，我们注册的listener的hashcode和 取消注册的hashcode 的值

```
2022-10-25 15:28:54.154 23929-23929/cc.fastcv.codelab D/ServerService: onBind: 
2022-10-25 15:28:54.155 23881-23881/cc.fastcv.codelab D/MainActivity: onServiceConnected: 
2022-10-25 15:28:54.157 23929-23946/cc.fastcv.codelab D/ServerService: register: 107797164
2022-10-25 15:28:56.525 23929-23946/cc.fastcv.codelab D/ServerService: register: 67220341
2022-10-25 15:28:56.527 23929-23929/cc.fastcv.codelab D/ServerService: onUnbind: 
2022-10-25 15:28:56.527 23929-23929/cc.fastcv.codelab D/ServerService: onDestroy:
```

两个值不一样，那么，如果存在多个listener组成一个集合，如：

```
    val nofitys = ArrayList<IServerNotyfyInterface>()
```

那么，在取消监听的时候，就会出现一个问题，我们无法从集合中remove掉这个对象，那这种情况怎么处理呢？我们可以使用：

```
    val nofitys = RemoteCallbackList<IServerNotyfyInterface>()   
    
    nofitys.register(listener)   
    
    nofitys.unregister(listener)
```



#### 简析源码

我们前面简单看过 AIDL文件生成的 接口文件的组成

- 真正的接口文件
- Stub Binder的继承者，接口的实现者，实现底层数据处理逻辑，是个抽象类
- Proxy 接口的代理类，具体接口方法的实现类



然后，看看我们服务端的具体实现

```
    val manager = object : IBookManagerInterface.Stub() {
        override fun getBookList(): MutableList<Book> {
            Log.d(TAG, "getBookList:  pid = ${myPid()}")
            return books
        }

        override fun addBook(book: Book?) {
            Log.d(TAG, "addBook: $book  pid = ${myPid()}")
            if (notify != null && notify!!.asBinder().isBinderAlive && books.size%5 == 0) {
                notify!!.nofity(books.size)
            }
            books.add(book!!)
        }
    }
```



可以看到，这里用匿名类的方法实现了**IBookManagerInterface.Stub** 这个抽象类，并且处理真正的数据。那当我们新增书籍的时候到底做了哪些事情呢？我们看看。

首先在客户端，我们拿到binder对象的方式为：

```
    var stub:IBookManagerInterface? = null
    stub = IBookManagerInterface.Stub.asInterface(service)
```

这里用到了asInterface方法：

```
    public static cc.fastcv.codelab.IBookManagerInterface asInterface(android.os.IBinder obj)
    {
      if ((obj==null)) {
        return null;
      }
      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
      if (((iin!=null)&&(iin instanceof cc.fastcv.codelab.IBookManagerInterface))) {
        return ((cc.fastcv.codelab.IBookManagerInterface)iin);
      }
      return new cc.fastcv.codelab.IBookManagerInterface.Stub.Proxy(obj);
    }
```

将binder本身传入，然后通过Stub.Proxy代理的方式，获取到代理类。

```
    private static class Proxy implements cc.fastcv.codelab.IBookManagerInterface
    {
      private android.os.IBinder mRemote;
      
      Proxy(android.os.IBinder remote)
      {
        mRemote = remote;
      }
      
      @Override public android.os.IBinder asBinder()
      {
        return mRemote;
      }
      
      public java.lang.String getInterfaceDescriptor()
      {
        return DESCRIPTOR;
      }
      
      //得到所有的书籍
      @Override public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException
      {
        ...
      }
      
      //新增书籍

      @Override public void addBook(cc.fastcv.codelab.Book book) throws android.os.RemoteException
      {
        ...
      }
    }
```

可以看到，Stub.Proxy本身与Binder无关，只是引用外部传入的mRemote做的操作，并且实现了IBookManagerInterface接口的相关方法。



那也就是说，调用新增书籍的方法是从这里进入的。

```
      //新增书籍
      @Override public void addBook(cc.fastcv.codelab.Book book) throws android.os.RemoteException
      {
        //分配数据载体对象
        android.os.Parcel _data = android.os.Parcel.obtain();
        //分配数据返回对象
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          //写入标识
          _data.writeInterfaceToken(DESCRIPTOR);
          if ((book!=null)) {
            _data.writeInt(1);
            //写入序列化数据
            book.writeToParcel(_data, 0);
          }
          else {
            _data.writeInt(0);
          }
          //获取数据传输结果
          boolean _status = mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);
          ...
          //读取返回是否有异常信息
          _reply.readException();
        }
        finally {
          //回收资源
          _reply.recycle();
          _data.recycle();
        }
      }
```

这里逻辑比较简单，我们继续看 ``` mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);``` 是怎么样的处理逻辑



这里的**mRemote**，有印象的人会知道它是 IBookManagerInterface.Stub 的实现类，也就是我们在服务端实现的 匿名类，它本身实现的onTransact为：

```
    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
    {
      java.lang.String descriptor = DESCRIPTOR;
      //code 方法标识
      switch (code)
      {
        ...
        case TRANSACTION_addBook:
        {
          //校验标识 如果存在错误的接口类型，则会引发 SecurityException。
          data.enforceInterface(descriptor);
          cc.fastcv.codelab.Book _arg0;
          //检验是否有写入值 如果有则反序列化
          if ((0!=data.readInt())) {
            _arg0 = cc.fastcv.codelab.Book.CREATOR.createFromParcel(data);
          }
          else {
            _arg0 = null;
          }
          this.addBook(_arg0);
          reply.writeNoException();
          return true;
        }
        ...
      }
    }
```

可以看到，这里最终调用了``` this.addBook(_arg0); ``` ，也就是最终调用到了我们实现的匿名类中。



新增是客户端往服务端写，那读取列表是怎么实现的呢？

```
      @Override public java.util.List<cc.fastcv.codelab.Book> getBookList() throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        java.util.List<cc.fastcv.codelab.Book> _result;
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);
          if (!_status && getDefaultImpl() != null) {
            return getDefaultImpl().getBookList();
          }
          _reply.readException();
          //如果没有出现异常，则读取数据
          _result = _reply.createTypedArrayList(cc.fastcv.codelab.Book.CREATOR);
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
        return _result;
      }
```

```
    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
    {
      java.lang.String descriptor = DESCRIPTOR;
      switch (code)
      {
        ...
        case TRANSACTION_getBookList:
        {
          data.enforceInterface(descriptor);
          java.util.List<cc.fastcv.codelab.Book> _result = this.getBookList();
          reply.writeNoException();
          reply.writeTypedList(_result);
          return true;
        }
        ...
      }
    }
```

可以看到，最后就是通过 **reply** 写入返回值。



**总结**

客户端总的来说：（带返回值的）

- 首先创建一个Parcel _data用于传值
- 再创建一个Parcel _reply用于收值
- 最后创建个我们要接收的类型，之后开始写入   如果没有就不写
- 首先_data写入我们的标识， _data.writeInterfaceToken(DESCRIPTOR);
- 如果有值要传入，就写_data.writeStrongBinder((((listener!=null))?(listener.asBinder()):(null)));   否则不写
- 最后发起请求Ibinder.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0)
- 再_reply.readException();
- 最后从_reply 取值   _result = _reply.createTypedArrayList(com.example.pipixia.ipc.aidl.Book.CREATOR);   如果没有值取就不写
- 然后回收 Parcel





服务端：

- data.enforceInterface(descriptor);  必须写
- 如果有返回值 则拿值  java.util.List<com.example.pipixia.ipc.aidl.Book> _result = this.getBookList(); ， 没有则不写
- 如果有传入的值，则拿值 arg0 = com.example.pipixia.ipc.aidl.Book.CREATOR.createFromParcel(data);; ， 没有则不写
- eply.writeNoException();
- 如果有返回值就写这行  reply.writeTypedList(_result);    否则不写
- return true;



这里我们虽然能猜到**onTransact**方法大概是干嘛的，但是它最后一个参数还是要讲一下：

其中四个参数的意义是：

| 字段  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| code  | 是一个整形的唯一标识，用于区分执行哪个方法，客户端会传递此参数，告诉服务端执行哪个方法 |
| data  | 客户端传递过来的参数                                         |
| reply | 服务器返回回去的值                                           |
| flags | 标明是否有返回值，0为有（双向），1为没有（单向）             |



### Binder

说了这么久的Binder，那Binder到底是什么？

IBinder是远程对象的基本接口，是为了高性能而设计的轻量级远程调用机制的核心部分。但它不仅用于远程调用，也用于进程内调用。该接口定义了与远程对象间交互的协议。但不要直接实现 这个接口，而是继承(extends)Binder。

IBinder主要的API是transact()，与之对应的API是Binder.onTransact()。通过前者，你能 想远程IBinder对象发送发出调用，后者使你的远程对象能够响应接收到的调用。IBinder的API都是 Syncronous(同步)执行的，比如transact()直到对方的Binder.onTransact()方法调用玩 后才返回。 调用发生在进程内时无疑是这样的，而在进程间时，在IPC的帮助下，也是同样的效果。

通过transact()发送的数据是Parcel，Parcel是一种一般的缓冲区，除了有数据外还带有 一些描述它内容的元数据。元数据用于管理IBinder对象的引用，这样就能在缓冲区从一个进程移动 到另一个进程时保存这些引用。这样就保证了当一个IBinder被写入到Parcel并发送到另一个进程中， 如果另一个进程把同一个IBinder的引用回发到原来的进程，那么这个原来的进程就能接收到发出的 那个IBinder的引用。这种机制使IBinder和Binder像唯一标志符那样在进程间管理。

系统为每个进程维护一个存放交互线程的线程池。这些交互线程用于派送所有从另外进程发来的IPC 调用。例如：当一个IPC从进程Ａ发到进程Ｂ，Ａ中那个发出调用的线程(这个应该不在线程池中)就阻塞 在transact()中了。进程Ｂ中的交互线程池中的一个线程接收了这个调用，它调用 Binder.onTransact()，完成后用一个Parcel来做为结果返回。然后进程Ａ中的那个等待的线程在 收到返回的Parcel后得以继续执行。实际上，另一个进程看起来就像是当前进程的一个线程， 但不是当前进程创建的。

Binder机制还支持进程间的递归调用。例如，进程Ａ执行自己的IBinder的transact()调用进程Ｂ 的Binder，而进程Ｂ在其Binder.onTransact()中又用transact()向进程Ａ发起调用，那么进程Ａ 在等待它发出的调用返回的同时，还会用Binder.onTransact()响应进程Ｂ的transact()。 总之Binder造成的结果就是让我们感觉到跨进程的调用与进程内的调用没什么区别。

直观来说，Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager(AM，WM，等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端就会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通服务和基于AIDL的服务。



Binder能干什么？Binder可以提供系统中任何程序都可以访问的全局服务。这个功能当然是任何系统都应该提供的，下面我们简单看一下Android的Binder的框架

Android Binder框架分为服务器接口、Binder驱动、以及客户端接口；简单想一下，需要提供一个全局服务，那么全局服务那端即是服务器接口，任何程序即客户端接口，它们之间通过一个Binder驱动访问。

服务器端接口：实际上是Binder类的对象，该对象一旦创建，内部则会启动一个隐藏线程，会接收Binder驱动发送的消息，收到消息后，会执行Binder对象中的onTransact()函数，并按照该函数的参数执行不同的服务器端代码。

Binder驱动：该对象也为Binder类的实例，客户端通过该对象访问远程服务。

客户端接口：获得Binder驱动，调用其transact()发送消息至服务器



Binder在运行过程中，可能由于某些原因导致异常终止了，这个时候我们到服务端的Binder连接断裂（称之为Binder死亡），会导致我们的远程调用失败。更为关键的是，如果我们不知道Binder连接已经断裂，那么客户端的功能就会收到影响。为了解决这个问题，Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath我们可以给Binder设置一个死亡代理，当Binder死亡时，我们就会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接。

```
    val deathRecipient = IBinder.DeathRecipient {
        Log.d(TAG, ": binderDied")
    }

    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            Log.d(TAG, "onServiceConnected: ")
            service?.linkToDeath(deathRecipient,0)
            stub = IBookManagerInterface.Stub.asInterface(service)
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            Log.d(TAG, "onServiceDisconnected: ")
        }
    }
```



默认情况下，我们的远程服务任何人都可以连接，但这不应该是我们愿意看到的。所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务中的方法。这里有两种方式：



声明权限

```
    <permission android:name="com.example.pipixia.ipc.permission" />
```

在需要判断的地方加上这个

```
            val check = checkCallingOrSelfPermission("com.example.pipixia.ipc.permission")            
            if (check == PackageManager.PERMISSION_DENIED) {
                return false
            }
```

申请权限

```
    <uses-permission android:name="com.example.pipixia.ipc.permission" />
```



# Android 8.0

- 在 Android 8.0 （API26）之前，创建前台服务的方式通常是先创建一个后台服务，然后将该服务推到前台。

- Android 8.0 （API26）有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。

- 在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。

- 如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。

```
android.app.RemoteServiceException: Context.startForegroundService() did not then call Service.startForeground()
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1768)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loop(Looper.java:164)
at android.app.ActivityThread.main(ActivityThread.java:6494)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
```



## 解决方法

将 调用 startService启动Service 改为调用 startForegroundService

```
public static void start() {
        Intent intent = new Intent(AppContext.me(), ScoreRefreshServer.class);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            AppContext.me().startForegroundService(intent);
        } else {
            AppContext.me().startService(intent);
        }
}
```



并且，在service的onCreate方法中调用startForeground()

```
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {   
          ...
          Notification.Builder builder = new Notification.Builder(getApplicationContext(), AppEnv.UMENG_CHANNEL)
                    .setContentTitle("正在后台运行")
                    .setSmallIcon(R.mipmap.logo);
          startForeground(1, builder.build());
}
```



可以看到**startForeground** 方法需要传入一个通知，也就是，我们需要给用户一个直观的表现，我们有个应用在后台运行。通知的知识我们会有单独的章节总结。



或者按照官方的推荐，我们使用 **JobIntentService**。

# Android 9.0

在 Android 9.0 中，应用在使用前台服务之前必须先申请 FOREGROUND_SERVICE 权限，否则就会抛出 SecurityException 异常。

此外，由于 FOREGROUND_SERVICE 权限只是普通权限，因此开发者只需在 AndroidManifest.xml 中注册此权限即可，系统会自动对此权限进行授权：



# Android 13.0

这里对通知的改动比较大，所以需要提一下，注意下通知的变化。